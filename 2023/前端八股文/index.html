<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>前端八股文</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="CSS,JavaScript">
    <div style="display:none;"><img src="/img/avatar.jpg"></div>
    <meta property="og:image" content="https://summxu.github.io/img/avatar.jpg">
    <meta name="description" content="传输协议&amp;amp;&amp;amp;浏览器https 协议的工作原理 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。 web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话">
<meta name="keywords" content="CSS,JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股文">
<meta property="og:url" content="https://summxu.github.io/2023/前端八股文/index.html">
<meta property="og:site_name" content="小兵旭旭的博客">
<meta property="og:description" content="传输协议&amp;amp;&amp;amp;浏览器https 协议的工作原理 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。 web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2023-12-10T04:23:58.675Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端八股文">
<meta name="twitter:description" content="传输协议&amp;amp;&amp;amp;浏览器https 协议的工作原理 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。 web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话">
    
        <link rel="alternate" type="application/atom+xml" title="小兵旭旭的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">summxu</h5>
          <a href="mailto:chenxu4012@foxmail.com" title="chenxu4012@foxmail.com" class="mail">chenxu4012@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-align-right"></i>
                时间线
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/JavaScript"  >
                <i class="icon icon-lg icon-star"></i>
                分类标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-grav"></i>
                这是我
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/summxu" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/1938786603" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/atom.xml" target="_blank" >
                <i class="icon icon-lg icon-rss-square"></i>
                Rss
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">前端八股文</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">前端八股文</h1>
        <h5 class="subtitle">
            
                <time datetime="2023-11-21T01:49:38.000Z" itemprop="datePublished" class="page-time">
  2023-11-21
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#传输协议-amp-amp-浏览器"><span class="post-toc-number">1.</span> <span class="post-toc-text">传输协议&amp;&amp;浏览器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#https-协议的工作原理"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">https 协议的工作原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从输入URL到页面加载的全过程"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">从输入URL到页面加载的全过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#浏览器的重绘与重排"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">浏览器的重绘与重排</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTML-amp-amp-CSS"><span class="post-toc-number">2.</span> <span class="post-toc-text">HTML&amp;&amp;CSS</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#script-标签中-defer-和-async的区别"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">script 标签中 defer 和 async的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常见的-meta-标签有哪些？"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">常见的 meta 标签有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是盒模型？"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">什么是盒模型？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文档定位方案"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">文档定位方案</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#position-属性的值有哪些及其区别"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">position 属性的值有哪些及其区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#浮动的解决办法"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">浮动的解决办法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BFC-Block-Formatting-Context-：块级格式化上下文"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">BFC(Block Formatting Context)：块级格式化上下文</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CSS优先级"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">CSS优先级</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CSS继承"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">CSS继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#隐藏元素的方法"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">隐藏元素的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CSS-单位"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">CSS 单位</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#响应式布局方案"><span class="post-toc-number">2.12.</span> <span class="post-toc-text">响应式布局方案</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用CSS实现三角符号"><span class="post-toc-number">2.13.</span> <span class="post-toc-text">用CSS实现三角符号</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JavaScript"><span class="post-toc-number">3.</span> <span class="post-toc-text">JavaScript</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型判断"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">类型判断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#作用域-amp-amp-闭包"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">作用域 &amp;&amp; 闭包</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象-amp-amp-原型-amp-amp-原型链"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">对象 &amp;&amp; 原型 &amp;&amp; 原型链</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#new-的实现步骤"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">new 的实现步骤</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#this-amp-amp-apply-amp-amp-call-amp-amp-bind"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">this &amp;&amp; apply &amp;&amp; call &amp;&amp; bind</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事件循环-EventLoop"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">事件循环 EventLoop</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Vue"><span class="post-toc-number">4.</span> <span class="post-toc-text">Vue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue响应式原理"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Vue响应式原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-Vue-项目中-key-的作用"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">React/Vue 项目中 key 的作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#nextTick的作用和实现原理"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">nextTick的作用和实现原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Vue3的新特性"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">Vue3的新特性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#React"><span class="post-toc-number">5.</span> <span class="post-toc-text">React</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jsx-转换过程"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">jsx 转换过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生命周期"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">生命周期</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数组件和class"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">函数组件和class</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单向数据流（Redux-flux-mobx）"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">单向数据流（Redux,flux,mobx）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#state-usestate-同步异步"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">state usestate 同步异步</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组件设计"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">组件设计</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hooks-amp-amp-HOC"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">hooks &amp;&amp; HOC</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#性能优化"><span class="post-toc-number">5.8.</span> <span class="post-toc-text">性能优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#fribe-amp-amp-diff-amp-amp-virtual-dom"><span class="post-toc-number">5.9.</span> <span class="post-toc-text">fribe &amp;&amp; diff &amp;&amp; virtual dom</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#TypeScript"><span class="post-toc-number">6.</span> <span class="post-toc-text">TypeScript</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#泛型"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">泛型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#联合类型和交叉类型"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">联合类型和交叉类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#type-amp-amp-interface"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">type&amp;&amp;interface</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#any-和-unknown-有什么区别"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">any 和 unknown 有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#never和void的区别"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">never和void的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#断言和类型推断"><span class="post-toc-number">6.6.</span> <span class="post-toc-text">断言和类型推断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常用内置函数及手动实现"><span class="post-toc-number">6.7.</span> <span class="post-toc-text">常用内置函数及手动实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#装饰器-amp-amp-类型守卫"><span class="post-toc-number">6.8.</span> <span class="post-toc-text">装饰器&amp;&amp;类型守卫</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Futrue"><span class="post-toc-number">7.</span> <span class="post-toc-text">Futrue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#微前端"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">微前端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vite-amp-amp-gulp"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">vite&amp;&amp;gulp</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-2023/前端八股文"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">前端八股文</h1>
        <div class="post-meta">
            <time class="post-time" title="2023-11-21 09:49:38" datetime="2023-11-21T01:49:38.000Z"  itemprop="datePublished">2023-11-21</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="传输协议-amp-amp-浏览器"><a href="#传输协议-amp-amp-浏览器" class="headerlink" title="传输协议&amp;&amp;浏览器"></a>传输协议&amp;&amp;浏览器</h2><h3 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h3><ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li>
<li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li>
<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器通过自己的私钥解密出会话密钥。</li>
<li>web 服务器通过会话密钥加密与客户端之间的通信。</li>
</ol>
<h3 id="从输入URL到页面加载的全过程"><a href="#从输入URL到页面加载的全过程" class="headerlink" title="从输入URL到页面加载的全过程"></a>从输入URL到页面加载的全过程</h3><ul>
<li>网络请求部分：<ol>
<li>检查是否有浏览器缓存结果或缓存标识。</li>
<li>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。</li>
<li>建立TCP连接：解析出IP地址后，根据IP地址和端口号，和服务器建立TCP连接。</li>
<li>发起HTTP请求：浏览器发起读取文档的HTTP请求，通过TCP三次握手请求数据。</li>
<li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器。</li>
<li>关闭TCP连接：通过四次挥手释放TCP连接。</li>
</ol>
</li>
<li>浏览器渲染部分：<ol>
<li>构建DOM树：文档分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li>
<li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li>
<li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置（计算的过程）</li>
<li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li>
</ol>
</li>
</ul>
<h3 id="浏览器的重绘与重排"><a href="#浏览器的重绘与重排" class="headerlink" title="浏览器的重绘与重排"></a>浏览器的重绘与重排</h3><ul>
<li>重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li>
<li>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。</li>
<li>如何触发重排和重绘？<ol>
<li>添加、删除、更新DOM节点</li>
<li>通过display: none隐藏一个DOM节点-触发重排和重绘</li>
<li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li>
<li>移动或者给页面中的DOM节点添加动画</li>
<li>添加一个样式表，调整样式属性</li>
<li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>
</ol>
</li>
<li>如何避免重绘或者重排（性能优化）？<ol>
<li>集中改变样式，不要一条一条地修改 DOM 的样式。</li>
</ol>
</li>
</ul>
<h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><blockquote>
<p>浏览器与服务器通信的方式为应答模式，浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器<strong>第一次</strong>向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。</p>
</blockquote>
<ul>
<li><p>接下来浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p>
</li>
<li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p>
<p>知道了缓存机制是怎么运作的时候，在进一步了解具体的缓存规则，可以将浏览器缓存的过程分为两个部分：</p>
</li>
<li><p>服务器会将缓存规则放入HTTP响应头中，控制强制缓存的字段分别是 Expires 和 Cache-Control。Cache-Control高于Expires，一般控制的是强制缓存在什么时间之后失效。</p>
</li>
<li><p>强制缓存判断过程：</p>
<ol>
<li>不存在该缓存结果和缓存标识，则直接向服务器发起请求（这也是第一次发起请求）</li>
<li>存在该缓存结果和缓存标识，且结果尚未失效，直接返回缓存结果。</li>
<li>存在该缓存结果和缓存标识，但该结果已失效，则使用协商缓存。</li>
</ol>
</li>
<li><p>协商缓存在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，控制协商缓存的字段分别有 Last-Modified 、Etag，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p>
</li>
<li><p>强制缓存判断结果：</p>
<ol>
<li>协商缓存生效，返回304</li>
<li>协商缓存失效，返回200和请求结果</li>
</ol>
</li>
</ul>
<h2 id="HTML-amp-amp-CSS"><a href="#HTML-amp-amp-CSS" class="headerlink" title="HTML&amp;&amp;CSS"></a>HTML&amp;&amp;CSS</h2><h3 id="script-标签中-defer-和-async的区别"><a href="#script-标签中-defer-和-async的区别" class="headerlink" title="script 标签中 defer 和 async的区别"></a>script 标签中 defer 和 async的区别</h3><ul>
<li>如果是<code>&lt;script defer&gt;</code>标签，那么就会js脚本与html文档并行加载，并在html文档加载完后再执行js脚本。</li>
<li>如果是<code>&lt;script async&gt;</code>标签，那么js脚本与html文档并行加载，但是与前者不同的是，async在js脚本加载完后会立刻执行。（执行时不能加载html文档）</li>
</ul>
<h3 id="常见的-meta-标签有哪些？"><a href="#常见的-meta-标签有哪些？" class="headerlink" title="常见的 meta 标签有哪些？"></a>常见的 meta 标签有哪些？</h3><ul>
<li>charset 用来描述HTML文档的编码类型</li>
<li>keywords 页面关键字</li>
<li>description 页面描述</li>
<li>refresh 页面重定向和刷新</li>
<li>viewport 适配移动端，可以控制视口大小和比例</li>
<li>robots 搜索引擎索引方式</li>
</ul>
<h3 id="什么是盒模型？"><a href="#什么是盒模型？" class="headerlink" title="什么是盒模型？"></a>什么是盒模型？</h3><ul>
<li>在HTML中的所有的元素，都可以看作为一个盒子。</li>
<li>盒子的组成：margin、padding、border、content</li>
<li>盒模型的类型：<ul>
<li>标准盒模型(box-sizing:content-box)：<br>margin + padding + border + content</li>
<li>IE盒模型(box-sizing:border-box):<br>margin + content(padding + border)</li>
</ul>
</li>
</ul>
<h3 id="文档定位方案"><a href="#文档定位方案" class="headerlink" title="文档定位方案"></a>文档定位方案</h3><ol>
<li>普通流：<ul>
<li>元素按照HTML的先后位置上下布局</li>
<li>行内元素水平排列，当前行被占满之后换行，块级元素渲染为新的一行</li>
<li>所有元素的默认定位是普通流</li>
</ul>
</li>
<li>浮动：<ul>
<li>元素首先按照普通流的方式呈现，然后尽可能的向左或者向右偏移</li>
<li>浮动脱离了普通流元素</li>
</ul>
</li>
<li>绝对/相对定位<ul>
<li>绝对/相对脱离了普通流元素，不会影响兄弟元素</li>
</ul>
</li>
</ol>
<h3 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h3><ul>
<li>固定定位 fixed：元素相对于浏览器窗口的固定定位，定位元素脱离文档流，不占据空间。</li>
<li>绝对定位 absolute：元素相对于最近的<strong>已定位的父元素</strong>定位，定位元素脱离文档流，不占据空间。</li>
<li>相对定位 relative：元素出现在本来的位置上，但是可以设置left、top等定位属性，如果设置了定位属性，元素会进行移动，但是仍占据本来所在的空间，所以相对定位也可以层叠到其他元素上面。</li>
<li>默认定位 Static：默认值。没有定位，在文档流中，占据空间，不能使用定位属性和z-index。</li>
<li>粘性定位 sticky：依赖于用户的滚动，在 relative 与 fixed 定位之间切换，而当页面滚动超出目标区域时，它会使用fixed固定在目标位置，否则使用relative定位在本来的位置上。</li>
</ul>
<h3 id="浮动的解决办法"><a href="#浮动的解决办法" class="headerlink" title="浮动的解决办法"></a>浮动的解决办法</h3><blockquote>
<p>清除浮动解决的是浮动元素的父元素的高度问题。原因是父元素没有设置高度，原本的高度，是由子元素撑起来的。当子元素浮动的时候，子元素是脱离文档流的,而父元素还是文档流里，这个时候，父元素的content没有东西，所以父元素的height就变为原本没有设置的高度（为0）。</p>
</blockquote>
<ol>
<li><p>把父元素创建为BFC（<strong>计算BFC高度的时候，浮动元素也会参与计算</strong>）。</p>
</li>
<li><p>为<strong>下一个</strong>块级兄弟元素添加样式 clear:both</p>
</li>
<li><p>父元素使用after，创建块级子伪元素，设置属性 clear:both;</p>
<blockquote>
<p>clear:both;(告诉浏览器一直到这个元素都不需要浮动);</p>
</blockquote>
</li>
</ol>
<h3 id="BFC-Block-Formatting-Context-：块级格式化上下文"><a href="#BFC-Block-Formatting-Context-：块级格式化上下文" class="headerlink" title="BFC(Block Formatting Context)：块级格式化上下文"></a>BFC(Block Formatting Context)：块级格式化上下文</h3><ul>
<li>BFC是指<strong>块级元素</strong>区域在页面中的渲染（排版）规则：<ol>
<li>普通流的元素垂直方向的外边距会发生重叠。属于不同BFC的元素外边距不会发生重叠。</li>
<li>BFC元素是一个独立的容器，外面的元素不会影响里面的元素。</li>
<li>计算BFC高度的时候，BFC内部的浮动元素也会参与计算。</li>
</ol>
</li>
<li>BFC作用<ol>
<li>清除浮动（<strong>计算BFC高度的时候，浮动元素也会参与计算</strong>）</li>
<li>解决垂直外边距塌陷（<strong>属于不同BFC的元素外边距不会发生重叠</strong>）</li>
<li>防止兄弟float元素覆盖（<strong>BFC的区域不会与浮动元素的布局重叠,float也是BFC</strong>)</li>
</ol>
</li>
<li>BFC的创建（为元素添加属性触发BFC渲染）：<ol>
<li>overflow:hidden;</li>
<li>float:left;float:right;</li>
<li>position:absolute;position:fixed;</li>
<li>display属性为inline-block,table,table-cell,table-caption,flex,inline-flex,grid;</li>
</ol>
</li>
</ul>
<h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h3><blockquote>
<p>css选择器冲突（多个选择器选择了相同的元素）导致出现选择器优先级问题</p>
</blockquote>
<ul>
<li>选择器类型：!important &gt; 行内 &gt; ID &gt; 类\伪类\属性 &gt; 标签 &gt; 全局（*）</li>
<li>选择器层级：（兄弟、子、后代）选择器，层级多的覆盖层级少的</li>
<li>代码先后顺序：后出现的代码覆盖先出现的</li>
</ul>
<h3 id="CSS继承"><a href="#CSS继承" class="headerlink" title="CSS继承"></a>CSS继承</h3><blockquote>
<p>css三大特性：继承、层叠、优先级</p>
</blockquote>
<ul>
<li>字体属性：font</li>
<li>文本属性：line-height、color、text-align</li>
<li>元素可见性：visibility: hidden</li>
<li>表格布局：border-spacing</li>
<li>列表属性：list-style</li>
</ul>
<h3 id="隐藏元素的方法"><a href="#隐藏元素的方法" class="headerlink" title="隐藏元素的方法"></a>隐藏元素的方法</h3><ul>
<li>display: none 隐藏元素，不占据页面位置</li>
<li>opactiy: 0 设置元素完全透明，占据页面位置</li>
<li>visibility: hidden 隐藏元素，占据页面位置</li>
</ul>
<h3 id="CSS-单位"><a href="#CSS-单位" class="headerlink" title="CSS 单位"></a>CSS 单位</h3><ul>
<li>px 在屏幕上显示出的绝对像素</li>
<li>em 相对与父级元素font-size比例的长度/大小（1em = 父级元素的font-size(px))</li>
<li>rem 相对与HTML元素font-size比例的长度/大小（1em = HTML元素的font-size(px))</li>
<li>% 相对于父级长度/大小的百分比</li>
<li>vw 把屏幕的宽度切成100份，每一份就是1vw</li>
<li>vh 把屏幕的高度切成100份，每一份就是1vh</li>
</ul>
<h3 id="响应式布局方案"><a href="#响应式布局方案" class="headerlink" title="响应式布局方案"></a>响应式布局方案</h3><ol>
<li>媒体查询：一套代码针对电脑、pad和移动设备，屏幕宽度相差悬殊的时候，使用@media(min-width) and (max-width)方法划分区域，单独做适应不同屏幕宽度的样式适配。</li>
<li>rem 计算屏幕宽度，动态设置html字体大小，等比缩放整体页面。</li>
<li>postcss 通过设计稿比例，在编译过程中把px转换成 vm/rem 单位。</li>
</ol>
<h3 id="用CSS实现三角符号"><a href="#用CSS实现三角符号" class="headerlink" title="用CSS实现三角符号"></a>用CSS实现三角符号</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过元素border的渲染机制实现的 */</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><ol>
<li><code>typeof &#39;123&#39;</code> 可以区分基本数据类型，但引用数据类型都返回Object</li>
<li><code>&#39;123&#39; instanceof String</code> 可以区分引用数据类型，但不能区分基本数据类型</li>
<li><code>Object.prototype.toString.call(&#39;123&#39;)</code> 返回 <code>[Object Array]</code> 可以判断所有数据类型</li>
</ol>
<h3 id="作用域-amp-amp-闭包"><a href="#作用域-amp-amp-闭包" class="headerlink" title="作用域 &amp;&amp; 闭包"></a>作用域 &amp;&amp; 闭包</h3><ul>
<li>作用域<ol>
<li>全局作用域，在js中的任何地方都可以访问。</li>
<li>函数作用域，只能在函数内部或子函数中访问。</li>
<li>块级作用域 { }，if for…</li>
</ol>
</li>
<li>变量提升<ol>
<li>var 的变量声明会提升到<strong>当前作用域（无视块级作用域）</strong>最顶部在进行赋值。</li>
<li>function的声明会提升到<strong>当前作用域（无视块级作用域）</strong>最顶部，function 的提升优先级大于 var。</li>
<li>const 和 let 不会提升，并且之在块级作用域生效，他们在作用域内只能被声明一次</li>
<li>const 声明的时候必须赋值，let 可以只声明不赋值，默认是 undefind</li>
<li>const 的值不可修改，但引用类型的赋值，可以修改其属性。</li>
</ol>
</li>
<li>闭包<ul>
<li>函数在执行时会形成属于函数的作用域，在函数执行完后，作用域就会被清理，内存也会被回收。但是在函数嵌套的时候，内部函数可以访问上级函数的变量，导致即使上级函数执行完，也不会被销毁，这时的内部函数就是闭包。</li>
<li>特点：</li>
</ul>
<ol>
<li>保护外部函数的变量不受污染</li>
<li>延长局部变量的生命周期（不会被回收）</li>
<li>会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</li>
</ol>
<ul>
<li>用途：</li>
</ul>
<ol>
<li>节流、防抖记录timer</li>
<li>模仿块级作用域创建模块</li>
</ol>
</li>
</ul>
<h3 id="对象-amp-amp-原型-amp-amp-原型链"><a href="#对象-amp-amp-原型-amp-amp-原型链" class="headerlink" title="对象 &amp;&amp; 原型 &amp;&amp; 原型链"></a>对象 &amp;&amp; 原型 &amp;&amp; 原型链</h3><ul>
<li>创建对象：<ol>
<li>字面量 <code>const obj = {}</code></li>
<li>Object.create(prototype, descriptors)</li>
<li>构造函数 <code>function Person() { this.name = &#39;张三&#39; };new Person()</code>，构造函数拥有<strong>constructor</strong>属性，也有原型的概念。</li>
</ol>
</li>
<li>原型：<br>在 JS 中，每创建一个对象时，对象中都会包含一些预定义的属性。其中每个构造函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。</li>
<li>原型链：<br>构造函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现对象的继承，还有一个<strong>原型链指针<strong>proto</strong></strong>，该指针指向的是上层原型对象，因此可以利用<strong>proto</strong>一直向上引用到 Object 再到 null 。这样就形成了原型链的概念。</li>
<li>特点：<br>JavaScript对象是通过引用来传递的，创建的每个新对象实例中并没有一份属于自己的原型副本，所以修改原型时，与之相关的对象也会继承这一改变。 </li>
</ul>
<h3 id="new-的实现步骤"><a href="#new-的实现步骤" class="headerlink" title="new 的实现步骤"></a>new 的实现步骤</h3><ol>
<li>创建一个新的空对象。</li>
<li>把对象的原型<code>__proto__</code>指向传入的构造函数的原型链<code>prototype</code>.</li>
<li>把构造函数的this，绑定到新对象上（对象添加了构造函数的新属性）。</li>
<li>判断构造函数的返回值，如果是值类型则返回这个对象，如果是引用类型，就返回这个引用类型的对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newFun = <span class="function">(<span class="params">Fun, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = &#123;&#125;</span><br><span class="line">    newObj.__proto__ = Fun.prototype</span><br><span class="line">    <span class="keyword">const</span> result = Fun.apply(newObj, args)</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : newObj</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="this-amp-amp-apply-amp-amp-call-amp-amp-bind"><a href="#this-amp-amp-apply-amp-amp-call-amp-amp-bind" class="headerlink" title="this &amp;&amp; apply &amp;&amp; call &amp;&amp; bind"></a>this &amp;&amp; apply &amp;&amp; call &amp;&amp; bind</h3><ul>
<li>apply 接受参数的是数组<code>Function.apply(this,[arg1,arg2])</code></li>
<li>call 接受参数的是参数列表<code>Function.call(this,arg1,arg2)</code></li>
<li>bind 返回一个改变了this的新函数<code>Function.bind(this)(arg1,arg2)</code></li>
<li>this</li>
</ul>
<ol>
<li>全局作用域下或者作为普通函数执行时，this指向window。</li>
<li>当函数作为对象的方法被调用时，this就会指向该对象。</li>
<li>new 会改变函数的this指向，构造函数中的this指向的是实例对象。</li>
<li>箭头函数的this指向当前函数在哪个对象下面。</li>
<li>Function原型上的apply、call、bind改变this指向到指定的调用函数。</li>
</ol>
<h3 id="事件循环-EventLoop"><a href="#事件循环-EventLoop" class="headerlink" title="事件循环 EventLoop"></a>事件循环 EventLoop</h3><p>  JS是单线程的，为了防止一个<strong>函数</strong>执行时间过长阻塞后面的代码，所以区分了同步代码和异步队列，异步队列又分为宏任务队列和微任务队列，通过先后顺序反复将不同任务压入执行栈中执行的过程就形成了事件循环。因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列，事件循环是由浏览器来实现的。</p>
<ol>
<li>函数入执行栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li>
<li>此期间WebAPIs完成这个事件，把<strong>回调函数</strong>放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li>
<li>当同步代码执行栈执行完毕，Event Loop开始找微任务队列，并把微任务放到执行栈中执行。</li>
<li>微任务执行栈执行完毕后，进入宏任务队列。在一轮循环里，<strong>先执行一个宏任务</strong>，执行完成后查看微任务队列是否有任务，有的话，清空微任务队列，在执行下一个红任务，再继续查找微任务队列，如此循环，清空微任务队列，直至清空所有的任务。</li>
</ol>
<ul>
<li>宏任务（浏览器提供的）：<ol>
<li>setTimeout</li>
<li>setInterval</li>
<li>ajax</li>
<li>onClick</li>
</ol>
</li>
<li>微任务（语言本身提供的）<ol>
<li>Promise.then</li>
<li>async await</li>
</ol>
</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><p>  vue.js是MVVM框架，数据变化的时候，视图也会自动更新。采用数据劫持+发布者-观察者模式的方式，在数据变动时触发相应的监听回调，从而使视图更新。</p>
<ul>
<li><p><strong>Observer（数据监听器）</strong> : Observer的核心是遍历data对象里的属性，通过Object.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。在被遍历到的每一个属性中，都会添加一个Dep的实例，它内部有个subscribes队列，保存着依赖本数据的观察者，当本数据发生变化时，调用dep.notify()通知观察者watcher。</p>
</li>
<li><p><strong>Watcher（观察者）</strong> : Watcher的实例有很多，它可以是视图模板中使用的变量、计算属性、侦听器。</p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己。</li>
<li>自身必须有一个update()方法。</li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。</li>
</ol>
</li>
<li><p><strong>Compile（指令解析器）</strong> : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，每个指令对应的节点绑定更新函数，一旦数据有变动，收到通知，更新视图。</p>
</li>
</ul>
<h3 id="React-Vue-项目中-key-的作用"><a href="#React-Vue-项目中-key-的作用" class="headerlink" title="React/Vue 项目中 key 的作用"></a>React/Vue 项目中 key 的作用</h3><ol>
<li>是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM;在vue的diff函数中，会根据key去数组中对比新旧节点，而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找，map映射的速度更快。</li>
<li>在v-for的时候，vue采用了“就地复用”的更新策略，如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是使用key作为索引来显示已被渲染过的每个元素，重复的key会造成渲染错误。</li>
</ol>
<h3 id="nextTick的作用和实现原理"><a href="#nextTick的作用和实现原理" class="headerlink" title="nextTick的作用和实现原理"></a>nextTick的作用和实现原理</h3><p>  nextTick是解决vue在数据变化操作之后，立即获取DOM元素而取不到的问题。nextTick接受一个回调函数作为参数，同时在vue3中，nextTick会返回一个Promise。</p>
<p>  Vue在更新DOM时是异步执行的，更改响应式状态时，Vue将开启一个缓存队列，<strong>同一事件循环</strong>如果一个watcher被多次触发，只会被推入到队列中一次，直到下一个“tick”才一起执行，这样避免不必要的计算。</p>
<ul>
<li>vue2中的DOM异步更新和nextTick主要使用了宏任务和微任务执行回调的时机来实现，根据执行环境分别尝试采用Promise、MutationObserver、setTimeout。nextTick的任务队列在DOM更新的后面。</li>
<li>vue3中的nextTick默认采用了Pormise来实现，并且他默认返回一个Promise，这样同时也能使用 await 在事件循环结束之后操作DOM。</li>
</ul>
<h3 id="Vue3的新特性"><a href="#Vue3的新特性" class="headerlink" title="Vue3的新特性"></a>Vue3的新特性</h3><ol>
<li>响应式原理改变，数据劫持由Object.defineProperty改为Proxy/Reflect。<ul>
<li>defineProperty只能劫持对象里某个属性的getter/setter，需要对vueData里的对象进行遍历递归，后添加的属性也无法实现响应式拦截，还需要重写大量的js原型实现完美响应式。</li>
<li>而Porxy利用ES6原生实现可以劫持整个对象的增删改查操作，配合上Reflect，提升了响应式实现的性能。</li>
<li>Reflect是为了操作对象而提供的API，他能把对象的操作都变成函数的行为，配合Proxy它能起到的作用是:<ol>
<li>触发代理对象的劫持时保证正确的 this 上下文指向</li>
<li>能使框架避免在操作对象时更健壮，避免一些报错。</li>
</ol>
</li>
</ul>
</li>
<li>Composition API的引入能更加灵活地组织代码和重用组件逻辑，不像Options API那样需要写在特定的代码块内，常见的新API有：<ul>
<li>createApp 创建应用实例，相当于 new Vue</li>
<li>provide、inject 局部范围内组件的传值，类似React useContext</li>
<li>ref、reactive 定义响应式数据。ref 定义基本结构数据，reactive 定义复杂结构数据<br>(Proxy只能<strong>代理对象</strong>，而ref又可以定义一个响应式的基本属性，vue在ref内部把基本属性包装成了对象，对象里只有一个属性是 <strong>value</strong>)</li>
<li>computed 计算属性，有返回值，依赖数据发生改变就会重新计算</li>
<li>watch、watchEffect watch 是监听一个值的变化，watchEffect是收集依赖数据发生变化就执行</li>
<li>toRef、toRefs 解构单个reactive中的数据和解构整个reactive中的数据 </li>
<li>getCurrentInstance 获取当前vue组件的实例</li>
</ul>
</li>
<li>teleport、Suspense、Fragment组件<ul>
<li>teleport 控制渲染位置，组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去，多用于modal弹出控制位置</li>
<li>Suspense 当要加载的组件都满足条件时，才会进行渲染。</li>
<li>Fragment 组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中。</li>
</ul>
</li>
</ol>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React是一个网页UI库，它主要通过组件化的方式解决视图层开发复用的问题。React的核心设计思路有三点：声明式、组件化、通用性。</p>
<ol>
<li>声明式：声明式的编写方式对比命令式可以做到直观和便于组合。</li>
<li>组件化：组件化的优势在于视图拆分和模块复用，更容易做到高内聚低耦合。</li>
<li>通用性：通用性在于一次学习随处编写。比如ReactNative，这靠的是虚拟DOM来实现的。这使得React的范围足够广，web、native都可以开发，这也是React的优势。</li>
</ol>
<p>React作为视图层的框架，他并没有提供一揽子的解决方案，在开发大型应用时需要在社区寻找、整合解决方案，在技术选型和学习上造成了一些成本。</p>
<h3 id="jsx-转换过程"><a href="#jsx-转换过程" class="headerlink" title="jsx 转换过程"></a>jsx 转换过程</h3><ul>
<li>jsx的解析和转换主要依靠Babel来实现，通过Babel转换成React.createElement对节点的描述</li>
<li>React.createElement生成虚拟DOM树，通过几种不同的节点类型来判断虚拟DOM生成：<ol>
<li>原生标签节点</li>
<li>文本节点</li>
<li>函数组件</li>
<li>类组件</li>
</ol>
</li>
<li>最后通过 ReactDom.render() 根据不同类型挂载成真实DOM.</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="函数组件和class"><a href="#函数组件和class" class="headerlink" title="函数组件和class"></a>函数组件和class</h3><h3 id="单向数据流（Redux-flux-mobx）"><a href="#单向数据流（Redux-flux-mobx）" class="headerlink" title="单向数据流（Redux,flux,mobx）"></a>单向数据流（Redux,flux,mobx）</h3><h3 id="state-usestate-同步异步"><a href="#state-usestate-同步异步" class="headerlink" title="state usestate 同步异步"></a>state usestate 同步异步</h3><h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><h3 id="hooks-amp-amp-HOC"><a href="#hooks-amp-amp-HOC" class="headerlink" title="hooks &amp;&amp; HOC"></a>hooks &amp;&amp; HOC</h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="fribe-amp-amp-diff-amp-amp-virtual-dom"><a href="#fribe-amp-amp-diff-amp-amp-virtual-dom" class="headerlink" title="fribe &amp;&amp; diff &amp;&amp; virtual dom"></a>fribe &amp;&amp; diff &amp;&amp; virtual dom</h3><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>  Typescript是js的超集，为js提供了静态类型检查，在js的基础上引入了面向对象的一些概念：类、接口、继承、范型。ts提供了类型注解、类型推断，在编译时就能保证类型的正确。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>  泛型是提供创建可重用组件的方法的工具，使用传参的形式将类型传递给函数或者接口，并在使用时指定具体的类型。</p>
<h3 id="联合类型和交叉类型"><a href="#联合类型和交叉类型" class="headerlink" title="联合类型和交叉类型"></a>联合类型和交叉类型</h3><ul>
<li>交叉类型：将多个类型合并成一个类型，新类型将具有多个类型的所有特性。&amp;</li>
<li>联合类型：表示一个值可以有多种类型的之一。｜</li>
</ul>
<h3 id="type-amp-amp-interface"><a href="#type-amp-amp-interface" class="headerlink" title="type&amp;&amp;interface"></a>type&amp;&amp;interface</h3><ul>
<li>相同点：<ol>
<li>都可以描述一个对象或者函数类型</li>
<li>都允许extends，并且可以互相扩展</li>
</ol>
</li>
<li>不同点：<ol>
<li>type 可以声明基本类型别名、联合类型、元组类型</li>
<li>type 支持typeof获取实例的类型进行赋值</li>
<li>interface 可以声明合并（交叉）</li>
</ol>
</li>
</ul>
<h3 id="any-和-unknown-有什么区别"><a href="#any-和-unknown-有什么区别" class="headerlink" title="any 和 unknown 有什么区别"></a>any 和 unknown 有什么区别</h3><p>  any和unknown都能在不能确定变量类型的时候使用，unknown更加严格，any直接不做类型检查。</p>
<ul>
<li>任何类型的数据都可以赋给 unknown 类型，unknown 类型的值也不能将值赋给 any 和 unknown 之外的类型变量</li>
<li>unknown类型的值不能确定内部属性。</li>
</ul>
<h3 id="never和void的区别"><a href="#never和void的区别" class="headerlink" title="never和void的区别"></a>never和void的区别</h3><ul>
<li>void表示没有任何类型（可以赋值为null和undefind）</li>
<li>never表示一个不包含值的类型，never类型的变量永远不存在值</li>
<li>拥有void返回值的函数可以正常运行，拥有never返回值的函数无法正常返回。</li>
</ul>
<h3 id="断言和类型推断"><a href="#断言和类型推断" class="headerlink" title="断言和类型推断"></a>断言和类型推断</h3><ul>
<li>类型推断：Typescript允许编译器根据上下文自动推断出变量的类型，从而减少手动类型输入的工作量。</li>
<li>类型断言：类似于类型强制转换，它建议编译器忽略自动推断，将变量强制视为某种类型。</li>
</ul>
<h3 id="常用内置函数及手动实现"><a href="#常用内置函数及手动实现" class="headerlink" title="常用内置函数及手动实现"></a>常用内置函数及手动实现</h3><ul>
<li><p>keyof关键字，用于获取对象类型的所有键的联合类型</p>
</li>
<li><p>Partial<t> 生成一个新的对象类型，属性全部变成可选的</t></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Required<t> 将一个对象类型中的所有属性变为必需的。</t></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Readonly<t> 将类型中的所有属性都变成只读的</t></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Record&lt;K, T&gt; 创建一个新的对象类型，指定对象属性名类型和属性值类型。其属性名类型为 K，属性值类型为 T</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Pick&lt;T, K&gt; 从类型中选择指定的属性，并返回一个新的对象类型：Pick&lt;Person, ‘name’ | ‘age’&gt;</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;SourceType, KeysType <span class="keyword">extends</span> keyof SourceType&gt; = &#123;</span><br><span class="line">  [KeyType <span class="keyword">in</span> KeysType]: SourceType[KeyType];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Omit&lt;T, K&gt; 创建新的类型，可以从一个类型中省略指定的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> omit = &lt;T, K <span class="keyword">extends</span> keyof T&gt;(obj: T, ...keys: K[]): Omit&lt;T, K&gt; =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> result = &#123; ...obj &#125;;</span><br><span class="line">keys.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> result[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="装饰器-amp-amp-类型守卫"><a href="#装饰器-amp-amp-类型守卫" class="headerlink" title="装饰器&amp;&amp;类型守卫"></a>装饰器&amp;&amp;类型守卫</h3><ul>
<li>装饰器是一种特殊的语法，它可以用来修饰类、方法、属性以及参数等元素，在ts中用@开头声明装饰器</li>
<li>类型守卫是判断类型的一种方法，常见的方法包括：instanceof、typeof、in操作符等，也可以自定义函数实现类型判断。</li>
</ul>
<h2 id="Futrue"><a href="#Futrue" class="headerlink" title="Futrue"></a>Futrue</h2><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><ul>
<li>样式隔离 <a href="https://blog.csdn.net/qiwoo_weekly/article/details/127399589" target="_blank" rel="noopener">https://blog.csdn.net/qiwoo_weekly/article/details/127399589</a></li>
<li>manifest.json</li>
<li>web components</li>
</ul>
<h3 id="vite-amp-amp-gulp"><a href="#vite-amp-amp-gulp" class="headerlink" title="vite&amp;&amp;gulp"></a>vite&amp;&amp;gulp</h3>
        </div>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://summxu.github.io/2023/前端八股文/&title=《前端八股文》 — 小兵旭旭的博客&pic=https://summxu.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://summxu.github.io/2023/前端八股文/&title=《前端八股文》 — 小兵旭旭的博客&source=小兵旭旭" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://summxu.github.io/2023/前端八股文/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《前端八股文》 — 小兵旭旭的博客&url=https://summxu.github.io/2023/前端八股文/&via=https://summxu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://summxu.github.io/2023/前端八股文/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2023/样式隔离与穿透/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">样式隔离与穿透</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2023/现代CSS解决方案：原生支持的三角函数/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">现代CSS解决方案：原生支持的三角函数</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
  <div class="top" style="display: none;">
    
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


    <p>
      <!-- 
      <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
            class="icon icon-lg icon-rss"></i></a></span>
       -->
      <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
    </p>
  </div>
  <div class="bottom">
    <p><span>summxu &copy;
        2017 -
        2023</span>
      <span>
        
        Power by Hexo
      </span>
    </p>
  </div>
</footer>
    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://summxu.github.io/2023/前端八股文/&title=《前端八股文》 — 小兵旭旭的博客&pic=https://summxu.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://summxu.github.io/2023/前端八股文/&title=《前端八股文》 — 小兵旭旭的博客&source=小兵旭旭" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://summxu.github.io/2023/前端八股文/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《前端八股文》 — 小兵旭旭的博客&url=https://summxu.github.io/2023/前端八股文/&via=https://summxu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://summxu.github.io/2023/前端八股文/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3aQW7DQAgF0Nz/0u62UhL3A0kl4zcrK7I787pADPB4xOt4Wr9/T958fud8l8c3FgYGxmUZx+lKNkg2Tv7+u+fzbzEwMO7DOD9css0k4CZ7/XFmDAwMjDgdrKaVOQkDAwOjyqgmeUmAxsDAwDhn5Ifrlcby979+F8fAwLggIz/E/z9/pb+BgYFxKcZRXL3QWW0wlE+FgYGxmtFrQPZCZPNweaKJgYGxlNFrUn7qwtlrFbz4BQMD4zaMPLwmYbQapnttBgwMjLsxem3IBNALvknSWU4NMTAwLshIguZ8bGI+WhHBMDAwljKqobA6kJGzP9zCxMDAWMSYDF7kieBkpGweoDEwMHYw8ovopFSXtxZ64R4DA2M3Iz90XvyqtiGr1+bCjRwDA+PijN4l9rPsvFH69lsMDIzVjLz4Xg2OyThF/k9p3sIxMDBWM6ohNS/xH8XV7MpiYGCsY/Q+/kYbIA/3zZELDAyMyzLOE69JWMyHyXohHgMD4z6MvEmZF+Z6xbVquvk2NcTAwFjK6N13q0W0yehGFHAxMDBWM/JW4uSamhfmqgEdAwNjK6NXps+fJyMX+XUXAwNjNyNfSfJXPWJ1sKM5bIGBgbGCMSpyjRuc1SGPwrAFBgbGOkavqdl7c5LklRsDGBgYt2RUG5/Vol6ztIeBgYERB81JkS4Psi8wGBgYN2DkYxPVAly1PZCMZWBgYNyN0bs65gX9URgdj2hgYGBcnPEDpftBz7TKDroAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };

</script>

<script src="/js/main.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</body>
</html>
