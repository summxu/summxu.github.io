<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Redux源码全面解析</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript">
    <div style="display:none;"><img src="/img/avatar.jpg"></div>
    <meta property="og:image" content="https://summxu.github.io/img/avatar.jpg">
    <meta name="description" content="Redux使用中的几个点：  Redux三大设计原则 Create Store Redux middleware combineReducer Provider与Connect Redux流程梳理 Redux设计特点  1. 单一数据源在传统的 MVC 架构中，可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="Redux源码全面解析">
<meta property="og:url" content="https://summxu.github.io/2022/Redux源码全面解析/index.html">
<meta property="og:site_name" content="小兵旭旭的博客">
<meta property="og:description" content="Redux使用中的几个点：  Redux三大设计原则 Create Store Redux middleware combineReducer Provider与Connect Redux流程梳理 Redux设计特点  1. 单一数据源在传统的 MVC 架构中，可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://sslstatic.ktanx.com/images/release/201811/Tr2gHBdB9tYoeS97.png">
<meta property="og:image" content="https://sslstatic.ktanx.com/images/release/201811/IArjf9kjKecPhnFF.png">
<meta property="og:image" content="https://sslstatic.ktanx.com/images/release/201811/4g40yEqEfjeRqxs6.png">
<meta property="og:updated_time" content="2024-01-08T05:48:03.082Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redux源码全面解析">
<meta name="twitter:description" content="Redux使用中的几个点：  Redux三大设计原则 Create Store Redux middleware combineReducer Provider与Connect Redux流程梳理 Redux设计特点  1. 单一数据源在传统的 MVC 架构中，可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。">
<meta name="twitter:image" content="https://sslstatic.ktanx.com/images/release/201811/Tr2gHBdB9tYoeS97.png">
    
        <link rel="alternate" type="application/atom+xml" title="小兵旭旭的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">summxu</h5>
          <a href="mailto:chenxu4012@foxmail.com" title="chenxu4012@foxmail.com" class="mail">chenxu4012@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-align-right"></i>
                时间线
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/JavaScript"  >
                <i class="icon icon-lg icon-star"></i>
                分类标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-grav"></i>
                这是我
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/summxu" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/1938786603" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/atom.xml" target="_blank" >
                <i class="icon icon-lg icon-rss-square"></i>
                Rss
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Redux源码全面解析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Redux源码全面解析</h1>
        <h5 class="subtitle">
            
                <time datetime="2022-02-26T01:36:37.000Z" itemprop="datePublished" class="page-time">
  2022-02-26
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-单一数据源"><span class="post-toc-number">1.</span> <span class="post-toc-text">1. 单一数据源</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-状态是只读的"><span class="post-toc-number">2.</span> <span class="post-toc-text">2. 状态是只读的</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-状态修改均由纯函数完成"><span class="post-toc-number">3.</span> <span class="post-toc-text">3.状态修改均由纯函数完成</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-Create-Store"><span class="post-toc-number"></span> <span class="post-toc-text">2.Create Store</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#getState"><span class="post-toc-number"></span> <span class="post-toc-text">getState</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#subscribe"><span class="post-toc-number"></span> <span class="post-toc-text">subscribe</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#dispatch"><span class="post-toc-number"></span> <span class="post-toc-text">dispatch</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#replaceReducer"><span class="post-toc-number"></span> <span class="post-toc-text">replaceReducer</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-Redux-middleware"><span class="post-toc-number"></span> <span class="post-toc-text">3.Redux middleware</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-combineReducer"><span class="post-toc-number"></span> <span class="post-toc-text">4.combineReducer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-Provider与Connect"><span class="post-toc-number"></span> <span class="post-toc-text">5. Provider与Connect</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Provider"><span class="post-toc-number"></span> <span class="post-toc-text">Provider</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Connect"><span class="post-toc-number"></span> <span class="post-toc-text">Connect</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-mapStateToProps"><span class="post-toc-number">1.</span> <span class="post-toc-text">1.mapStateToProps</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-mapDispatchToProps"><span class="post-toc-number">2.</span> <span class="post-toc-text">2.mapDispatchToProps</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-mergeProps"><span class="post-toc-number">3.</span> <span class="post-toc-text">3.mergeProps</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-options"><span class="post-toc-number">4.</span> <span class="post-toc-text">4.options</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-Redux流程梳理"><span class="post-toc-number"></span> <span class="post-toc-text">6. Redux流程梳理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-Redux设计技巧"><span class="post-toc-number"></span> <span class="post-toc-text">7.Redux设计技巧</span></a>
        </nav>
    </aside>


<article id="post-2022/Redux源码全面解析"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Redux源码全面解析</h1>
        <div class="post-meta">
            <time class="post-time" title="2022-02-26 09:36:37" datetime="2022-02-26T01:36:37.000Z"  itemprop="datePublished">2022-02-26</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>Redux使用中的几个点：</p>
<ol>
<li>Redux三大设计原则</li>
<li>Create Store</li>
<li>Redux middleware</li>
<li>combineReducer</li>
<li>Provider与Connect</li>
<li>Redux流程梳理</li>
<li>Redux设计特点</li>
</ol>
<h4 id="1-单一数据源"><a href="#1-单一数据源" class="headerlink" title="1. 单一数据源"></a>1. 单一数据源</h4><p>在传统的 MVC 架构中，可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。因为在 Redux 的思想里，一个应用永远只有唯一的数据源。实际上，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样随时可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）。此外，这样的设计也为服务端渲染提供了可能。</p>
<h4 id="2-状态是只读的"><a href="#2-状态是只读的" class="headerlink" title="2. 状态是只读的"></a>2. 状态是只读的</h4><p>在 Redux 中，并不会自己用代码来定义一个 store。取而代之的是，定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里并没有直接修改应用的状态，而是返回了一份全新的状态。</p>
<p>Redux 提供的 createStore 方法会根据 reducer 生成 store。最后，可以利用 store. dispatch方法来达到修改状态的目的。</p>
<h4 id="3-状态修改均由纯函数完成"><a href="#3-状态修改均由纯函数完成" class="headerlink" title="3.状态修改均由纯函数完成"></a>3.状态修改均由纯函数完成</h4><p>在 Redux 里，通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。</p>
<p>这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux 利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发 action 而改变状态的结果成为了可能。</p>
<h2 id="2-Create-Store"><a href="#2-Create-Store" class="headerlink" title="2.Create Store"></a>2.Create Store</h2><p>从store的诞生开始说起。create store函数API文档如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createStore(reducer, [initialState], enhancer)</span><br></pre></td></tr></table></figure>

<p>可以看出，它接受三个参数：reducer、initialState 和 enhancer 。Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。</p>
<p>再来看看他的返回值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    dispatch: f (action),</span><br><span class="line">    getState: f (),</span><br><span class="line">    replaceReducer: f (nextReducer),</span><br><span class="line">    subscribe: f (listener),</span><br><span class="line">    <span class="built_in">Symbol</span>(observable): f ()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>store的返回值就是一个普通对象，里面有几个常用的方法：</p>
<ul>
<li>dispatch：就是最常用的dispatch方法，派发action。</li>
<li>getState：通过该方法，可以拿到当前状态树state。</li>
<li>replaceReducer：这个方法主要用于 reducer 的热替换，下面介绍该方法。</li>
<li>subscribe：添加一个变化监听器。每当 dispatch（action）的时候就会执行，state 树中的一部分可能已经变化。</li>
<li>observable：观察者模式，用于处理订阅关系。</li>
</ul>
<p>这里挑几个方法介绍：</p>
<h3 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h3><p>在完成基本的参数校验之后，在 createStore 中声明如下变量及 getState 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentReducer = reducer</span><br><span class="line"><span class="keyword">var</span> currentState = initialState</span><br><span class="line"><span class="keyword">var</span> listeners = [] <span class="comment">// 当前监听 store 变化的监听器</span></span><br><span class="line"><span class="keyword">var</span> isDispatching = <span class="literal">false</span> <span class="comment">// 某个 action 是否处于分发的处理过程中</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Reads the state tree managed by the store.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">* @returns &#123;any&#125; The current state tree of your application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> currentState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getState方法就是简单返回当前state，如果state没有被reducer处理过，他就是initialState。</p>
<h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p>在 getState 之后，定义了 store 的另一个方法 subscribe：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line"> listeners.push(listener)</span><br><span class="line"> <span class="keyword">var</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> isSubscribed = <span class="literal">false</span></span><br><span class="line"> <span class="keyword">var</span> index = listeners.indexOf(listener)</span><br><span class="line"> listeners.splice(index, <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Store 允许使用<code>store.subscribe</code>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p>
<p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入<code>listen</code>，就会实现 View 的自动渲染。你可能会感到奇怪，好像在 Redux 应用中并没有使用 store.subscribe 方法？事实上，</p>
<p>React Redux 中的 connect 方法隐式地帮完成了这个工作。</p>
<p><code>store.subscribe</code>方法返回一个函数，调用这个函数就可以解除监听。</p>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>dispatch是redux的核心方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">            <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">            <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        isDispatching = <span class="literal">true</span></span><br><span class="line">        currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    listeners.slice().forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断当前是否处于某个 action 的分发过程中，这个检查主要是为了避免在 reducer 中分发 action 的情况，因为这样做可能导致分发死循环，同时也增加了数据流动的复杂度。</p>
<p>确认当前不属于分发过程中后，先设定标志位，然后将当前的状态和 action 传给当前的reducer，用于生成最新的 state。这看起来一点都不复杂，这也是反复强调的 reducer 工作过程——纯函数、接受状态和 action 作为参数，返回一个新的状态。</p>
<p>在得到新的状态后，依次调用所有的监听器，通知状态的变更。需要注意的是，在通知监听器变更发生时，并没有将最新的状态作为参数传递给这些监听器。这是因为在监听器中，可以直接调用 store.getState() 方法拿到最新的状态。</p>
<p>最终，处理之后的 action 会被 dispatch 方法返回。</p>
<h3 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    currentReducer = nextReducer;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这是为了拿到所有 reducer 中的初始状态（你是否还记得在定义 reducer 时，第一个参数为previousState，如果该参数为空，提供默认的 initialState）。只有所有的初始状态都成功获取后，Redux 应用才能有条不紊地开始运作。</p>
<h2 id="3-Redux-middleware"><a href="#3-Redux-middleware" class="headerlink" title="3.Redux middleware"></a>3.Redux middleware</h2><blockquote>
<p>It provides a third-party extension point between dispatching an action, and the moment it reachesthe reducer</p>
</blockquote>
<p>它提供了一个分类处理 action 的机会。在middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的action 进行相应操作，给你一次改变 action 的机会。</p>
<p>常规的同步数据流模式的流程图如下：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://sslstatic.ktanx.com/images/release/201811/Tr2gHBdB9tYoeS97.png" alt="f2BVgyd4bOqmbmPx.png](https://sslstatic.ktanx.com/images/release/201811/f2BVgyd4bOqmbmPx.png)不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：![Tr2gHBdB9tYoeS97.png" title>
                </div>
                <div class="image-caption">f2BVgyd4bOqmbmPx.png](https://sslstatic.ktanx.com/images/release/201811/f2BVgyd4bOqmbmPx.png)不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：![Tr2gHBdB9tYoeS97.png</div>
            </figure>每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware 实现变化多样的功能。比如上面的业务，把处理log的代码封装成一个middleware，处理异步的也是一个middleware，两者串联，却又相互独立。</p>
<p>使用middleware之后，action触发的dispatch并不是原来的dispatch，而是经过封装的new dispatch，在这个new dispatch中，按照顺序依次执行每个middleware，最后调用原生的dispatch。</p>
<p>来看下logger middleware如何实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action); </span><br><span class="line">    next(action);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里代码十分简洁，就是在next调用下一个middleware之前和之后，分别打印两次。</p>
<p>Redux 提供了 applyMiddleware 方法来加载 middleware，该方法的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, initialState</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> store = next(reducer, initialState);</span><br><span class="line">            <span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">            <span class="keyword">let</span> chain = [];</span><br><span class="line">            <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">                getState: store.getState,</span><br><span class="line">                dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action),</span><br><span class="line">            &#125;;</span><br><span class="line">            chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">            dispatch = compose(...chain)(store.dispatch);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...store,</span><br><span class="line">                dispatch,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中compose源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> funcs.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newStore = applyMiddleware([mid1, mid2, mid3, ...])(createStore)(reducer, initialState);</span><br></pre></td></tr></table></figure>

<p>ok，相关源码已就位，来详细解析一波。</p>
<p><strong>函数式编程思想设计</strong> ：middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的currying，它是一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个middleware 进行层层调用，动态地将 store 和 next 参数赋值。currying 的 middleware 结构的好处主要有以下两点。</p>
<ul>
<li>易串联：currying 函数具有延迟执行的特性，通过不断 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeline 来处理数据流。</li>
<li> 共享 store: 在 applyMiddleware 执行的过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。</li>
</ul>
<p><strong>给 middleware 分发 store</strong>：newStore创建完成之后，applyMiddleware 方法陆续获得了3个参数，第一个是 middlewares 数组[mid1, mid2, mid3, …]，第二个是 Redux 原生的 createStore ，最后一个是 reducer。然后，可以看到 applyMiddleware 利用 createStore 和 reducer 创建了一个 store。而 store 的 getState方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量 store：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line"> getState: store.getState,</span><br><span class="line"> dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action),</span><br><span class="line">&#125;;</span><br><span class="line">chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br></pre></td></tr></table></figure>

<p>然后，让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍。执行完后，获得 chain数组 [f1, f2, … , fx, …, fn]，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数都可以访问相同的 store，即 middlewareAPI。</p>
<blockquote>
<p>middlewareAPI 中的 dispatch 为什么要用匿名函数包裹呢？</p>
<p>用 applyMiddleware 是为了改造 dispatch，所以 applyMiddleware 执行完后，dispatch 是变化了的，而 middlewareAPI 是 applyMiddleware 执行中分发到各个 middleware 的，所以必须用匿名函数包裹 dispatch，这样只要 dispatch 更新了，middlewareAPI 中的 dispatch 应用也会发生变化。</p>
</blockquote>
<p><strong>组合串联 middleware</strong>：这一层只有一行代码，却是 applyMiddleware 精华之所在<code>dispatch = compose(...chain)(store.dispatch);</code>，其中 compose 是函数式编程中的组合，它将 chain 中的所有匿名函数 [f1, f2, … , fx, …, fn]组装成一个新的函数，即新的 dispatch。当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行。</p>
<p>compose(…funcs) 返回的是一个匿名函数，其中 funcs 就是 chain 数组。当调用 reduceRight时，依次从 funcs 数组的右端取一个函数 fx 拿来执行，fx 的参数 composed 就是前一次 fx+1 执行的结果，而第一次执行的 fn（n 代表 chain 的长度）的参数 arg 就是 store.dispatch。所以，当 compose 执行完后，得到的 dispatch 是这样的，假设 n = 3：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = f1(f2(f3(store.dispatch))));</span><br></pre></td></tr></table></figure>

<p>这时调用新 dispatch，每一个 middleware 就依次执行了。</p>
<p><strong>在 middleware 中调用 dispatch 会发生什么</strong>：经过 compose 后，所有的 middleware 算是串联起来了。可是还有一个问题，在分发 store 时，提到过每个 middleware 都可以访问 store，即 middlewareAPI 这个变量，也可以拿到 store 的dispatch 属性。那么，在 middleware 中调用 store.dispatch() 会发生什么，和调用 next() 有区别吗？现在来说明两者的不同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action);</span><br><span class="line"> next(action);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action);</span><br><span class="line"> store.dispatch(action);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在分发 store 时解释过，middleware 中 store 的 dispatch 通过匿名函数的方式和最终compose 结束后的新 dispatch 保持一致，所以，在 middleware 中调用 store.dispatch() 和在其他任何地方调用的效果一样。而在 middleware 中调用 next()，效果是进入下一个 middleware，下图就是redux middleware最著名的洋葱模型图。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://sslstatic.ktanx.com/images/release/201811/IArjf9kjKecPhnFF.png" alt="IArjf9kjKecPhnFF.png" title>
                </div>
                <div class="image-caption">IArjf9kjKecPhnFF.png</div>
            </figure></p>
<h2 id="4-combineReducer"><a href="#4-combineReducer" class="headerlink" title="4.combineReducer"></a>4.combineReducer</h2><p>如果一个项目过大，通常按模块来写reducer，但是redux create store只接受一个reducer参数，所以需要合并reducer。这里就用到了redux提供的<code>combineReducer</code>辅助函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">combineReducers(&#123;</span><br><span class="line">      layout,</span><br><span class="line">      home,</span><br><span class="line">      ...asyncReducers</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>这个函数用起来很简单，就是传入一个对象，key是模块reducer对应的名字， 值是对应reducer。值是一个function，相当于是一个新的reducer，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">var</span> finalReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = reducerKeys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        warning(<span class="string">`No reducer provided for key "<span class="subst">$&#123;key&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> unexpectedKeyCache = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> sanityError</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    assertReducerSanity(finalReducers)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    sanityError = e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sanityError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> sanityError</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)</span><br><span class="line">      <span class="keyword">if</span> (warningMessage) &#123;</span><br><span class="line">        warning(warningMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">var</span> reducer = finalReducers[key]</span><br><span class="line">      <span class="keyword">var</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码不是很多，除去一些验证代码，剩下的就是说：return一个function，暂时称呼他combination，就相当于是与一个总的reducer，每次action都会走到combination中，combination会遍历输入的reducer，将action放到每个reducer中执行一下，计算出返回结果就是nextState，nextState于previousState如果!==说明改变了，返回nextState，否则返回执行之前的state。</p>
<p>这也解释了不同模块actionType如果相同的话，两个模块的reducer都会走一遍的问题，在actionType名称前面加上模块前缀即可解决问题。</p>
<h2 id="5-Provider与Connect"><a href="#5-Provider与Connect" class="headerlink" title="5. Provider与Connect"></a>5. Provider与Connect</h2><p>Provider与Connet组件都是React-Redux提供的核心组件，两者看起来功能一样，都是帮助容器组件获取store中的数据，但是原理与功能却不同。</p>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider组件在所有组件的最外层，其接受store作为参数，将store里的state使用context属性向下传递。部分源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> getChildContext() &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line"> <span class="keyword">super</span>(props, context)</span><br><span class="line"> <span class="keyword">this</span>.store = props.store</span><br><span class="line"> &#125;</span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props</span><br><span class="line"> <span class="keyword">return</span> Children.only(children)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用context这个属性，Provider所有子组件均可以拿到这个属性。</p>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>connect实现的功能是将需要关联store的组件和store的dispatch等数据混合到一块，这块就是一个高阶组件典型的应用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">if</span> (withRef) &#123;</span><br><span class="line"> <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent, &#123;</span><br><span class="line"> ...this.mergedProps,</span><br><span class="line"> ref: <span class="string">'wrappedInstance'</span></span><br><span class="line"> &#125;)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent,</span><br><span class="line"> <span class="keyword">this</span>.mergedProps</span><br><span class="line"> )</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.renderedElement</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">return</span> hoistStatcis(Connect, WrappedComponent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是先从他的四个参数说起：</p>
<h4 id="1-mapStateToProps"><a href="#1-mapStateToProps" class="headerlink" title="1.mapStateToProps"></a>1.mapStateToProps</h4><p>connect 的第一个参数定义了需要从 Redux 状态树中提取哪些部分当作 props 传给当前组件。一般来说，这也是使用 connect 时经常传入的参数。事实上，如果不传入这个参数，React 组件将永远不会和 Redux 的状态树产生任何关系。具体在源代码中的表现为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> shouldSubscribe = <span class="built_in">Boolean</span>(mapStateToProps)</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> trySubscribe() &#123;</span><br><span class="line"> <span class="keyword">if</span> (shouldSubscribe &amp;&amp; !<span class="keyword">this</span>.unsubscribe) &#123;</span><br><span class="line"> <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>))</span><br><span class="line"> <span class="keyword">this</span>.handleChange()</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p>
<p>这块的源码相对较简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapState = mapStateToProps || defaultMapStateToProps </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line">    computeStateProps(store, props) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.finalMapStateToProps) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.configureFinalMapState(store, props)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> state = store.getState()</span><br><span class="line">        <span class="keyword">const</span> stateProps = <span class="keyword">this</span>.doStatePropsDependOnOwnProps ?</span><br><span class="line">          <span class="keyword">this</span>.finalMapStateToProps(state, props) :</span><br><span class="line">          <span class="keyword">this</span>.finalMapStateToProps(state)</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          checkStateShape(stateProps, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stateProps</span><br><span class="line">      &#125;</span><br><span class="line">      configureFinalMapState(store, props) &#123;</span><br><span class="line">        <span class="keyword">const</span> mappedState = mapState(store.getState(), props)</span><br><span class="line">        <span class="keyword">const</span> isFactory = <span class="keyword">typeof</span> mappedState === <span class="string">'function'</span></span><br><span class="line">        <span class="keyword">this</span>.finalMapStateToProps = isFactory ? mappedState : mapState</span><br><span class="line">        <span class="keyword">this</span>.doStatePropsDependOnOwnProps = <span class="keyword">this</span>.finalMapStateToProps.length !== <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.computeStateProps(store, props)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          checkStateShape(mappedState, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mappedState</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块原理很简单，进行一些参数校验，判断第一个参数mapStateToProps返回值是否为function，如果是递归调用，不是的话算出返回值。如果没传这个参数，默认给{}。</p>
<blockquote>
<p>可能会疑惑为什么传给 connect 的第一个参数本身是一个函数，react-redux 还允许这个函数的返回值也是一个函数呢？简单地说，这样设计可以允许在 connect 的第一个参数里利用函数闭包进行一些复杂计算的缓存，从而实现效率优化的目的</p>
</blockquote>
<p>当使用的时候：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    home: state.home,</span><br><span class="line">    layout: state.layout</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染</p>
<h4 id="2-mapDispatchToProps"><a href="#2-mapDispatchToProps" class="headerlink" title="2.mapDispatchToProps"></a>2.mapDispatchToProps</h4><p>人如其名，它接受 store 的 dispatch 作为第一个参数，同时接受 this.props 作为可选的第二个参数。利用这个方法，可以在 connect 中方便地将 actionCreator 与 dispatch 绑定在一起（利用 bindActionCreators 方法），最终绑定好的方法也会作为 props 传给当前组件。这块的源码与mapStateToProps一样，就不贴了。</p>
<p>bindActionCreator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-mergeProps"><a href="#3-mergeProps" class="headerlink" title="3.mergeProps"></a>3.mergeProps</h4><p>前两个参数返回的对象，都要跟组件自身的props merge一下，形成一个新的对象赋值给对应组件，可以在这一步做一些处理，这个参数就是干这个的，该参数签名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mergeProps(stateProps, dispatchProps, ownProps): props</span><br></pre></td></tr></table></figure>

<p>默认情况如果没传该参数，返回<code>Object.assign(ownProps, stateProps, dispatchProps)</code>。</p>
<h4 id="4-options"><a href="#4-options" class="headerlink" title="4.options"></a>4.options</h4><p>如果指定这个参数，可以定制 connector 的行为。</p>
<ul>
<li>[<code>pure = true</code>] <em>(Boolean)</em>: 如果为 true，connector 将执行 <code>shouldComponentUpdate</code> 并且浅对比 <code>mergeProps</code> 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。*默认值为 true。*</li>
<li>[<code>withRef = false</code>] <em>(Boolean)</em>: 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 <code>getWrappedInstance()</code> 方法获得。*默认值为 false。*</li>
</ul>
<p>这个connect组件还干了一件事，状态缓存判断。当store变了的时候，前后状态判断，如果状态不等，更新组件，并且完成事件分发。</p>
<h2 id="6-Redux流程梳理"><a href="#6-Redux流程梳理" class="headerlink" title="6. Redux流程梳理"></a>6. Redux流程梳理</h2><p>上面讲了大量的函数源码，这么些函数之间的关系：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://sslstatic.ktanx.com/images/release/201811/4g40yEqEfjeRqxs6.png" alt="4g40yEqEfjeRqxs6.png" title>
                </div>
                <div class="image-caption">4g40yEqEfjeRqxs6.png</div>
            </figure>初始化阶段：</p>
<ol>
<li>createStore创建一个store对象</li>
<li>将store对象通过参数给Provider组件</li>
<li>Provider组件将store通过context向子组件传递</li>
<li>Connect组件通过context获取到store，存入自己的state</li>
<li>componentDidMount里面订阅store.subscribe事件</li>
</ol>
<p>更新数据阶段：</p>
<ol>
<li>用户事件触发</li>
<li>actionCreator生成action交给dispatch</li>
<li>实际上交给了封装后的中间层（compose(applyMiddleware(…))）</li>
<li>请求依次通过每个中间件，中间件通过next进行下一步</li>
<li>最后一个中间件将action交给store.dispatch</li>
<li>dispatch内部将action交给reducer执行</li>
<li>combineReducer将每个子reducer执行一遍算出新的state</li>
<li>dispatch内部调用所有订阅事件</li>
<li>Connect组件handleChange事件触发判断新state和旧state是否===</li>
<li>并且判断新的state是否与mapStateToProps shallowEqual</li>
<li>不等则setState触发更新</li>
</ol>
<h2 id="7-Redux设计技巧"><a href="#7-Redux设计技巧" class="headerlink" title="7.Redux设计技巧"></a>7.Redux设计技巧</h2><ol>
<li><p>匿名函数&amp;&amp;闭包使用</p>
<p>redux核心函数大量使用了匿名函数和闭包来实现数据共享和状态同步。</p>
</li>
<li><p>函数柯里化使用</p>
<p>使用函数柯里化s实现参数复用，本质上是降低通用性，提高适用性。</p>
</li>
<li><p>核心状态读取是拷贝而不是地址</p>
<p>对于state这种核心状态使用getState()计算出新的state，而不是直接返回一个state对象。</p>
</li>
<li><p>观察者订阅者是核心实现</p>
<p>使用观察者订阅者模式实现数据响应。</p>
</li>
<li><p>context这个api的使用</p>
<p>平时开发不常接触的api实现Provider与Connect通信。</p>
</li>
</ol>

        </div>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://summxu.github.io/2022/Redux源码全面解析/&title=《Redux源码全面解析》 — 小兵旭旭的博客&pic=https://summxu.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://summxu.github.io/2022/Redux源码全面解析/&title=《Redux源码全面解析》 — 小兵旭旭的博客&source=小兵旭旭" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://summxu.github.io/2022/Redux源码全面解析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Redux源码全面解析》 — 小兵旭旭的博客&url=https://summxu.github.io/2022/Redux源码全面解析/&via=https://summxu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://summxu.github.io/2022/Redux源码全面解析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2022/React实现原理及Fiber架构/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">React实现原理及Fiber架构</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/深入了解useMemo和useCallback/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">深入了解useMemo和useCallback</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
  <div class="top" style="display: none;">
    
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


    <p>
      <!-- 
      <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
            class="icon icon-lg icon-rss"></i></a></span>
       -->
      <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
    </p>
  </div>
  <div class="bottom">
    <p><span>summxu &copy;
        2017 -
        2024</span>
      <span>
        
        Power by Hexo
      </span>
    </p>
  </div>
</footer>
    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://summxu.github.io/2022/Redux源码全面解析/&title=《Redux源码全面解析》 — 小兵旭旭的博客&pic=https://summxu.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://summxu.github.io/2022/Redux源码全面解析/&title=《Redux源码全面解析》 — 小兵旭旭的博客&source=小兵旭旭" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://summxu.github.io/2022/Redux源码全面解析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Redux源码全面解析》 — 小兵旭旭的博客&url=https://summxu.github.io/2022/Redux源码全面解析/&via=https://summxu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://summxu.github.io/2022/Redux源码全面解析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKElEQVR42u3aS27DMAxF0ex/0+60RRP5PlIZmLoaBUYr63gg8Pd64XX9Wuvn14dV223zkiFDxmMZ13Ktj/v/N0fyncmnkSFDxgmMT4fgh+5cuLUPJEOGDBnr7dZHWSP5ExkyZMjoMGqHWKep/NPIkCHjTAZJYvsFOx5cfjEXlyFDxgMZnUN8+/dX+hsyZMh4FOMKV7+s1r9k37xRhgwZoxlpmYyHdOlBa2wZMmScxuCBGg/veLNz/V8oWJQhQ8ZQRq0Qz8dVOSwdF/vzRIYMGaMZtfYAp/aRnC1DhoypjPVBayNf/NKsBYJvdpMhQ8ZoRq15Sdhpt3HDQWXIkDGUkW5Xu0x5a5MEnTe5uAwZMg5j1EpmnUIbZ9zMjMiQIWMoY9fwBHpx2CiNxyxkyJAxiNFpLqbtzE75LG5eypAh4wAGST5rR0xXgJEhQ8ZQBhmqSMcveICYMuJymwwZMgYx4kJ8KYzrj5fdzIzIkCFjKKMzq0AGyHYNk6HAVIYMGccwSNZbayfwpHRzLi5DhoyhDD68xVPctMHJL2gZMmScyUgHuXiZjMPSZqoMGTKmMmpl+trfpKRWoU2GDBmDGHx1Woy80E/GzkjCLEOGjHmMtNzPG43poEZ6WQcRqwwZMkYw0tGKzqhE7fq+QcqQIUMGKOXzKzJNcYPoVYYMGTK2Jqu1lsDmC1eGDBmPYnTGJtIntYPKkCHjZEYad3Ve0G8JtBqZMmTIeB7jBwwQslBqJArWAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };

</script>

<script src="/js/main.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</body>
</html>
