{"meta":{"title":"小兵旭旭的博客","subtitle":null,"description":"小兵旭旭","author":"summxu","url":"https://summxu.github.io","root":"/"},"pages":[{"title":"小兵旭旭","date":"2023-07-21T12:35:55.259Z","updated":"2023-07-21T12:35:55.259Z","comments":false,"path":"about/index.html","permalink":"https://summxu.github.io/about/index.html","excerpt":"","text":"@card{ 末批90后，大学网络工程。现居山东，不入流前端开发 。 会一点儿TypeScript和Dart，听说过C++。现着迷WebGL，至今不会修电脑。 喜欢游戏，尝试去做开发，但难以脱离Web，看好Cocos。 轻度强迫症，常年代码洁癖，会影响开发进度，不过还是想再慢一些。 爱折腾，Cisco、NAS、STM32、Verilog…. 孤独患者，懒癌中期，无脑幻想者。但却人畜无害，无需远离。 兴趣众多，然无一精通（如果Coding也算的话）。正努力成为一个有趣的人。 1console.log(\"👆以上是不完整的我\") // 请我吃大餐了解更多 }"},{"title":"标签分类","date":"2019-09-14T08:39:14.000Z","updated":"2023-07-21T12:35:55.259Z","comments":false,"path":"tags/index.html","permalink":"https://summxu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ReactNative踩坑记","slug":"2020/ReactNative踩坑记","date":"2020-07-21T04:16:24.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2020/ReactNative踩坑记/","link":"","permalink":"https://summxu.github.io/2020/ReactNative踩坑记/","excerpt":"","text":"最近在使用react-native的时候遇到了很多坑,这里记录一下样式react-native 虽然支持flex布局，但是所有的样式均是css样式的一个很小的集合，尤其是在安卓机下问题尤为凸显： View内部的元素千万不要超出父级的范围，iso上问题倒是不大，安卓上就什么超出的都看不到了 lineHeight 可以用，不过千万不要写成小数，否则安卓上会直接崩溃 rn的样式不存在继承的情况，所以基本上每个节点都要写style，真的是体力活 如果Text的父级元素设置了背景颜色，那么ios下Text的背景颜色也是父级的背景颜色，要么自己写个Text重置下样式，要么就遇到了再改 react-native的字号是没有设置单位的，所以会随着系统设置的字体大小而变化，我也不知道这是不是坑，不过貌似有的app也没有管这个，如果硬要去设置Text的文字不随系统改变，安卓是可以统一设置的，ios上Text设置allowFontScaling ={false}就可以解决 异常react-native 在发生js异常的时候，debug的时候会直接红屏幕，但是再release的时候直接会崩溃退出，解决办法 1234import ErrorUtils from \"ErrorUtils\" &lt;br&gt;//这里应该做个判断，如果不是debug的才做这样的异常全局处理ErrorUtils.setGlobalHandler((e)=&gt;&#123;&lt;br&gt; //发生异常的处理方法,当然如果是打包好的话可能你找都找不到是哪段代码出问题了 Alert.alert(\"异常\",JSON.stringify(e))&#125;); fetchreact-native虽然自带有fetch，不过在使用的时候发现了一个问题，如果需要获取http的header头的时候问题就来了，可能得到的是一些千奇百怪的样式，这并不是react-native的错，而是第三方的 whatwg-fetch 留下的坑，当然也有人再github上跟react-native反映过这个问题，不过得到的解决方案都很坑，唯有一个办法，就是拷贝自己修改，修改如下: 注释该注释的 123456(function(self) &#123; 'use strict'; //注释这里，不然总是用的是全局的fetch // if (self.fetch) &#123; // return // &#125; 修改该修改的 1234567891011121314function parseHeaders(rawHeaders) &#123; var headers = new Headers()&lt;br&gt; //把\\t\\n改成\\t，因为一般header都是用\\n来分割的 rawHeaders.split('\\n').forEach(function(line) &#123; //rawHeaders.split('\\t\\n').forEach(function(line) &#123; var parts = line.split(':') var key = parts.shift().trim() if (key) &#123; var value = parts.join(':').trim() headers.append(key, value) &#125; &#125;) &#125; return headers&#125; 直接import你改好的文件，fetch就可以用了 ModalMode控件在使用的时候要注意了，因为这个是rn提供的，并且也写的很清楚是最高层级的一个弹出层，所以你想要又打开Model又要跳转基本是无望的了，所以建议不要使用这个，最好是使用第三方的控件，我们用的是 react-native-modalbox + 高阶控件 实现的全遮盖的弹出层 点击屏幕其他位置关闭的菜单这类菜单有个共同的特点就是点击屏幕其他地方然后菜单就关闭，我们的解决办法就是用自己写的 react-native-modalbox + 高阶控件 也就是说放在一个弹出层里面，当然可以试试把当前页面套进一个大的 TouchableWithoutFeedback 里面 接口请求非特殊情况下都应该这样做 123456import &#123;InteractionManager&#125; from \"react-native\"componentDidMount()&#123; InteractionManager.runAfterInteractions(() =&gt; &#123; fetch(\"xxx.xxx.xxx\",&#123;&#125;) &#125;); &#125; 键盘官方提供的自定义隐藏键盘的方法是 12import &#123; Keyboard &#125; from 'react-native'Keyboard.dismiss() 但是我试了很多次之后发现根本不能，而且还报错，楼主的react-native版本是0.35.0 看了官方的issue才知道这个不行，推荐下面方法 1import dismissKeyboard from 'dismissKeyboard'dismissKeyboard() 这样就可以隐藏了，太坑了 还有个很坑的地方，官方提供的移除键盘事件的方法不可用 1234componentDidMount () &#123; Keyboard.addListener('keyboardDidShow', this.keyboardDidShow.bind(this)) Keyboard.addListener('keyboardDidHide', this.keyboardDidHide.bind(this))&#125;componentWillUnmount () &#123; Keyboard.removeAllListeners('keyboardDidShow') Keyboard.removeAllListeners('keyboardDidHide')&#125; 这样的方式特么的如果操作快了，或者有时候莫名其妙的就会出错,下面的才是正确的打开方式： 12345678componentDidMount () &#123; this.keyboardDidShowListener = Keyboard.addListener('keyboardDidShow', this.keyboardDidShow.bind(this)) this.keyboardDidHideListener = Keyboard.addListener('keyboardDidHide', this.keyboardDidHide.bind(this))&#125;componentWillUnmount () &#123; this.keyboardDidShowListener.remove() this.keyboardDidHideListener.remove()&#125; httpshttps这个问题上ios还好，安卓问题就来了，前期我们准备将ajax请求的库丢给原生安卓和ios来做我们直接调用就是了，但是后来发现问题这样那样的问题太多了， 所以在热更新服务器启动或者打包的时候就把源代码先改了在进行打包或者启动服务器 文件位置： 1node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java 这个文件的最后一个方法修改如下： 12345678910111213141516private static OkHttpClient createClient() &#123; // No timeouts by default return new OkHttpClient.Builder() .sslSocketFactory(sslContext.getSocketFactory()) .hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; //忽略所有的认证，直接返回了true &#125; &#125;) .connectTimeout(0, TimeUnit.MILLISECONDS) .readTimeout(0, TimeUnit.MILLISECONDS) .writeTimeout(0, TimeUnit.MILLISECONDS) .cookieJar(new ReactCookieJarContainer()) .build();&#125; 修改源代码的方式有点略坑，不过可以解决很多问题，还节约时间！！！ BackAndroid安卓机有独特的点击按键返回，所以在最外层会注册一个监听方法 123456789101112131415161718192021222324252627282930313233bindHardwareBackPress()&#123; if (Platform.OS === 'android') &#123; BackAndroid.addEventListener('hardwareBackPress', this._onHomeBackPress); &#125;&#125; onHomeBackPress()&#123; let routeList = this.getRouteList(); if (routeList.length !== 1) &#123; this.navigator.pop(); return true; &#125; this.handleHomeBackPress(); return true;&#125; handleHomeBackPress()&#123; if (Platform.OS === \"android\") &#123; ToastAndroid.show(\"再按一次退出应用\", ToastAndroid.SHORT); BackAndroid.removeEventListener(\"hardwareBackPress\", this._onHomeBackPress); BackAndroid.addEventListener(\"hardwareBackPress\", this._onExitApp); this.timer = TimerMixin.setInterval(() =&gt; &#123; TimerMixin.clearInterval(this.timer); BackAndroid.removeEventListener(\"hardwareBackPress\", this._onExitApp); BackAndroid.addEventListener(\"hardwareBackPress\", this._onHomeBackPress); &#125;, 2000); &#125;&#125; exitApp()&#123; BackAndroid.exitApp();&#125; 上面的代码是监听返回键，如果不是在最外层的路由就返回上一个,如果在最外层就直接关闭app，但是有很多这样那样的需求要去对安卓的返回键进行操作，坑就来了，你以为提供的removeEventListener方法是没问题的？no ！！！ 他会移除所有的监听，这是不是很坑！！！！ 所以：在需要对安卓返回键进行特殊处理的时候记得其他地方做了监听的再重新监听一次！！！！","categories":[],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://summxu.github.io/tags/ReactNative/"}]},{"title":"HTTP缓存-ETag","slug":"2019/http-cache-etag","date":"2019-08-10T12:44:11.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/http-cache-etag/","link":"","permalink":"https://summxu.github.io/2019/http-cache-etag/","excerpt":"","text":"最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。 ETag验证缓存的响应在本地通过 express 启了一个非常简单的个服务，具体如下 1234567891011// app.jsconst express = require('express');const app = express();app.get('/', (req, res) =&gt; &#123; res.send('hello http')&#125;)app.listen(3000, () =&gt; &#123; console.log('The server is running at http://127.0.0.1:3000/')&#125;) 但是仔细看却发现，第一次进入页面http://127.0.0.1:3000/时，Status为200而再次刷新发现Status却是304 仔细对比发现 第一次请求时候请求参数中并没有 If-None-Match 字段但是却有个Pragma；同时在请求的Response中有一个 ETag: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg”字段。 刷新页面后再次请求在请求头中却有个 *If-None-Match: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg” *，If-None-Match 的值和第一次请求的ETag的值相同。 经过查询才了解原理浏览器会根据HTTP请求的ETag验证请求的资源是否发生了改变，如果它未发生变化，服务器将返回“304 Not Modified”响应，并且资源从浏览器缓存中读取，这样就不必再次下载请求。 由此看来整个的过程就是下面这样： 如果缓存中有ETag 令牌，客户端请求时会自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。 服务器根据当前资源核对令牌，验证是否发生变化，将验证结果通知给客户端，客户端根据结果看看是否需要从缓存中读取还是发送资源请求。 补充一个很直白的 TCP协议的三次握手 的理解。 为了验证查证的结果，我又添加一个请求处理。这个过程是，客户端明确返回一个ETag, 但是这里每次请求的的返回值都不相同，这里简单的使用了个etag++。 1234567891011121314151617181920// app.jsconst express = require('express');const app = express();app.get('/', (req, res) =&gt; &#123; res.send('hello http');&#125;)// 验证ETaglet etag = 0;app.get('/test', (req, res) =&gt; &#123; etag++; res.set('ETag', etag); res.send('ETag');&#125;)app.listen(3000, () =&gt; &#123; console.log('The server is running at http://127.0.0.1:3000/')&#125;) 查看下 /test 地址的请求结果，会发现If-None-Match 的值和 Response中的 ETag值每次都不相同，并且是 浏览器会将每次的 ETag 值都缓存起来在下次请求的时候发送给服务器。这样一来，每次服务器每次校验的值都是不相同的，所以这种就没有做缓存，因此每次请求 /test 地址都是 200 的状态。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://summxu.github.io/tags/网络/"}]},{"title":"fixed 定位失效 与 CSS 层叠上下文","slug":"2019/fixed-stacking-context","date":"2019-05-22T15:38:51.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/fixed-stacking-context/","link":"","permalink":"https://summxu.github.io/2019/fixed-stacking-context/","excerpt":"","text":"第一部分，position: fixed失效的问题；第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。 关于 position: fixedposition: fixed 在日常布局中比较常用，如移动端头部和底部导航定位、模态框、悬浮按钮等，设置了这个属性值得元素会相对于屏幕视口（viewport）进行定位，其位置在屏幕进行滚动时会保持不变，不占用文档流中的位置，而且打印时这个元素会出现在 每一页 的相同位置。设置了 position: fixed 的元素最终的位置由它的 top, right, bottom, left 来决定，这个值会创建一个新的 stacking context但是，有些情况下，这种定位方式会失效，使得元素相对于视窗定位的定位不符合预期（其实是 fixed 定位的参考元素变了）。当该元素的父元素中（广义，包含祖先元素）有元素的 transform 或 perspective 的值不是 none，该元素就会相对于这个父元素而不是视口进行定位。具体的原因是这样： Specifying a value other than none for the transform property establishes a new local coordinate system at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element’s transformation matrix. Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent. From the perspective of the user, an element effectively accumulates all the transform properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a current transformation matrix for the element. 解释一下，transform 或 perspective 的非 none 值会影响元素的包含块和层叠上下文，这些值会在应用它的元素上建立一个局部的坐标系（X轴向右水平增加; Y轴垂直向下增加），由变换矩阵（transform 的值）给出元素到该局部坐标系的映射，而且 transform 带来的局部坐标系的改变是可以累积的——也就是说，子元素会在它的父元素的坐标系内建立子元素自己的局部坐标系：父元素的 transform 们一层层积累定义了子元素当前的变换矩阵（一个元素的变换矩阵是从 transform 和 transform-origin 属性中计算出来的），步骤如下： 通过 transform-origin 的值对坐标原点 X 和 Y 的位置进行转换 以变换后的 X、Y 为坐标原点原点，根据 transform 的属性值进行变换 X 和 Y 根据 transform-origin 的相反值平移回去 如图 transform 会影响最终的渲染效果，但是不影响除overflow外的CSS布局，当通过 getClientRects()、getBoundingClientRect() 这些接口获取 client rectangles 时，transform 的效果也会被考虑进去。 可以应用 transform 的元素（transformable elements）有： 满足CSS盒模型的块级元素或行内元素，或者它的 display 值为 table-row, table-row-group, table-header-group, table-footer-group, table-cell, table-caption 中的一个 SVG 命名空间中具有 transform, patternTransform 或 gradientTransform 属性的元素 p.s. 关于上面的应用transform后元素位置的计算方式。原文如下： Start with the identity matrix. Translate by the computed X and Y of transform-origin Multiply by each of the transform functions in transform property from left to right Translate by the negated computed X and Y values of transform-origin 参考文档： The transform Property - W3C Working Draft - 30 November 2017 The Transform Rendering Model - W3C Working Draft - 30 November 2017 层叠上下文 Stacking Context通过上文我们知道了有层叠上下文这么一个东西，层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。和BFC还有IFC这些xx context一样，创建层叠上下文也是有条件的，文档中的层叠上下文由满足以下任意一个条件的元素形成： 根元素 (HTML), z-index 值不为 auto 的 绝对/相对定位元素 position 不是 static 的元素（sticky 也会创建层叠上下文，这是一个神奇的实验中的属性值） 一个 z-index 值不为 auto 的 flex 项目 (flex item) opacity 属性值小于 1 的元素（参考 the specification for opacity） transform 属性值不为 none 的元素 mix-blend-mode 属性值不为 normal 的元素 有 transform、filter、perspective、clip-path、mask / mask-image / mask-border 这些属性中任意一个或多个属性的元素 isolation 属性被设置为 isolate的元素 在 will-change 中指定了任意CSS` 属性的元素（即使没有直接指定这些属性的值） -webkit-overflow-scrolling 属性被设置 touch的元素 设置了 transform-style: preserve-3d 的元素 在层叠上下文中的子元素也会按照上面的规则进行层叠，子元素的 z-index 值只在父级层叠上下文中有意义，子级层叠上下文被自动视为父级层叠上下文的一个独立单元。 但是，并不是创建了新的层叠上下文的元素并不一定都会对其拥有position: fixed的子元素的效果产生影响，在Chrome（Blink内核）中，可以明确看到产生了影响的是： transform 属性值不为 none 的元素 设置了 transform-style: preserve-3d 的元素 perspective 值不为 none 的元素 在 will-change 中指定了任意 CSS 属性的元素 但是，在不同的浏览器内核下，上述结论也会有所差异，例如，在 Safari（Webkit内核） 中，只有transform 属性值不为 none 的元素会对 fixed 定位的效果产生影响. 参考文档： the specification for opacity - W3C The stacking context - MDN","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}]},{"title":"css3 transform对普通元素的n多渲染影响","slug":"2019/transform-element-impact","date":"2019-05-18T15:15:18.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/transform-element-impact/","link":"","permalink":"https://summxu.github.io/2019/transform-element-impact/","excerpt":"","text":"问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 position:fixed 无效，问题是因为dilog定位时用了transform，深究下问题原因，发现事情并不是这么简单！ 一个普普通通的元素，如果应用了CSS3 transform变换，即便这个transform属性值不会改变其任何表面的变化（如scale(1), translate(0,0)），但是，实际上，对这些元素还是造成了很深远的影响。 transform提升元素的垂直地位当遭遇元素margin负值重叠的时候，如果没有static以外的position属性值的话，后面的元素是会覆盖前面的元素的。img src=&quot;mm1&quot;&gt;&lt;img src=&quot;mm2&quot; style=&quot;margin-left:-60px;&quot;&gt;在transform出现之前，这个规则一直很稳健；但是，自从transform降临，这个规则就变了。元素应用了transform属性之后，就会变得应用了position:relative一个尿性，原本应该被覆盖的元素会雄起，变成覆盖其他元素，修改为如下代码： 12&lt;img src=\"mm1\" style=\"-ms-transform:scale(1);transform:scale(1);\"&gt;&lt;img src=\"mm2\" style=\"margin-left:-60px;\"&gt; 只要是支持transform元素的浏览器，包括IE9(-ms-), 都会提高普通元素的垂直地位，使其覆盖其他元素而不是被覆盖。 这种特性底层原理是层叠上下文，具体可参见“深入理解CSS中的层叠上下文和层叠顺序”一文。 transform限制position:fixed的跟随效果我们应该都知道，position:fixed可以让元素不跟随浏览器的滚动条滚动，而且这种跟随效果连它的兄弟们position:relative/absolute都限制不了。但是，真是一物降一物，position:fixed固定效果却被小小的transform给干掉了，直接降级变成position:absolute的蛋疼表现。 例如下面示意代码： &lt;p style=&quot;transform:scale(1);&quot;&gt;&lt;img src=&quot;mm1.jpg&quot;style=&quot;position:fixed;&quot; /&gt;&lt;/p&gt;结果，本来应该不跟着滚动条滚动的傲娇fixed元素，变成absolute一样的行为表现，归根结底就是父元素加了个小小的transform属性值。 注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有，IE浏览器，包括IE11, fixed还是fixed的表现。 transform改变overflow对absolute元素的限制在以前，overflow与absolute之间的限制规范内容大致是这样的： absolute绝对定位元素，如果含有overflow不为visible的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有position为非static属性的声明，则overflow对该absolute元素不起作用。 比方说如下示意代码： 123&lt;p style=\"width:96px; height:96px; border:2px solid #beceeb; overflow:hidden;\"&gt; &lt;img src=\"mm1.jpg\"style=\"position:absolute;\" /&gt;&lt;/p&gt; 但是，一旦我们给overflow容器或者与图片有嵌套关系的子元素使用transform声明，估计absolute元素就要去领便当了！ 无论是overflow容器还是嵌套子元素，只要有transform属性，就会hidden溢出的absolute元素。 transform限制absolute的100%宽度大小以前，我们设置absolute元素宽度100%, 则都会参照第一个非static值的position祖先元素计算，没有就window. 现在，需要把transform也考虑在内了。 结果，无论是IE9+，还是Chrome还是FireFox浏览器，所有绝对定位图片100%宽度，都是相对设置了transform的容器计算了，于是，上面的图片拉长到了西伯利亚；下面的图片被限制成了小胖墩。 transform对absolute宽度100%限制~","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}]},{"title":"基于 document.execCommand 的富文本","slug":"2019/rich-text-editor-by-execCommand","date":"2019-04-30T13:05:35.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/rich-text-editor-by-execCommand/","link":"","permalink":"https://summxu.github.io/2019/rich-text-editor-by-execCommand/","excerpt":"","text":"前言最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需求，但其提供的诸多功能是用不上的，可以使用更轻量的实现代替。 在寻找新的替代品时，也顺便瞄了下各种编辑器的内部实现。一些体积庞大的编辑器一般都兼容低版本浏览器，不得不写很多兼容性的代码。而一些 MINI、轻量的编辑器是不对低端浏览器作兼容的，使用Selection、Range或者document.execCommand实现。 之前在 JavaScript 获取输入时的光标位置及场景问题 中提到过Selection和Range，这次就说说document.execCommand。 document.execCommand该方法可以对可编辑器区域进行操作，比如加粗文字、改变字号、插入链接等。可编辑区域也就是设置了contentEditable属性的元素。 12// 语法bool = document.execCommand(commandName, showDefaultUI[, arg]) commandName：String，命令的名称 showDefaultUI：Boolean，是否展示用户界面（暂时没有发现“用户界面”指的是什么），一般为false arg：String，要传递的参数，比如插入链接需要传入一个 URL，可选 返回值：Boolean，表示操作是否支持或是否启用假如要把选中的文字加粗，只需要这样： document.execCommand(&#39;bold&#39;, false) 兼容性[http://static.imys.net/execCommand-support-2017113.jpg] 对于现代浏览器的兼容度较好，不过 Android 53 取消兼容的什么鬼？ 除了了解该方法的兼容性外，还需要了解每一种可执行命令的兼容性。比如decreaseFontSize，给选中文字添加small标签，也就是小号字体，谷歌是不支持的。 可以使用以下方法检测命令是否在浏览器中支持： document.queryCommandSupported(commandName) 简陋的实现不到 50 行代码，基于document.execCommand实现富文本编辑器。 有兴趣的同学可以以此为出发点，去开发一个具备完整功能的编辑器。懒得折腾的可以像我一样多搜索几下，找一个合适的轮子。😅 参考MDN: document.execCommand","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"Webpack按需打包Lodash的几种方式","slug":"2019/webpack-use-lodash","date":"2019-04-16T05:23:06.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/webpack-use-lodash/","link":"","permalink":"https://summxu.github.io/2019/webpack-use-lodash/","excerpt":"","text":"在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。 ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 71k 的体积。不能为了吃一口饭而买下一个饭店啊。 针对这个问题，其实已经有很多可选方案了。 函数模块Lodash 中的每个函数在 NPM 都有一个单独的发布模块。NPM: results for ‘lodash’假如你只需要使用_.isEqual，那么你只需要安装lodash.isequal模块，然后按以下方式引用。 1234var isEqual = require('lodash.isequal')// or ES6import isEqual from 'lodash.isequal'isEqual([1, 2, 3], [1, 2, 3]) // true 全路径引用在你完整安装 Lodash 后，可以按lodash/函数名的格式单独引入需要的函数模块。 1234var difference = require('lodash/difference')// or ES6import difference from 'lodash/difference'difference([1, 2], [1, 3]) // [2] 使用插件优化在简单场景下，以上两种方式足以解决问题。而遇到复杂的数据对象时，我们不得不在一个文件中引入多个 Lodash 函数，这样就需要在文件中写多个require或import相关函数。 12345import remove from 'lodash/remove'import uniq from 'lodash/uniq'import invokeMap from 'lodash/invokeMap'import sortBy from 'lodash/sortBy'// more... 正写到关键处却因为引入一个函数要拉到文件头部去定义引用而打乱了思路，很不爽！ 于是我机智的到 Github 去搜索了webpack和lodash两个关键词的组合，排在首位的 lodash-webpack-plugin 就是为了解决这个问题而生。 使用时需要以下模块，其实除了前两个剩下的一般都已安装了： $ npm i -S lodash-webpack-plugin babel-plugin-lodash babel-core babel-loader babel-preset-es2015 webpack配置： 123456789101112131415161718192021webpack.config.jsvar LodashModuleReplacementPlugin = require('lodash-webpack-plugin');var webpack = require('webpack');module.exports = &#123; module: &#123; loaders: [&#123; loader: 'babel', test: /\\.js$/, exclude: /node_modules/, query: &#123; plugins: ['transform-runtime', 'lodash'], presets: ['es2015'] &#125; &#125;] &#125;, plugins: [ new LodashModuleReplacementPlugin, new webpack.optimize.OccurrenceOrderPlugin, new webpack.optimize.UglifyJsPlugin ]&#125; 其中babel-plugin-lodash的配置，也就是plugins: [&#39;lodash&#39;]，并不是一定要在loaders中，也可以单独定义babel。 123456789101112131415161718192021webpack.config.jsvar LodashModuleReplacementPlugin = require('lodash-webpack-plugin');var webpack = require('webpack');module.exports = &#123; module: &#123; loaders: [&#123; loader: 'babel', test: /\\.js$/, exclude: /node_modules/ &#125;] &#125;, babel: &#123; presets: ['es2015'], plugins: ['transform-runtime', 'lodash'] &#125;, plugins: [ new LodashModuleReplacementPlugin, new webpack.optimize.OccurrenceOrderPlugin, new webpack.optimize.UglifyJsPlugin ]&#125; 又或者是.babelrc文件中。 以上工作完成了，在每个你需要使用 lodash 函数的文件中只需要引用一次 lodash，即可调用任意函数而不会造成完全打包。 12import _ from 'lodash'_.add(1, 2) // 打包时只会引入这一个函数模块 注意：必须要使用 ES2015 的模块引用方式才有效。 End以上即是我目前所知道的几种方式，如果哪位朋友有更好的方式（比如只需要全局引入一次），请一定分享与我！😋","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"正确使用Vue指令的钩子函数","slug":"2019/vue-directive-hook","date":"2019-03-24T07:28:24.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/vue-directive-hook/","link":"","permalink":"https://summxu.github.io/2019/vue-directive-hook/","excerpt":"","text":"在 Vue 中可以把一系列复杂的操作包装为一个指令。 什么是复杂的操作？我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段的掩盖等。我们总是期望以操作数据的形式来实现功能逻辑。 钩子函数对于自定义指令的定义，Vue2 有 5 个可选的钩子函数。 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次，指令与元素解绑时调用。接下来，定义一个简单的指令以验证这些钩子函数的触发时机。123456&lt;div id=\"app\"&gt; &lt;my-comp v-if=\"msg\" :msg=\"msg\"&gt;&lt;/my-comp&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt; &lt;button @click=\"uninstall\"&gt;卸载&lt;/button&gt; &lt;button @click=\"install\"&gt;安装&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243Vue.directive('hello', &#123; bind: function (el) &#123; console.log('bind') &#125;, inserted: function (el) &#123; console.log('inserted') &#125;, update: function (el) &#123; console.log('update') &#125;, componentUpdated: function (el) &#123; console.log('componentUpdated') &#125;, unbind: function (el) &#123; console.log('unbind') &#125;&#125;)var myComp = &#123; template: '&lt;h1 v-hello&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;', props: &#123; msg: String &#125;&#125;new Vue(&#123; el: '#app', data: &#123; msg: 'Hello' &#125;, components: &#123; myComp: myComp &#125;, methods: &#123; update: function () &#123; this.msg = 'Hi' &#125;, uninstall: function () &#123; this.msg = '' &#125;, install: function () &#123; this.msg = 'Hello' &#125; &#125;&#125;) 页面加载时12bindinserted 组件更新时点击“更新”按钮，更改数据触发组件更新。 12updatecomponentUpdated 卸载组件时点击“卸载”按钮，数据置空否定判断以触发组件卸载。 unbind 重新安装组件时点击“安装”按钮，数据赋值肯定判断以触发组件重新安装。 12bindinserted 区别从案例的运行中，对 5 个钩子函数的触发时机有了初步的认识。存疑的也就是bind和inserted、update和componentUpdated的区别了。 bind 和 inserted据文档所说，插入父节点时调用 inserted，来个测试。 12345678bind: function (el) &#123; console.log(el.parentNode) // null console.log('bind')&#125;,inserted: function (el) &#123; console.log(el.parentNode) // &lt;div id=\"app\"&gt;...&lt;/div&gt; console.log('inserted')&#125; 分别在两个钩子函数中输出父节点：bind 时父节点为 null，inserted 时父节点存在。 update 和 componentUpdated关于这两个的介绍，从字眼上看感觉是组件更新周期有关，继续验证。 12345678update: function (el) &#123; console.log(el.innerHTML) // Hello console.log('update')&#125;,componentUpdated: function (el) &#123; console.log(el.innerHTML) // Hi console.log('componentUpdated')&#125; 没毛病，update 和 componentUpdated 就是组件更新前和更新后的区别。 结论文档说的没错…😒Demo 最佳实践根据需求的不同，我们要选择恰当的时机去初始化指令、更新指令调用参数以及释放指令存在时的内存占用等。 比较常见的场景是：用指令包装一些无依赖的第三方库以扩展组件功能。而一个健壮的库通常会包含：初始化实例、参数更新和释放实例资源占用等操作。 12345678910111213141516Vue.directive('hello', &#123; bind: function (el, binding) &#123; // 在 bind 钩子中初始化库实例 // 如果需要使用父节点，也可以在 inserted 钩子中执行 el.__library__ = new Library(el, binding.value) &#125;, update: function (el, binding) &#123; // 模版更新意味着指令的参数可能被改变，这里可以对库实例的参数作更新 // 酌情使用 update 或 componentUpdated 钩子 el.__library__.setOptions(Object.assign(binding.oldValue, binding.value)) &#125;, unbind: function (el) &#123; // 释放实例 el.__library__.destory() &#125;&#125;)","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}]},{"title":"使用队列解决插队业务场景","slug":"2019/queue-solve-continuous","date":"2019-03-01T01:02:36.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/queue-solve-continuous/","link":"","permalink":"https://summxu.github.io/2019/queue-solve-continuous/","excerpt":"","text":"为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。 我觉得用“插队”来描述这个场景真是再好不过了。 队列既然有人要“插队”，我们就要定义一个规则：先进先出。也就是数据结构中的“队列”了。 javascript 中队列的实现： 1234567891011121314151617181920// 实现1var queue = []// 进队queue.push(1)queue.push(2)queue.push(3)// 出队queue.shift() // 1queue.shift() // 2queue.shift() // 3// 实现2var queue2 = []// 进队queue2.unshift(1)queue2.unshift(2)queue2.unshift(3)// 出队queue2.pop() // 1queue2.pop() // 2queue2.pop() // 3 实践定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。 12var requestQueue = []var XHR = function(method, url, param) &#123;&#125; 点击操作的入口函数，先创建请求进队。因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。 123456function myClick(method, url, param) &#123; var len = requestQueue.push(XHR(method, url, param)) if(len === 1) &#123; update() &#125;&#125; 执行的永远是队列中的第一个请求。当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。如果存在未完成的请求，继续调用更新操作。 1234567function update() &#123; requestQueue[0].then(function(res)&#123; // request success requestQueue.shift() requestQueue.length &amp;&amp; update() &#125;)&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"如何为Canvas中特定图形绑定事件？","slug":"2019/canvas-event","date":"2019-02-14T10:47:15.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2019/canvas-event/","link":"","permalink":"https://summxu.github.io/2019/canvas-event/","excerpt":"","text":"Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。 我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件时，动态判断当前响应元素为目标子节点时再执行对应的操作。 这个思想同样也可以用在 Canvas 上，只需要为 canvas 元素绑定事件，事件响应时判断当前鼠标位置处于哪个图形之上，执行对应的操作。 isPointInPathcontext.isPointInPath(x, y); 理论上讲，想要知道一个点是否处于一个图形之中，现成的算法应该是有很多了。不过难得 canvas 本身就提供了这样的函数，用来判断一个点是否处于当前路径中。 1234var c = document.getElementById('canvas');var ctx = c.getContext('2d');ctx.rect(0, 0, 200, 200);console.log(ctx.isPointInPath(50, 100)) // true 就像这样，当你创建一个矩形时，就会产生一个路径，此时就可以调用该方法去判断一个点是否存在于该路径。 产生路径的函数还有其他，比如：lineTo()、clip()、arc()、arcTo() 等。 实现图形的事件绑定先来个简单的饼图吧。 1234567891011121314151617181920var canvas = document.getElementById('c');var ctx = canvas.getContext('2d');var r = canvas.width / 2;ctx.beginPath();ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3'; //蓝色ctx.fill();ctx.beginPath();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336'; //红色ctx.fill();function isInPath (x, y)&#123; ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y);&#125;canvas.addEventListener('click', function(e)&#123; if(isInPath(e.offsetX, e.offsetY)) &#123; console.log('hello') &#125;&#125;) 现在创建一个红蓝拼接的饼图，isInPath 方法判断一个点是否处于蓝色区。理想的结果是只有当鼠标点击区域为蓝色区域时才输出hello。 但事实确不是如此，示例Demo。无论点击红色还是蓝色区域均会输出 hello，这是怎么回事呢 路径既然 isPointInPath(x, y) 的基于路径判断的，那我们就从路径入手。 123456ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3';ctx.fill();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336';ctx.fill(); 当我们把画图时的 ctx.beginPath() 去掉后，发现生成的图形变成一个红色的整圆了：示例Demo。 beginPath() 用来重置路径，由于第一个半圆画完路径未重置，第二个半圆就绘制了两条路径。这似乎解释了上个问题的答案。 在 isInPath(x, y)函数中，由于路径没有重置，所以最终最终判断的不止是 ctx.arc(r, r, r, 0, Math.PI * 1) 这个路径，还有方法外的画红色圆的路径。两个路径加一起自然就是个整圆，所以无论蓝色区还是红色区都会输出。 正确结果12345function isInPath (x, y)&#123; ctx.beginPath(); ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y)&#125; 修改 isInPath 函数，加入重置路径，结果正确输出","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"Vue组件间样式污染大坑","slug":"2018/vue-scoped-keng","date":"2018-12-03T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/vue-scoped-keng/","link":"","permalink":"https://summxu.github.io/2018/vue-scoped-keng/","excerpt":"","text":"我们都知道，Vue 组件内的样式可以写在 Style 标签下，而各组件之间的样式冲突(污染)问题也十分常见，当然我们可以尽量避免起相同的类名，但项目较大的时候，Class类名时而会冲突。 当然 Vue官方也给了我们解决方法，就是定义了 scoped 这个属性的设置： 这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover。 最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在 标签内。 但是问题就在于 虽然加了scoped,但是却仍热无法锁住用@import引入的外部css文件 这里的解决方法也比较神奇，就是把引入的css文件改为使用预处理器处理的 less sass 或者 styl 文件，具体原理暂时还不得而知 使用 /deep/ 来解决更深一级的标签","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"Vue.$emit Promise 回调后的深坑","slug":"2018/vue-emit-keng","date":"2018-09-24T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/vue-emit-keng/","link":"","permalink":"https://summxu.github.io/2018/vue-emit-keng/","excerpt":"","text":"有个登录需求，是 login.vue 属于 App.vue 的子组件，默认路由页面是进入 login.vue 因为你一开始需要验证登录用户，又要通过登录用户来进行","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"Express + 模板引擎 + jQuery load 实现局部页面的异步加载","slug":"2018/express-jqueryload","date":"2018-09-11T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/express-jqueryload/","link":"","permalink":"https://summxu.github.io/2018/express-jqueryload/","excerpt":"","text":"项目匿名评论系统的局部异步加载服务的实现 问题需求目前的论坛系统带有聊天室，在浏览帖子的同时可以随时聊天，这就意味着页面不能经常刷新，一是刷新就会重连服务器，导致一直断开重连的状态，二是刷新之后聊天记录消失，还要做数据的持久化，再者就是影响用户体验，所以最好的解决方案就是异步加载局部页面。前后端分离是挺好做，直接load加载本地页面就可以，但一和express结合起来就不知道该怎么办了。 解决方案其实仔细思考这个问题并不复杂，和前后端分离的模式是完全一模一样的，只是把本地要加载的局部页面换成了服务器上渲染出来的局部页面 。 这时就需要重新配置express的路由和 render 的页面分离，路由多了两条： 123456789101112131415161718192021.get('/main',(req,res) =&gt; &#123; mongo.Post.find((err, postdata) =&gt; &#123; if (err) return res.status(500) /* 对象属性抽离，解决template陷入递归 */ /* mogon取出的对象不正常，转换一下 */ var data = JSON.stringify(postdata) data = JSON.parse(data) var images = [] data.forEach((element, a) =&gt; &#123; images.push(element.images) delete element.images &#125;); res.render('./components/main.html', &#123; post: data, images: images &#125;) &#125;)&#125;).get('/sendpost',(req,res) =&gt; &#123; res.render('./components/sendpost.html')&#125;) 渲染出独立页面，这是各个页面的路径分配： 这样两个在服务器路径中真实存在的页面出来了，通过浏览器也能访问，只不过没了样式： 在客户端上写上这么一句，就大功告成了！！ $(&#39;.center .left&#39;).load(&quot;/main&quot;);$(&#39;.center .left&#39;).load(&quot;/sendpost&quot;);","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://summxu.github.io/tags/jQuery/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"MongoDB的查找find方法取出不正经对象","slug":"2018/mongo-object-files","date":"2018-09-09T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/mongo-object-files/","link":"","permalink":"https://summxu.github.io/2018/mongo-object-files/","excerpt":"","text":"项目匿名评论系统的MongoDB操作 起因：用art-template来渲染前端页面的时候，数组里又包含了数组，这是模板引擎报了一个递归错误，貌似 模板引擎不支持递归？ 想到的解决办法是对象的 数组属性 分离渲染，在删除对象属性时遇到了问题。 delete 方法原生 js 中支持 delete 方法，即删除对象里的某个属性，并且带有一个布尔类型的返回值，本事一个很简单的事情，放到普通代码中也很好实现，但是和MongoDB集合起来的时候，就出了问题。 原因就是 mongoDB find 出来的对象 不正经 这里的id没有引号，原本js代码是不能执行，更不能直接删除对象的属性值，但是这里很奇怪的是，js居然不会报错？？而把这个对象格式直接复制到正常程序里却报错。 正确的解决办法就是转换一下 对象的类型： 1234/* 对象属性抽离，解决template陷入递归 *//* mogon取出的对象不正常，转换一下 */var data = JSON.stringify(postdata)data = JSON.parse(data) 循环嵌套的异步还遇到就是循环图片的时候，等循环结束要res。send（）图片数组，但是 fs.rename 是一个异步操作，要等到循环结束，可以这么操作： 12345678910111213141516171819202122if (req.files.pic.length &gt; 1) &#123; var c = req.files.pic.length req.files.pic.forEach(item =&gt; &#123; var target_path = &apos;./upload/&apos; + item.name fs.rename(&apos;./&apos; + item.path, target_path, function (err) &#123; if (err) throw err; postObj.images.push(target_path.replace(&apos;.&apos;,&apos;&apos;)) c--; if (c === 0 )&#123; console.log(postObj.images) postObj.save((err, result) =&gt; &#123; if (err) throw err res.send(&apos;success&apos;) &#125;) &#125; // 删除临时文件夹文件, fs.unlink(&apos;./&apos; + item.path, function () &#123; if (err) throw err; &#125;); &#125;); &#125;); 用计数器判断循环的次数，为 0 时执行代码。 听说用递归也可以","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"Web文件上传实现","slug":"2018/upload-files","date":"2018-09-09T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/upload-files/","link":"","permalink":"https://summxu.github.io/2018/upload-files/","excerpt":"","text":"项目匿名评论系统的文件上传服务的实现 做了个匿名评论论坛的小系统，里面涉及到了图片的上传，期间遇到的问题汇总。 HTML首先上传文件还是要套到form表单里，并且文件上传是 input type = file 的一个标签‘ 12345678&lt;form id=&quot;form1&quot; method=&quot;POST&quot; enctype =&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;color&quot; for=&quot;exampleInputFile&quot;&gt;图片发表&lt;/label&gt; &lt;input class=&quot;color&quot; type=&quot;file&quot; id=&quot;exampleInputFile&quot; multiple=&quot;multiple&quot; onchange=&quot;imagechange(this)&quot; value=&quot;&quot;&gt; &lt;/div&gt; &lt;textarea style=&quot;resize:none;&quot; name=&quot;content&quot; class=&quot;form-control&quot; rows=&quot;9&quot;&gt;&lt;/textarea&gt; &lt;button style=&quot;margin-top:10px;&quot; type=&quot;button&quot; onclick=&quot;upload1()&quot; class=&quot;btn btn-primary btn-lg btn-block&quot;&gt;发表发表发发表发表发表表发发表发表&lt;/button&gt;&lt;/form&gt; 这里上表单上传多了一个 enctype =&quot;multipart/form-data&quot; 属性，这是代表表单可以上传带有数据的文件。input type = file 的控件是文件标签，其中 class=&quot;form-control&quot; 是可以上传多个文件？ （但我实践上这个属性并没有什么用，最后还是在js里push了多文件上传） onchange=&quot;imagechange(this)&quot; 这个是在文件选择被改变的事件，这里把本dom对象传给js就不用麻烦的获取该dom对象了。 其中该dom节点有一个files对象，这是一个数组，里面放了文件的对象，按道理来说 enctype =&quot;multipart/form-data&quot;会在这里生效在多文件的时候往files里添加多个文件，但实际并没有，新的文件还是把旧的文件覆盖了。所以下面我手动push到了一个新的数组里。这地方还有待研究 注意的是这里一个坑，当我把函数名命名为 upload 的时候，居然不会生效？ 难道是函数命名有冲突？ JS12345678910111213141516171819202122232425function imagechange(a) &#123; files.push(a.files);&#125;function upload1() &#123; var fd = new FormData(document.getElementById(&apos;form1&apos;)) files.forEach(item =&gt; &#123; fd.append(&apos;pic&apos;,item[0]) &#125;); fd.append(&apos;postuser&apos;,&apos;小兵旭旭&apos;) $.ajax(&#123; url: &quot;/sendpost&quot;, type: &quot;POST&quot;, data: fd, sync: false, processData: false, // 告诉jQuery不要去处理发送的数据 contentType: false, // 告诉jQuery不要去设置Content-Type请求头 success: function(response,status,xhr)&#123; console.log(xhr); if (response === &apos;success&apos;) &#123; $(&apos;#sendpost&apos;).toggle(); location.reload() &#125; &#125; &#125;);&#125; js里是用了新的 FormData 对象，这个对象可以接收一个form表单的对象，并且 FormData 可以自己添加属性的，他会一并跟随上传到服务器上。这里把文件数组添加了进去，再通过ajax异步发送到服务器，摆脱了页面停止响应的异步表单提交。 不过需要注意的是，直接console.log（FormData）的对象看上去是个空的对象，他传的参数是不直接在对象里的，而在对象的更深处 这种情况可以在 network 里查看到传出的参数 Node…在Node接收文件的时候也有许多坑，其中就是 express 接收post的请求，并且含有文件数据请求的时候，需要一个中间件 1234const multiparty = require(&apos;connect-multiparty&apos;).use(multiparty(&#123;uploadDir:&apos;./linshi&apos;&#125;))var mutipartMiddeware = multiparty();.post(&apos;/sendpost&apos;, mutipartMiddeware, (req, res) =&gt; &#123;&#125;) {uploadDir:’./linshi’} 配置了该中间件接收到的文件存放的临时目录。并且该中间件接收到的res有以下几个有用的参数： 1234req.body: 请求体req.files: 接收到的文件数组req.files.file.path: 临时存放文件的路径req.files.file.name: 接收到的文件名字 上面注意到，该中间件存放的是临时文件，并且文件名是随机命名的（req属性里有真实的文件名字），如果想正常保存上传来的文件，还是需要自己手动去处理： 12345678var target_path = &apos;./upload/&apos; + req.files.pic.namefs.rename(&apos;./&apos; + req.files.pic.path, target_path, function (err) &#123; if (err) throw err; postObj.images.push(target_path.replace(&apos;.&apos;,&apos;&apos;)) // 删除临时文件夹文件, fs.unlink(&apos;./&apos; + req.files.pic.path, function () &#123; if (err) throw err; &#125;); 这样一个基本的文件上传服务就完成了，当然还有很多判断需要自己手动去实现。这里是使用了 FormData 对象，MDN上也给出了不使用该对象的方法。 FromData上传文件的方法 Ajax序列化及文件上传","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"Vue-resouce改为Axios之旅","slug":"2018/vue-axios","date":"2018-08-27T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/vue-axios/","link":"","permalink":"https://summxu.github.io/2018/vue-axios/","excerpt":"","text":"尤雨溪说了，vue2.0 将不再维护自己的原生请求插件 vue-resource 而推荐使用axios，所以以后就用axios来发送vue请求了。 使用 cnpm 安装 axioscnpm install axios --save-dev 安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton。这里只说修改原型链的方式改写原型链 首先在 main.js 中引入 axiosimport axios from &#39;axios&#39; 这时候如果在其它的组件中，是无法使用 axios 命令的。所以我们将 axios 改写为 Vue 的原型属性 Vue.prototype.$http= axios 在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令例如 12345678910methods: &#123; show() &#123; this.$http(&#123; method: &apos;get&apos;, url: &apos;/user&apos;, data: &#123; name: &apos;virus&apos; &#125; &#125;)&#125; 配置 axios实际上只有 url 是必须的，完整的 api 可以参考https://link.jianshu.com/?t=https://www.kancloud.cn/yunye/axios/234845 对于get请求 12345axios.get(&apos;/user&apos;, &#123; params:&#123; name:&quot;virus&quot; &#125;&#125;) 对于POST请求 123axios.post(&apos;/user&apos;,&#123; name:&quot;virus&quot; &#125;) 一次并发多个请求 12345678910function getUserAccount()&#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions()&#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios可以通过配置（config）来发送请求 1234567axios(&#123; method:&quot;POST&quot;, url:&apos;/user/1111&apos;, data:&#123; name:&quot;virus&quot; &#125;&#125;); 完整的请求还应当包括 .then 和 .catch 123456.then(function(res)&#123; console.log(res) &#125;).catch(function(err)&#123; console.log(err) &#125;) 当请求成功时，会执行 .then，否则执行 .catch这两个回调函数都有各自独立的作用域，如果直接在里面访问 this，无法访问到 Vue 实例,这时只要添加一个 .bind(this) 就能解决这个问题 123.then(function(res)&#123; console.log(this.data)&#125;.bind(this)) 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名12345678910111213axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]])","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"Bootstrap响应式轮播图问题","slug":"2018/mobileweb-bootstrap-slide","date":"2018-08-24T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/mobileweb-bootstrap-slide/","link":"","permalink":"https://summxu.github.io/2018/mobileweb-bootstrap-slide/","excerpt":"","text":"bootstrap 原生轮播图，因为轮播图是图片，所以为了做响应式就要麻烦一些，因为要涉及到图片的大小还有小屏幕的显示比例，把这次遇到的问题重新捋一下 。 两站单独设计因为PC端的轮播图是定高的，而且图片尺寸又大，但是移动端是百分比可缩小的，图片是小图，所以只能是两站单独设计，这是两站单独的CSS: 1234567891011121314.pc_img &#123; display: block; height: 400px; background: no-repeat center; background-size: cover;&#125;.m_img &#123; display: block; width: 100%;&#125;.m_img img&#123; display: block; width: 100%;&#125; 这样HTML的结构就可以这么放(用了模板引擎之后)，并且用了响应式工具使两者实现不同屏幕尺寸单独显示，不会同时显示出来。。 1234&lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt; &lt;a class=&quot;m_img hidden-lg hidden-md hidden-sm&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot;&gt;&lt;img src=&quot;&#123; &#123;$value&#125; &#125;&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/a&gt; &lt;a class=&quot;pc_img hidden-xs&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot; style=&quot;background-image: url(&apos;&#123; &#123;$value&#125; &#125;&apos;);&quot;&gt;&lt;/a&gt;&lt;/div&gt; 这样虽说是视觉上看不出来有什么问题，但是在请求中两者都会同时请求，加载的图片太多，而且只是小屏幕的话，会多加载大屏幕中的大图片。。。 为了优化 不得不用js判断访问的屏幕大小。这样一系列的问题就来了。 屏幕大小判断并单独加载因为要单独判断当前屏幕的大小来指定到底要加载哪种图片，什么结构，又要做响应式，就会涉及到以下两点问题： 判断页面大小，请求页面数据，渲染模板引擎 响应式实时判断页面大小，而不重复发送请求 难点在第二点，我们只需要页面在需要请求数据的时候才不得不请求（如果现在是大屏幕，只请求大图片，如果是小屏幕，之请求小图片。如果从大屏幕响应式到了小屏幕，这时不得不再去求情一次） 做响应式，实时判断页面大小，又不用每次改变大小时去实时发送请。这时我们可以在特定的时候来请求数据，并把数据缓存下来，这里用的方法是绑定到 window 上一个全局对象的属性，并且用 回调函数 把全局对象的属性返回，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 判断访问来源 ， 以便使pc和m都加载 */$(document).ready(function () &#123; function getData(callback) &#123; /* 判断 window.data 是不是有缓存数据 */ if (window.data) &#123; callback &amp;&amp; callback(window.data) &#125;else &#123; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;./data.json&quot;, dataType: &quot;json&quot;, // async: false, success: function (response) &#123; window.data = response callback &amp;&amp; callback(window.data) &#125; &#125;); &#125; &#125; function render() &#123; /* 这里通过回调函数获取传递过来的数据，是为了每次调用 render 的时候不ajax */ getData(function (response) &#123; var data = &#123;&#125; var iSMobile = window.innerWidth &lt; 750 ? true : false if (iSMobile) &#123; data.type = &apos;m&apos; data.content = response.m var html = template(&apos;carousel-content&apos;,data) $(&apos;.banner .carousel-inner&apos;).html(html) var html = template(&apos;carousel-indicators&apos;,data) $(&apos;.banner .carousel-indicators&apos;).html(html) &#125;else&#123; data.type = &apos;pc&apos; data.content = response.pc var html = template(&apos;carousel-content&apos;,data) $(&apos;.banner .carousel-inner&apos;).html(html) var html = template(&apos;carousel-indicators&apos;,data) $(&apos;.banner .carousel-indicators&apos;).html(html) &#125; &#125;) &#125; /* 这里要做响应式，所以要把数据渗透成全局对象 window.data */ $(window).on(&apos;resize&apos;,function () &#123; render() /* 通过js主动触发事件 */ &#125;).trigger(&apos;resize&apos;,function ()&#123; render() &#125;) 这里要注意一点，就是当数据请求和没请求的两种状态下，都要进行回调函数 1234success: function (response) &#123; window.data = response callback &amp;&amp; callback(window.data)&#125; 最后用 jQuery 的 trigger 方法来主动调用一次 window.onresize 就不用手动调用 render() 了。 实现移动端滑动功能123456789101112131415161718192021222324/* 加载轮播图滑动 控制 prev 和 next */ var startX = 0 var endX = 0 isMove = false $(&apos;#carousel-id&apos;).on(&apos;touchstart&apos;, function (e) &#123; startX = e.originalEvent.touches[0].clientX; &#125;).on(&apos;touchmove&apos;,function(e)&#123; isMove = true /* originalEvent 是原生事件的属性。 */ endX = e.originalEvent.touches[0].clientX; &#125;).on(&apos;touchend&apos;,function(e)&#123; lr = endX - startX tmp = Math.abs( endX - startX) if (isMove &amp;&amp; tmp &gt; 50) &#123; if (lr &lt; 0) &#123; $(&apos;.carousel&apos;).carousel(&apos;next&apos;) console.log(&apos;next&apos;); &#125;else &#123; $(&apos;.carousel&apos;).carousel(&apos;prev&apos;) console.log(&apos;prev&apos;) &#125; &#125; &#125;);&#125;); 关于模板引擎模板引擎是个好东西，在获取到数据绑定到HTML页面上的时候，用DOM方式来操作确实有点难受，而且还弄的十分混乱，特别是当数据比较多的时候。这时候模板引擎能更友好的将数据渲染到页面上，甚至模板引擎本身提供了简单好用的一些方法 这里使用的模板引擎是 Arttemplate其他的模板引擎的使用方法都大同小异，基本的使用方法大概是这样：js: 1234&lt;!-- 渲染html结构 ，放到 script 标签中--&gt;var html = template(&apos;arttemplate&apos;,&#123;value:data&#125;)&lt;!-- 把渲染好的HTML放到指定的容器中 --&gt;document.getEmementById(&apos;content&apos;).innerHTML(html) 因为script 的 type 只要是不为 text/javascript 就不会别解析成js语法 所以很多时候方便存一些有结构型的数据到script标签中，模板引擎也是基于这个。 但是模板引擎 使用 { { } } 里面的内容是 可以直接写 js 代码的html: 1234567891011121314151617181920&lt;script id=&quot;carousel-content&quot; type=&quot;text/x-arttemplate&quot;&gt; &#123; &#123; if $data.type == &apos;m&apos; &#125; &#125; &#123; &#123; each $data.content &#125; &#125; &lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt; &lt;a class=&quot;m_img hidden-lg hidden-md hidden-sm&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot;&gt;&lt;img src=&quot;&#123; &#123;$value&#125; &#125;&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &#123; &#123; /each &#125; &#125; &#123; &#123; else &#125; &#125; &#123; &#123; each $data.content &#125; &#125; &lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt; &lt;a class=&quot;pc_img hidden-xs&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot; style=&quot;background-image: url(&apos;&#123; &#123;$value&#125; &#125;&apos;);&quot;&gt;&lt;/a&gt; &lt;/div&gt; &#123; &#123; /each &#125; &#125; &#123; &#123; /if &#125; &#125;&lt;/script&gt;&lt;script id=&quot;carousel-indicators&quot; type=&quot;text/x-arttemplate&quot;&gt; &#123; &#123; each $data.content &#125; &#125; &lt;li data-target=&quot;#carousel-id&quot; data-slide-to=&quot;&#123; &#123;$index&#125; &#125;&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &#123; &#123; /each &#125; &#125;&lt;/script&gt; 这样页面就能方便的处理数据了。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://summxu.github.io/tags/Bootstrap/"}],"author":"BoomXu"},{"title":"Overflow实现圣杯布局","slug":"2018/grail-layout","date":"2018-08-23T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/grail-layout/","link":"","permalink":"https://summxu.github.io/2018/grail-layout/","excerpt":"","text":"工作过程中遇到了很多问题，也学到了很多知识，这次用Overflow来触发BFC以实现双飞翼布局，很简单的一件事。但中间却有点学问。 实现原理所谓原理就是用Overflow来触发BFC（块级格式化范围）。 1.这是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。 2.另一个通俗点的解释是：在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 inline formatting context(行内格式化上下文) 里格式化。任何被渲染的元素都属于一个 box ，并且不是 block ，就是 inline 。即使是未被任何元素包裹的文本，根据不同的情况，也会属于匿名的 block boxes 或者 inline boxes。所以上面的描述，即是把所有的元素划分到对应的 formatting context 里。 总的来说BFC是和浮动划分开来，两者互不干扰，所以在center 中间的元素 宽度 100 % 不会铺满整个窗口 实现代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;overflow&lt;/title&gt; &lt;style&gt; .left &#123; float: left; width: 100px; height: 100px; background-color: skyblue; &#125; .right &#123; float: right; width: 100px; height: 100px; background-color: skyblue; &#125; .center &#123; overflow: hidden; height: 100px; background-color: pink; line-height: 100px; &#125; .search &#123; height: 50%; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;input class=\"search\" type=\"text\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 但是要注意，left center 和 right 标签的位置顺序不能放错。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}],"author":"BoomXu"},{"title":"Webpack CSS分类打包和html img不打包配置","slug":"2018/webpack-html-withimg","date":"2018-08-23T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/webpack-html-withimg/","link":"","permalink":"https://summxu.github.io/2018/webpack-html-withimg/","excerpt":"","text":"介绍两个webpack插件的使用 问题还原 在webpack打包之后的文件，往往都会打包到bundle.js中。但是为了目录的维护性，通常要把CSS单独分离出来这时需要 extract-text-webpack-pluginnpm install extract-text-webpack-plugin --save-dev 配置上首先引入插件，然后再创建多个新的 extract 对象，并且在 plugins 引用他们 123456789101112var Extract = require('extract-text-webpack-plugin')var extractCss = new Extract('css/base.css')var extractLess = new Extract('css/[name].css')var extractScss = new Extract('css/[name].css')var extractStyl = new Extract('css/[name].css')plugins: [ extractCss, extractLess, extractScss, extractStyl], 下一步就是修改原本的 rules loader规则 12345&#123; test: /\\.css$/, use: extractCss.extract( ['css-loader']) &#125;, // 处理 CSS 文件的 loader&#123; test: /\\.less$/, use: extractLess.extract(['css-loader', 'less-loader']) &#125;, // 处理 less 文件的 loader&#123; test: /\\.scss$/, use: extractScss.extract(['css-loader', 'sass-loader']) &#125;, // 处理 scss 文件的 loader&#123; test: /\\.styl$/, use: extractStyl.extract(['css-loader', 'stylus-loader']) &#125;, // 处理 stylus 文件的 loader&#123; test: /\\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&amp;name=[name].[ext]&amp;outputPath=./images&amp;publicPath=../images'&#125;, // 处理 图片路径的 loader https://www.npmjs.com/package/extract-text-webpack-plugin 虽然上面引入了 url-loader 来解析图片文件，但是html内的img：src图片并不能通过此方式正常解析，原因是因为，webpack不能正确找到引入的图片，解决方式有两种。、 让webpack知道引入的图片路径&lt;img src=&quot;${ require(&#39;..assets/logo.png&#39;) }&quot;&gt; 借助loader html-withimg-loadernpm install html-withimg-loader --save 在rule 中加入 { test: /\\.(htm|html)$/i, loader: &#39;html-withimg-loader&#39;} //处理html img 中的图片 完事！ https://github.com/wzsxyz/html-withimg-loader","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"Vue-loader版本遇到的坑","slug":"2018/vue-loader-version","date":"2018-07-21T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/vue-loader-version/","link":"","permalink":"https://summxu.github.io/2018/vue-loader-version/","excerpt":"","text":"在学习Vue.js和Webpack的路上遇到了不少问题,也找到了相对的解决办法, 这次记录下在vue-loader版本遇到的问题. vue-loader简介在webpack中加载第三方的文件支持,就要有第三方的文件解析工具,在vue的组件模板文件中,要有vue-loader的支持才可以.他可以将vue文件转换为JS模块； vue-loader特性（1）ES2015默认支持（2）允许对VUE组件的组成部分使用其他webpack loader;比如对&lt; style &gt;使用SASS（编译CSS语言），对&lt; template &gt;使用JADE（jade是一个高性能的模板引擎，用JS实现，也有其他语言的实现—php,scala,yuby,python,java，可以供给node使用）（3）.vue文件中允许自定义节点，然后使用自定义的loader处理他们（4）对&lt; style &gt;&lt; template &gt;中的静态资源当做模块来对待，并且使用webpack loaders进行处理（5）对每个组件模拟出CSS作用域（6）支持开发期组件的热重载在编写vue应用程序时，组合使用webpack跟vue-loader能带来一个现代。灵活并且非常强大的前端工作流程； vue-loader@14 Version特性上面说了,允许对VUE组件的组成部分使用其他webpack loader;比如对&lt; style &gt;使用SASS（编译CSS语言），对&lt; template &gt;使用JADE，但是我在运行的过程中在vue组件模板文件下写stylus的样式一直报错 总是提示说需要装一个loader支持，但是我已经装了 而且语法也有写错 这是我看到报错里提到了vue-loader，果然是vue-loader 的版本问题 vue-loader@15 Version在最新的npm上装的是vue-loader 15.x 版本，但是现在直接npm装的最新版本的vue-loader 15 把这个功能给去除了,同时在vue-loader 15配置的时候还要引入一个插件 1234567815版本以上的vue-loader 需要插件支持 , 插件是个对象,这里引入的时候要转换成对象才行const &#123;VueLoaderPlugin&#125; = require(&apos;vue-loader&apos;)plugins: [ //15版本以上的vue-loader 需要插件支持 new VueLoaderPlugin()], 不仅如此，15版本的vue-loader还 去除了 对&lt; style &gt; 编译CSS预处理的支持 现在暂时使用14版本的vue-loader，15版本的新特性和使用方法还需要进一步的学习。。。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"DIV的Height为什么不能100%","slug":"2018/div-height100","date":"2018-05-29T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/div-height100/","link":"","permalink":"https://summxu.github.io/2018/div-height100/","excerpt":"","text":"跟着百度IFE的基础做做，确实是遇到不少问题，在《三种简历》这一章，侧边导航就遇到了高度无法铺满的问题。 那为什么 height:100%; 不起作用 在html布局中body内第一个div盒子对象设置100%高度height样式，是无法成功显示100%高度的。这个是因为body高度默认值为自适应的，所以及时设置body第一个布局div高度为百分比也是无效的，因为div解析上级高度为0，自然div height 100%实际高度也为0。 浏览器根本就不计算内容的高度，除非内容超出了视窗范围(导致滚动条出现)。或者你给整个页面设置一个绝对高度。否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑。 因为页面并没有缺省的高度值，所以，当你让一个元素的高度设定为百分比高度时，无法根据获取父元素的高度，也就无法计算自己的高度。换句话说，父元素的高度只是一个缺省值：height: auto;。当你要求浏览器根据这样一个缺省值来计算百分比高度时，只能得到undefined的结果。也就是一个null值，浏览器不会对这个值有任何的反应。 如果想让一个元素的百分比css高度height: 100%;起作用，你需要给这个元素的 所有父元素 的高度设定一个有效值。 这里的 所有父元素 我发现其实是错误的，只要根元素 &lt; html &gt; 的高度设置好，其他子元素都是自动继承的。。而父元素块HTML本身是没有高度的 以上当我没说，还是必须要所有的父元素都要设置。 123html,body&#123; height:100%;&#125; 解决方法方法一为 根元素 &lt; html &gt; 设置高度 123html&#123; height:100%;&#125; 方法二方法二就是使用绝对定位，使div脱离标准流，也就是脱离了他的根元素 html 123456789.title&#123; float: left; position:absolute; width: 20%; height: 100%; background-color: dodgerblue; font-size: 28px; font-weight: bold;&#125; 结果Height:100%的方法，缺点缺非常显著，你在div内定义 padding 或者是 margin 就会把页面撑开，也就是说超过了 100%，就会出现一个非常不完美的滚动条。。 当然你可以用 overflow: hidden; 溢出隐藏，但是这样只是掩耳盗铃，滚动条是没了，页面的滚动却不受控制了。 神奇的CSS 。。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}],"author":"BoomXu"},{"title":"Python网页自动化操作","slug":"2018/python-selenium","date":"2018-05-29T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/python-selenium/","link":"","permalink":"https://summxu.github.io/2018/python-selenium/","excerpt":"","text":"最近几天忙忙碌碌却感到忙出来什么好结果，不过最近几天要抓紧时间学学英语。因为最近有一个表需要一直重复向网页添加信息，于是就借此机会研究了Python的网页自动化，在此是用了Selenium框架。。 什么是Seleniumselenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。 selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。 selenium基本使用在此之前先上段代码： 1234567891011121314browser = webdriver.Chrome()browser.get(&apos;http://sdxy.gov.cn:8888/auth/pub/loginerror&apos;)wait = WebDriverWait(browser, 10, 1.0)browser.set_page_load_timeout(8)browser.set_script_timeout(8)``` ## 声明浏览器对象首先selenium支持绝大多数主流浏览器，但是中间要有浏览器的驱动程序 在此我是调用的 **[chromedriver](http://npm.taobao.org/mirrors/chromedriver/)** 放到相同目录下就可以运行。`browser = webdriver.Firefox()`这是火狐的调用方式。## 访问页面 browser.get(“http://www.baidu.com&quot;)print(browser.page_source)browser.close() 12345用**rowser.get**方法可以打开网页**page_source**是提取网页源代码## 查找元素### 单个元素查找 from selenium import webdriver browser = webdriver.Chrome() browser.get(“http://www.taobao.com&quot;)input_first = browser.find_element_by_id(“q”)input_second = browser.find_element_by_css_selector(“#q”)input_third = browser.find_element_by_xpath(‘//*[@id=”q”]’)print(input_first)print(input_second)print(input_third)browser.close() 12345678910111213141516这里列举一下常用的查找元素方法：find_element_by_namefind_element_by_idfind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector下面这种方式是比较通用的一种方式：这里需要记住By模块所以需要导入from selenium.webdriver.common.by import By### 多个元素查找 from selenium import webdriver browser = webdriver.Chrome()browser.get(“http://www.taobao.com&quot;)lis = browser.find_elements_by_css_selector(‘.service-bd li’)print(lis)browser.close() 123456这样获得就是一个列表:![from zhaof](https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193737497-369795287.png)## 元素交互操作 from selenium import webdriver import time browser = webdriver.Chrome()browser.get(“http://www.taobao.com&quot;)input_str = browser.find_element_by_id(‘q’)input_str.send_keys(“ipad”)time.sleep(1)input_str.clear()input_str.send_keys(“MakBook pro”)button = browser.find_element_by_class_name(‘btn-search’)button.click() 123456789101112131415161718192021222324运行的结果可以看出程序会自动打开Chrome浏览器并打开淘宝输入ipad,然后删除，重新输入MakBook pro，并点击搜索Selenium所有的api文档：&lt;http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains&gt;### 交互动作将动作附加到动作链中串行执行from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = &quot;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;browser.get(url)browser.switch_to.frame(&apos;iframeResult&apos;)source = browser.find_element_by_css_selector(&apos;#draggable&apos;)target = browser.find_element_by_css_selector(&apos;#droppable&apos;)actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform()## 执行JavaScript这是一个非常有用的方法，这里就可以直接调用js方法来实现一些操作，下面的例子是通过登录知乎然后通过js翻到页面底部，并弹框提示 from selenium import webdriverbrowser = webdriver.Chrome()browser.get(“http://www.zhihu.com/explore&quot;)browser.execute_script(‘window.scrollTo(0, document.body.scrollHeight)’)browser.execute_script(‘alert(“To Bottom”)’) 12345678910111213141516## 元素操作 元素操作 | 方法---------|---------- 获取元素属性 | get_attribute(&apos;class&apos;) 获取文本值 | text 获取ID | id 位置 | location 标签名 | tag_name ## 等待当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0### 显式等待指定一个等待条件，并且指定一个最长等待时间，会在这个时间内进行判断是否满足等待条件，如果成立就会立即返回，如果不成立，就会一直等待，直到等待你指定的最长等待时间，如果还是不满足，就会抛出异常，如果满足了就会正常返回 from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC browser = webdriver.Chrome()browser.get(‘https://www.taobao.com/&#39;)wait = WebDriverWait(browser, 10)input = wait.until(EC.presence_of_element_located((By.ID, ‘q’)))button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, ‘.btn-search’)))print(input, button) 123### 隐式等待到了一定的时间发现元素还没有加载，则继续等待我们指定的时间，如果超过了我们指定的时间还没有加载就会抛出异常，如果没有需要等待的时候就已经加载完毕就会立即执行 from selenium import webdriver browser = webdriver.Chrome()browser.implicitly_wait(10)browser.get(‘https://www.zhihu.com/explore&#39;)input = browser.find_element_by_class_name(‘zu-top-add-question’)print(input) 12345678910111213141516171819202122232425## 条件判断1. title_is 标题是某内容2. title_contains 标题包含某内容3. presence_of_element_located 元素加载出，传入定位元组，如(By.ID, &apos;p&apos;)4. visibility_of_element_located 元素可见，传入定位元组5. visibility_of 可见，传入元素对象6. presence_of_all_elements_located 所有元素加载出7. text_to_be_present_in_element 某个元素文本包含某文字8. text_to_be_present_in_element_value 某个元素值包含某文字9. frame_to_be_available_and_switch_to_it frame加载并切换10. invisibility_of_element_located 元素不可见11. element_to_be_clickable 元素可点击12. staleness_of 判断一个元素是否仍在DOM，可判断页面是否已经刷新13. element_to_be_selected 元素可选择，传元素对象14. element_located_to_be_selected 元素可选择，传入定位元组15. element_selection_state_to_be 传入元素对象以及状态，相等返回True，否则返回False16. element_located_selection_state_to_be 传入定位元组以及状态，相等返回True，否则返回False17. alert_is_present 是否出现Alert## cookie操作get_cookies()delete_all_cookes()add_cookie() from selenium import webdriver browser = webdriver.Chrome()browser.get(‘https://www.zhihu.com/explore&#39;)print(browser.get_cookies())browser.add_cookie({‘name’: ‘name’, ‘domain’: ‘www.zhihu.com&#39;, ‘value’: ‘zhaofan’})print(browser.get_cookies())browser.delete_all_cookies()print(browser.get_cookies()) 12345## 选项卡管理通过执行js命令实现新开选项卡window.open()不同的选项卡是存在列表里browser.window_handles通过browser.window_handles[0]就可以操作第一个选项卡 import timefrom selenium import webdriver browser = webdriver.Chrome()browser.get(‘https://www.baidu.com&#39;)browser.execute_script(‘window.open()’)print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get(‘https://www.taobao.com&#39;)time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get(‘https://python.org&#39;)``` 还有很多强大的功能有待研究","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://summxu.github.io/tags/Python/"}],"author":"BoomXu"},{"title":"初次尝试Vue Jsx","slug":"2018/vue-jsx","date":"2018-04-23T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/vue-jsx/","link":"","permalink":"https://summxu.github.io/2018/vue-jsx/","excerpt":"","text":"Vue声明加载1234567891011&lt;script&gt;import Header from &apos;./todo/header.vue&apos;import Footer from &apos;./todo/footer.jsx&apos;export default &#123; components:&#123; Header, Footer, &#125;&#125;&lt;/script&gt; 这里用 components 方法来声明加载过来的外部文件。。 Jsx React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。我们不需要一定使用 JSX，但它有以下优点：JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。它是类型安全的，在编译过程中就能发现错误。使用 JSX 编写模板更加简单快速。 jsx更好的把js和html结合起来，可以很简单的做到原生js很复杂的操作，下面是一段代码： 12345678910111213141516import '../assets/styles/footer.styl'export default&#123; data() &#123; return &#123; author: 'BoomXu' &#125; &#125;, render() &#123; return( &lt;div id=\"footer\"&gt; &lt;span&gt;Written by &#123;this.author&#125;&lt;/span&gt; //这里用了this对像调用 &lt;/div&gt; ) &#125;&#125; jsx在生成html的时候用了 render()方法，其实vue和这个一样，vue里的 &lt;template&gt;标签其实就是用了render()方法来生成的html结构。 但是jsx不好的一点在于他不能直接写 style 需要引入外部文件才可以。 methods{} 声明方法","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"初次尝试Vue","slug":"2018/first-vue","date":"2018-04-22T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/first-vue/","link":"","permalink":"https://summxu.github.io/2018/first-vue/","excerpt":"","text":"我换了个Jekyll 随机自动换图的接口，以后不用每次都上传图片了 。。 https://img.xjh.me/random_img.php?type=bg&amp;ctype=nature&amp;return=302 速度还很快 天天好心情 VUE2简介数据绑定省去js操作dom，动态的把js的数据绑定到html，数据一旦改变，html数据跟着改变 vue文件开发方式1234567891011&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 组件化开发，可以自定义标签，包含html、js、css 。。 在一个文件里面直接写各种组建。 render方法组件数据变化时vue会自动用render方法去遍历构建&lt;template&gt;标签内的标签节点。 API重点生命周期方法组件什么时候编译，什么时候生html元素，都是有规定的生命周期方法。控制生命周期方法可以方便的在某个地方调用某种功能 computed数据改变的时候调用的方法，方便的控制数据的变化 Vue之前装的packautoprefixer这个包是省去了写css的时候对特定的浏览器的写法，它可以自动填补上。 Postcss一个css插件系统,后期用插件处理的css处理器 具体可以看这个 https://segmentfault.com/a/1190000011595620 babel用来演示 vue-jsx 的操作","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"初次尝试Webpack构建前端","slug":"2018/first-webpack","date":"2018-04-20T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/first-webpack/","link":"","permalink":"https://summxu.github.io/2018/first-webpack/","excerpt":"","text":"最近一直研究前端工程化和更高效的构建工具，网上很多人都说Node.js能帮助前端开发，今天终于了解了一下，原有的js,jquery,css,html都是基础，想要做出完整的前端页面还是很复杂，而且文件也比较多。初次接触了下Webpack，这真的是前端离不开的工程构建工具. 首先在用这些东西之前最好是了解以下: css基础 JavaScript基础 ES6 css预处理器(less,sass,stulus) 对象编程逻辑 什么是Webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack就是把网页资源文件打包成一个js,在此之前你编程上可以用多种语言和多种工具,高效开发.在运行上网页速度加载也很快,减少了大量的http请求. webpack有极高的配置度和丰富的插件,loader以及webhttp调试. Webpack 安装环境 在这之前要说下 Node.js 和 NPM Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 NPM npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。 NPM包管理工具异常强大,他可以把很多个包的东西都关联起来.我们搭建本次webpack使用了以下的各种包: “cross-env”: “^5.1.4”, “css-loader”: “^0.28.11”, “file-loader”: “^1.1.11”, “html-webpack-plugin”: “^3.2.0”, “style-loader”: “^0.21.0”, “stylus”: “^0.54.5”, “stylus-loader”: “^3.0.2”, “url-loader”: “^1.0.1”, “vue”: “^2.5.16”, “vue-loader”: “^14.2.2”, “vue-template-compiler”: “^2.5.16”, “webpack”: “^4.6.0”, “webpack-dev-server”: “^3.1.3” Webpack 在我们这里也是一种包 其安装方法如下: npm install webpack NPM package.json文件 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 其实就是一个json格式的包管理文件,以及这种命令操作配置,这个文件配置很灵活,我们也要经常添加各种配置. 以下是我的文件配置 : 12345678910111213141516171819202122232425262728293031&#123; \"name\": \"vuewebpacke\", \"version\": \"1.0.0\", \"description\": \"test\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"cross-env\": \"^5.1.4\", \"css-loader\": \"^0.28.11\", \"file-loader\": \"^1.1.11\", \"html-webpack-plugin\": \"^3.2.0\", \"style-loader\": \"^0.21.0\", \"stylus\": \"^0.54.5\", \"stylus-loader\": \"^3.0.2\", \"url-loader\": \"^1.0.1\", \"vue\": \"^2.5.16\", \"vue-loader\": \"^14.2.2\", \"vue-template-compiler\": \"^2.5.16\", \"webpack\": \"^4.6.0\", \"webpack-dev-server\": \"^3.1.3\" &#125;, \"devDependencies\": &#123; \"webpack-cli\": \"^2.0.14\" &#125;&#125; 这就是没有配置loader造成的对.vue文件不识别 Webpack 目录结构Webpack.config.js package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 这是默认文件,我们不必动这个 webpack.config.js这是webpack的配置文件,他是在运行的时候加载的一种文件格式,属于node.js的模块我们用了es6来编辑和配置这个文件里的各个参数和值,下面是文件内容,我们一一来解释: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//首先载入用的到的node.js库文件 const path = require(&apos;path&apos;) //path node.js 自带的模块用来生成出口文件const HTMLPlugin = require(&apos;html-webpack-plugin&apos;) //html-webpack-plugin 是生成html入口页面的插件const webpack = require(&apos;webpack&apos;)const isDev = process.env.NODE_ENV === &apos;development&apos;const config = &#123; target: &apos;web&apos;, entry: path.join(__dirname,&apos;src/index.js&apos;), //入口文件 output:&#123; filename: &apos;bundle.js&apos;, path: path.join(__dirname,&apos;dist&apos;) //__dirname是node.js全局变量,是文件目录 &#125;, //生成出口文件 module: &#123; rules: [ &#123; test: /\\.vue$/, //正则表达式 loader: &apos;vue-loader&apos; &#125;, &#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;, &#123; test: /\\.styl/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;stylus-loader&apos; ] &#125;, &#123; test: /\\.(gif|png|jpeg|jpg|svg)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 1024, //url-loader配置,图片小于1024使用base64编码 name: &apos;[name]-xu.[ext]&apos; //输出图片名字格式 &#125; &#125; ] &#125; ] &#125;, //各种loader声明方式 plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; NODE_ENV: isDev ? &apos;&quot;development&quot;&apos; : &apos;&quot;production&quot;&apos; &#125; &#125;), //动态指定打包模式development or production new HTMLPlugin() ] //插件数组,用到的插件都需要用new声明&#125;if (isDev) &#123; config.devtool = &apos;#cheap-module-eval-source-map&apos; config.devServer = &#123; port: 8000, host: &apos;0.0.0.0&apos;, overlay: &#123; errors: true, &#125;, hot: true &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config //配置加载对象化 在此贴上webpack更具体的用法 www.webpackjs.com/concepts 运行webpacknpm run build or dev 12&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;,&quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js&quot; 之后还要在继续看看 stylus,es6,vue","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"三天教你Apache CGI从入门到放弃","slug":"2018/apache-cgi-abandon","date":"2018-04-15T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/apache-cgi-abandon/","link":"","permalink":"https://summxu.github.io/2018/apache-cgi-abandon/","excerpt":"","text":"千万不要用被淘汰的技术产品！！千万不要用被淘汰的技术产品！！千万不要用被淘汰的技术产品！！ 为什么要抛弃麻烦！ 为什么CGI麻烦1.配置上CGI的apache配置倒是不太繁琐，但是绝对没有PHP来的更快，更兼容 2.格式上CGI的变成格式看上去就不太高效，不仅要让程序输出html格式的网页头还要在文件头部准确的定义CGI程序的打开位置，不过这都不是重点 3.重点是调试上CGI准确的来说，是用Apache为环境来输出出来，这样在调试的时候相当复杂，在本地环境调试好的程序放上去并不能直接运行， 还要调试各种各样的问题。加上Python的两个版本的不兼容，整个项目的编写会用80%的时间来进行调试。所以果断弃之。 下面http的接口调用部分还是用先进的PHP来完成把，Python只在固定时间内在后台抓抓数据就完事了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"https://summxu.github.io/tags/Python/"}],"author":"BoomXu"},{"title":"Apahce的CGI操作 - Python","slug":"2018/apache-cgi","date":"2018-04-12T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/apache-cgi/","link":"","permalink":"https://summxu.github.io/2018/apache-cgi/","excerpt":"","text":"最近在研究Podcast泛博客的订阅地址，在国内的几大Podcast平台基本都提供RSS订阅源地址，但还是有很多专辑没有被分享订阅地址出来，碰巧最近在研究Python，打算用Python做爬虫，分析出来各大节目的广播地址并生成订阅源头。如果用前台去调用后台接口大部分的方式都是用PHP和Apache的方法，为了不想再涉及到PHP，下面就用这种古老的CGI的方式来解决。 什么是 CGICGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI,可用任何语言编写CGI,包括流行的C、C ++、VB 和Delphi 等。CGI 分为标准CGI 和间接CGI两种。标准CGI 使用命令行参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI 又称缓冲CGI,在CGI 程序和CGI 接口之间插入一个缓冲程序，缓冲程序与CGI 接口间用标准输入输出进行通信。 怎么用Apache来调用指定CGI其实调用原理很简单,无非就是配置apache的cgi支持、设置cgi的运行目录和运行cgi的后缀 配置对CGI的支持LoadModule cgi_module modules/mod_cgi.so 定义CGI的目录12345678910111213ScriptAlias /cgi-bin/ &quot;/var/www/cgi-bin/&quot;## &quot;/var/www/cgi-bin&quot; should be changed to whatever your ScriptAliased# CGI directory exists, if you have that configured.#&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; Options Indexes FollowSymLinks MultiViews +ExecCGI AllowOverride None Options None Order allow,deny Allow from all&lt;/Directory&gt; 定义CGI支持的文件后缀AddHandler cgi-script .cgi .py .sh 编写Python脚本的CGI1234567891011#!/usr/bin/env python# -*- coding: UTF-8 -*-import cgiimport cgitbprint &quot;Content-type:text/html&quot;printform = cgi.FieldStorage()name = form.getvalue(&apos;name&apos;)print name 这里要注意的是 apache 调用cgi的时候必须要输出的这一句 ： 12print &quot;Content-type:text/html&quot;print 这个应该是固定格式，具体的原因的话没再深入研究","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"https://summxu.github.io/tags/Python/"}],"author":"BoomXu"},{"title":"博客大改之Ajax、Cookie、PHP","slug":"2018/ajax-cookie-php","date":"2018-03-24T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/ajax-cookie-php/","link":"","permalink":"https://summxu.github.io/2018/ajax-cookie-php/","excerpt":"","text":"最近一个星期内，我一直在修改我的博客，直到今天，才算是基本完型。中间修改了很多地方，也学到了很多东西，在这篇博客里就一起回顾下这次博客修改遇到的各种问题吧！ 因为中间隔得天数实在是太多，我也没有时间当时就去整理一番，现在再总结的话，中间肯定会有很多遗漏的地方， 所以说以后每天遇到的新的技术问题一定要及时记录下来。 Jekyll在一开始我先根据Jekyll的内部功能来添加日记，其中主要运用了Jekyll的文章分类功能 categories 我一直以为Jekyll 没有这种功能， 而且在网上查找资料都说得要这么实现很复杂，还有说要修改Jekyll的gem文章遍历的插件，其实并没有这么复杂，只需在文章头部添加文章标签就行了，关于Jekyll 的更多用法，以下这篇博客已经说得很完美了。 http://ju.outofmemory.cn/entry/149459 Cookie我使用了Jquery的cookie插件，其使用方法很简单，试用cookie的原因主要是不用每篇日记或者说是每次打开的时候都会进行密码验证。一开始想的是直接把密码从服务端取出来然后在本地判断，这样还省去了每次都向服务器端发送局的麻烦。但是这样行不通，因为密码一旦做本地判断，就不安全。 1.写入Cookie1234567891011$.cookie(&quot;写入的cookie名&quot;,&quot;写入的cookie值&quot;,&#123;expires:7, //含义：有效期，单位：天，可写值：数字、日期对象，默认：如果不写或写null则浏览器关闭后cookie删除path:&quot;/&quot;, //路径，默认是创建该cookie的页面路径domain:&quot;地址&quot;, //域名属性，默认是创建该cookie的页面域名secure:true //如果为true，那么此cookie的传输会要求一个安全协议，例如https&#125;); 2.读取cookiejQuery的读取cookie很简单： $.cookie(&quot;读取的cookie名&quot;) 3.删除cookie写法：$.cookie(&quot;删除的cookie名&quot;,null) //参数null：代表删除此cookie cookie一开始一直有一个问题，就是每一页的验证好像都是一个cookie，找到资料发现是因为没有配置 path 如果要想全站cookie，只要加上 path:”/“ 就好了。下面再继续说下Ajax。 Ajax其实在开始研究学习ajax之前，我感觉这是一种很麻烦动东西，但是仔细研究发现ajax并不是这么难，只是有时候会出现莫名其妙的问题。看看代码和写法： 1234567891011121314151617$.ajax(&#123; type: \"GET\", url: \"http://192.168.1.112/check.php\", data: &#123;pass : $(\"#pass\").val()&#125;, //发送出去的数据 dataType : \"json\", //返回的数据格式 async : false, //同步请求 success: function (data) &#123; if(data.status == 1)&#123; alert(data.status); &#125;else&#123; alert(data.status); &#125; &#125;, // 成功后之执行 error: function()&#123; alert('产生了莫名其妙的错误！'); &#125; // 失败后执行 &#125;); ajax普通的传递,这几个参数还是很 简单的。第一个遇到的问题就是： 2018.8.28 回来看到之前的这个博客那时候的技术还是太浅了， 当时只涉及到jQuery的ajax封装函数，还不知道JavaScript的ajax的请求过程。现在想想，ajax就是创建一个xmlhttprequest对象，再使用open建立连接，然后发送请求直至接受请求。这时可能涉及到请求过程中的4种状态码： 0：初始化，XMLHttpRequest对象还没有完成初始化1：载入，XMLHttpRequest对象开始发送请求2：载入完成，XMLHttpRequest对象的请求发送完成3：解析，XMLHttpRequest对象开始读取服务器的响应4：完成，XMLHttpRequest对象读取服务器响应结束 1234var xhr = new XMLHtttpRequest ()xhr.open(&apos;GET&apos;,&apos;./data.json&apos;,true)xhr.send()xhr.load()&#123;&#125; 跨域请求问题 本地测试是可以正常传输，但是Github上是不支持任何服务器可执行的脚本的，所以我必须用另一个可执行后台的服务器来进行密码验证，这样就要涉及到跨域请求。我在网络上收集了各种解决方法，其中有用 jasonp、加header头 还有各种很复杂的方法，但是在这其中header头是最简单的。只需要在后台PHP里加上这么一句：header(&#39;Access-Control-Allow-Origin:*&#39;); 异步请求问题 ajax中有一个参数就是 async : false 就是是否异步请求，默认是异步的，这个意思就是 ajax运行的时候能同时运行其他的东西 就像是多线程一样 但是在实际用的时候，我发现跨域用异步请求的话会很大几率出现请求不成功的情况，我不知道是为什么。 PHP后台接口PHP我之前尝试着做过，但是一直没有怎么学，也没有实际的项目能用上php，现在可以了，我完全可以用PHP做一个后端判断的接口。PHP代码很简单，但是有这么两点注意的地方： 1.做接口一定要加上 `error_reporting(E_ERROR);`我之前见过别人的接口就是加上了这个，这句话的意思是不让PHP输出错误提示，有时候输出来错误提示返回出来的数据就不是标准的格式了。 2.就是跨域请求的header头。123456789101112131415161718&lt;?php // /*验密码码是否正确*/ error_reporting(E_ERROR); header(&apos;Access-Control-Allow-Origin:*&apos;); $code = trim($_GET[&apos;pass&apos;]);//接收前端传来的数据 $raw_success = array(&apos;status&apos; =&gt; 1 , &apos;word&apos; =&gt; $code); $res_success = json_encode($raw_success); $raw_fail = array(&apos;status&apos; =&gt; 0); $res_fail = json_encode($raw_fail); if ($code == &quot;想什么呢&quot;) &#123; echo $res_success; &#125; else &#123; echo $res_fail; &#125;?&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"初入股市新体验-开户和第一股","slug":"2018/stock-first","date":"2018-03-14T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2018/stock-first/","link":"","permalink":"https://summxu.github.io/2018/stock-first/","excerpt":"","text":"时隔一段时间，遇到了很多事没记录，中间沉迷游戏 。现在转眼到了大三下学期，却还没有拿到证书什么的。我打算开始学习，但是在此期间，我想去学习金融，也就是从股市开始。。 2018年3月12日 成功在《中泰证券》开户2018年3月13日 存入5700元 并购买了以下两股 002012 凯恩股份 7.98 买入 400股 000806 银河生物 8.20 买入 300股 2018年3月14日 7.69 卖出银河生物 亏损1552018年3月15日 1.89 卖出凯恩股份 亏损50 随即买入 601996 丰林集团目前亏损23 其中 银河生物 丰林集团 都是高价卖了然后跌，凯恩股份是平价买的，然后跌了就卖了，然后又涨上来了。 我认为在我操作中还存在许多问题： 1、分时买的时候找不到最低点 2、分时卖的时候找不到最高点，不知道是否还会反弹。 3、没有良好的心里准备，盲目购买不过最近我也在看视频或者知乎大神的方法的时候了解了些知识： 看分时最高点： 在走势第一波冲高的时候不要着急，等回落后看第二波冲高，如果第一波冲高的量和第二波的量差距不大，那么很有可能会有第三波冲高。如果说第一波冲高的量明显大于第二波的量，那么则很有可能高点诞生。 下跌反弹： 看了吴浅的股票乐园，他说下跌分为急跌和缓跌两种，缓跌一定要出局，急跌瞬间拉起来就可以再等等看。 总的来说最为一个新手我还什么都不知道 但是下一个要学习的技术是要设置止损位 。 2018年3月15日17点00分","categories":[],"tags":[{"name":"生活分享","slug":"生活分享","permalink":"https://summxu.github.io/tags/生活分享/"}],"author":"BoomXu"},{"title":"西游记中有什么可悲的细节？","slug":"2017/xiyouji-kebei","date":"2017-06-30T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2017/xiyouji-kebei/","link":"","permalink":"https://summxu.github.io/2017/xiyouji-kebei/","excerpt":"","text":"最可悲，最让人心酸的莫过于黄狮精。 要说西游记里最善良最老实的妖怪是谁，莫过于黄狮精和他手下的小妖。 孙悟空去追查兵器时遇到黄狮精手下的两个狼头怪，他们在说什么呢？ “我们也有些侥幸。拿这二十两银子买猪羊去，如今到了前方集上，先吃几壶酒儿，把东 西开个花帐儿，落他二三两银子，买件绵衣过寒，却不是好？”两个怪说说笑笑的，上大路急走如飞。 能吃上几壶，还能买上件棉衣以后冬天不用挨冻就能让他们欣喜的有说有笑，高兴的都快飞起来。这样老实本分的苦逼日子，是那些动不动捉个人来吃的妖怪能想象的吗？ 孙悟空定住了两个小妖，取走了带给他俩无限欣喜的二十两银子，跟猪八戒变作小妖模样，让沙僧化妆成卖猪羊的，跟他们回去给黄狮精说，还欠他五两银子。 妖王听说，即唤：“小的们，取五两银子，打发他去。” 换成别的妖精，早就一口把他吞了，还想要银子？但黄狮精立马就给，连个价都不还，老实巴交到这种程度。 然后孙悟空说猪羊贩子要看那几件兵器，黄狮精做贼心虚，怕玉华州王子”一时来访求”，自己说不过去，不敢让看。但经不住孙悟空劝，他还是答应让看了。 看到这里，86 版西游记编剧都看不下去了。要是按原著中拍出来，这妖怪也太本分好说话了吧，这样一个妖怪被孙悟空打死并分尸，也太损孙悟空除暴安良的形象了。于是改成了，以白送鸭子作为交换条件来看兵器。 可实际上不仅银子照给，还白管一顿酒饭。 说不了，有一小妖，取了五两银子，递与行 者。行者将银子递与沙僧道：“客人，收了银子，我与你进后面去吃些饭来。” 黄狮精只是嘱咐 那怪王随后跟着道：“客人，那中间放光亮的就是钉钯。你看便看，只是出 去，千万莫与人说。” 换了别的妖怪早杀了灭口了吧。 偷了三件兵器是犯了盗窃罪，关上三五年也就差不多了，十年也就顶天了吧。可是终身监禁孙悟空都不愿意，杀了黄狮精，还灭了他满门，并且把黄狮精分尸吃了。 辛辛苦苦赚来的家当，就这样被孙悟空烧了，全家的老小被灭了。吴承恩对黄狮精的悲痛毫不吝啬笔墨。 那妖精闻言，止不住泪如泉涌，双脚齐跌，喊声振天，恨道：“那秃厮！十分作恶！怎 么干出这般毒事，把我洞府烧尽，美人烧死，家当老小一空！气杀我也，气杀我也！” 1 在灭顶的打击之下，黄狮精崩溃了，甚至都不想去报仇，只想撞墙自杀。 “老爷！我那们个山场，非一日治的，今被这秃厮尽毁，我却要此命做甚的！”挣起来，往石崖上撞头磕脑，被雪狮、猱 狮等苦劝方止。 一个不肯伤天害理，老实本分，买卖公平，与人为善的黄狮精老小被灭了，自己被杀，然后尸体被分吃了。 那个吃了一城人的大鹏，作了如来的护法。 金鱼精每年吃一对童男童女，村民们还大拜金鱼精的主人。 黄袍怪吃人随便，只被罚俸几天。 蜈蚣精毒翻多少路人，作了护法大神。 这就是名著，不像三流小说一样，主角不是高大上做什么都是正义的，主角的对手也不一定是该死的坏人，最后恶人也不一定得恶报，真实地描绘了这个复杂的世界。 转自知乎 待我施为地煞变的回答：https://www.zhihu.com/question/51682490","categories":[],"tags":[{"name":"文学分享","slug":"文学分享","permalink":"https://summxu.github.io/tags/文学分享/"}],"author":"BoomXu"},{"title":"优雅的使用Email和Rss以便让生活井井有序","slug":"2017/email-rss-xiantan","date":"2017-06-27T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/email-rss-xiantan/","link":"","permalink":"https://summxu.github.io/2017/email-rss-xiantan/","excerpt":"","text":"高逼格的生活方式依然不能离开Email. 有质量的内容依然会用Rss订阅. Email邮件几户贯穿整个互联网史的发展，直到现在一些很正式的场合依然用Email来通信，各种企业之间的商务交流等等。 但是随着互联网的发展很快就有了各种产品来替代Email,比如IM即时通信的流行各种各样的聊天软件。 Email在中国可以说不太流行，唯一能让所有人都拥有一个邮箱的估计还是QQ邮箱，要不是腾讯，或许大部分的人都不会去注册一个邮箱。不过如果你要是觉得Email只能和朋友和一些陌生的人发些邮件来通信，那你就OUT了。Email的功能远不止如此。 这里我说说Email的各种用法或许会让我们方便不少。 客户端和服务商Email是要有客户端的支持(现在的邮件服务商都提供了网页版)，无论你用的哪家的Email服务，都可以用各种客户端去同步你的邮件。现在基本的的邮件服务有很多家，其中比较常见的： QQ邮箱 QQ邮箱是腾讯公司在2002年推出的邮箱服务。2005年3月，腾讯收购Foxmail，张小龙及研发团队20余人不久后进入腾讯。 虽然QQ的邮箱域显得不太正式，但是不的不说QQ邮箱是让我们大部分人拥有的第一个邮箱。 网易邮箱 网易的邮箱有：163、126和yeah.net 目前是国内的主流邮箱服务之一。在国内非常流行也是国内邮箱的首选品牌。目前官方宣称用户总数突破5亿。 我没用过网易的邮箱，感觉广告太多了。 雅虎邮箱 雅虎邮箱是世界邮箱服务商之一，规模非常大，于1997年10月8日激活。不过好像是不对国内用户开放，或者之前开放过后来停了。 Outlook Outlook是非常老牌的邮箱服务商了，他有自己的邮件客户端，界面也比较简洁功能也很多。国内也可以用。 Gmail 自我感觉是最好用的邮箱，但是因为谷歌推出了中国市场导致其所有服务全部不能用。所以，没有什么办法。无奈之下只好暂时放弃 无论是在Android、IOS、windows上都支持邮件也有自带的邮件客户端。 介绍了几大服务商，下面说说功能。 邮件服务电子邮件是整个网络间以至所有其他网络系统中直接面向人与人之间信息交流的系统，它的数据发送方和接收方都是人，所以极大地满足了大量存在的人与人之间的通信需求。 电子邮件指用电子手段传送信件、单据、资料等信息的通信方法。电子邮件综合了电话通信和邮政信件的特点，它传送信息的速度和电话一样快，又能像信件一样使收信者在接收端收到文字记录。电子邮件系统又称基于计算机的邮件报文系统。它参与了从邮件进入系统到邮件到达目的地为止的全部处理过程。电子邮件不仅可利用电话网络，而且可利用其它任何通信网传送。在利用电话网络时,还可在其非高峰期间传送信息，这对于商业邮件具有特殊价值。由中央计算机和小型计算机控制的面向有限用户的电子系统可以看作是一种计算机会议系统。电子邮件采用储存-转发方式在网络上逐步传递信息，不像电话那样直接、及时，但费用低廉。 联系人同步这是我认为除了发邮件最重要的一个功能了，也特别好用。 这可以解决你的很多问题： 换手机了联系人还要导入到SIM卡里在导出来？ 在电脑上不能查看自己的联系人？ 有了未接来电信息不能多端同步？ 邮箱可以给你解决这些问题。 你只需要在手机上登录上邮箱账户，添加联系人时选择添加到邮箱账户即可，也可以把联系人导出成CVS格式的信息导入到邮箱里，以上介绍的各大邮箱服务商都支持联系人导入。 手机上： 图片1 电脑上： img2 日历同步邮箱可以同步你的日历，无论是在电脑上还是手机上，你的日程安排都可以实时的同步起来，并且还能很多设备都同步提醒。 手机上： IMG6 电脑上： img8 除此之外，你还能去订阅一些天气日历节假日，在OUTLOOK上还能看到一些有趣的日历订阅。 img3 img4 更多功能可以看到，以OUTLOOK为例还有很多可以同步的功能： img9 邮箱的便捷性不止于发邮件，希望这些能让我们的生活习惯更好。 Rss什么是Rss RSS是在线共享内容的一种简易方式（也叫聚合内容，全称Really Simple Syndication）。使用RSS订阅能更快地速获取信息和获取网站内容的最新更新。更直白的说，你可以不用再一一打开各个网站页面，而是通过阅读器一次一起阅读所有你订阅了的网站的最新内容。 订阅RSS有什么优点？ 加载速度快，一次阅读所有订阅的网站； 阅读器阅读通常都非常简洁，网站上的广告等都不会有； 不受功夫网的影响，能够继续通过RSS订阅阅读最新文章； 及时更新，若源网站有发表新文章，马上就可以阅读到； 全部信息都能在RSS阅读器内读完，不再需要一个一个地刷新各个网站页面。 如何订阅RSS？ 使用RSS阅读器 主要有在线阅读器和离线阅读器两种。弥缝没用过离线阅读器，所以这儿就不做推荐，而且弥缝推荐使用更加方便的在线阅读器，比如说Google Reader、抓虾、鲜果、QQ阅读、有道阅读、豆瓣九点和一些个性化主页（Netvibes）等等。 在线阅读的好处在于你可以在任何地方（使用手机/电脑等）通过登录帐号来阅读你订阅的信息，而离线阅读器是不行的。 如果你比较偏好Google可以使用Google Reader，只需使用你的Gmail帐号登录即可。 使用Email 可以通过Email服务商来在线订阅Rss，如果有更新会通过邮件的方式发给你。现在基本的邮件服务商都支持填写Rss订阅地址。 订阅BoomXu本博客的订阅地址 https://www.BoomXu.com/feed.xml 或者可以点击网站下下方的订阅按钮来获取Rss地址： 推荐的订阅源知乎每日精选（强烈推荐） 知乎日报（非常宝贵的源） nhzy资讯（健康生活） 果壳网（科普生活） 科学松鼠会（科普） 科学公园（分析各种误区） 泛科学（台湾的科普资讯） Matrix67（数学爱好者） 战隼的学习探索（效率生活） 更多的源可以去仔细看这篇回答：你必读的 RSS 订阅源有哪些？ END老套的东西并不是没有用的，需要你用一双发现美的眼睛去欣赏它，或许他会使你的生活更加美好。科技如此，其他更是如此。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"Linux下Shell学习 --基础1","slug":"2017/linux-shell-1","date":"2017-06-26T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/linux-shell-1/","link":"","permalink":"https://summxu.github.io/2017/linux-shell-1/","excerpt":"","text":"今天学习下Shell,发现非常简单，语法也很是随意，在此记录下学习过程。 Shell介绍Shell和Shell脚本Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。 Shell 环境Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） …… 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。 #! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 Hello world12#!/bin/bashecho &quot;Hello world&quot; 变量及数组12345678910111213141516171819202122#!/bin/bashonly=&quot;我是只读变量&quot;readonly only#only=&quot;我不是只读变量&quot;del=&quot;我被删除了&quot;unset dela=&apos;陈旭&apos;str=&quot;hello,$&#123;a&#125;&quot;array=(陈旭 神还套 梁航宇)echo &quot;ni hao a wo shi $a heihei &quot;echo $onlyecho $delecho $strecho &quot;字符串长度为：$&#123;#str&#125;&quot;echo &quot;提取字符串陈旭：$&#123;str:6:4&#125;&quot;echo $array $&#123;array[1]&#125; $&#123;array[2]&#125;echo &quot;数组长度是：$&#123;#array[*]&#125;&quot;echo &quot;数组所有元素：$&#123;array[*]&#125;&quot; 参数传递123456789101112#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;echo &quot;参数个数 $#&quot;echo &quot;参数字符串 $*&quot;echo &quot;运行ID号 $$&quot; 运算符表达式12345678910111213141516#!/bin/basha=10b=22add=`expr $a + $b`quyu=`expr $b % $a`cheng=`expr $a \\* $b`echo &quot;A+B=：$add&quot;echo &quot;取余：$quyu&quot;echo &quot;A乘B：$cheng&quot;if [ $a == $b ]thenecho &quot;A大于B&quot;fiecho &quot;B大于A&quot; 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://summxu.github.io/tags/Shell/"}],"author":"BoomXu"},{"title":"Linux下Shell学习 --基础2","slug":"2017/linux-shell-2","date":"2017-06-26T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/linux-shell-2/","link":"","permalink":"https://summxu.github.io/2017/linux-shell-2/","excerpt":"","text":"今天学习下Shell,发现非常简单，语法也很是随意，在此记录下学习过程。 echoecho 命令也很简单，在这里记下几个不常用到的。 显示命令执行结果1echo `date` 显示不换行123#!/bin/shecho -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行echo &quot;It is a test&quot; 显示换行12echo -e &quot;OK! \\n&quot; # -e 开启转义echo &quot;It it a test&quot; test文件测试 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 分支语法12345678910#!/bin/bashnum1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;两个数字相等!&apos;else echo &apos;两个数字不相等!&apos;fi 循环语法Shell的循环方式比较多，一开始不太好用， 我选择了基本和C语言方法相同的语法，现在理解是基本用法都差不多。 C语言方式123456789101112131415161718192021#!/bin/bashnum1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;两个数字相等!&apos;else echo &apos;两个数字不相等!&apos;fiecho `expr 100 % 3`#100以内可以被3整除for ((i=1;i&lt;100;i++))doif [ `expr $i % 3` == 0 ]thenecho $ifidone for in1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 例子： 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done while 语句1234while conditiondo commanddone case123456789101112131415echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in 1) echo &apos;你选择了 1&apos; ;; 2) echo &apos;你选择了 2&apos; ;; 3) echo &apos;你选择了 3&apos; ;; 4) echo &apos;你选择了 4&apos; ;; *) echo &apos;你没有输入 1 到 4 之间的数字&apos; ;;esac 跳出循环break命令break命令允许跳出所有循环（终止执行后面的所有循环）。下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。 12345678910111213#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone continuecontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。对上面的例子进行修改： 1234567891011121314#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; ;; esacdone 函数12345678910111213#!/bin/bashfunWithReturn()&#123; echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 函数参数123456789101112#!/bin/bashfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 求素数DEMO12345678910111213141516171819#!/bin/bash#求100以内的所有素数for((i=2;i&lt;100;i++))do k=1 for((j=2;j&lt;i;j++)) do if((`expr $i % $j` == 0)) then k=0 break fi done if [ $k == 1 ] then echo $i fidone","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://summxu.github.io/tags/Shell/"}],"author":"BoomXu"},{"title":"Linxu下安装Node.js","slug":"2017/nodejs-install-linux","date":"2017-06-25T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/nodejs-install-linux/","link":"","permalink":"https://summxu.github.io/2017/nodejs-install-linux/","excerpt":"","text":"系统环境：Ubuntu 32位 下载Node.js首先去官网复制下Node.js的Source Code包地址 1 然后用 weget 来下载编译包。 2 安装Node.js先解压包 12tar -xf node-v6.11.0.tar.gzcd node-v6.11.0 配置并编译 12./configuremake 5 安装 1sudo make install 检查安装12node -vnpm -v 7 创建nodejs项目目录 mkdir -p /usr/local/nodejs/ 创建hello.js文件 vi /usr/local/nodejs/hello.js 内容如下： 123456789var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123; \"Content-Type\" : \"text/plain\" // 输出类型 &#125;); response.write(\"Hello BoomXu\");// 页面输出 response.end();&#125;).listen(8100); // 监听端口号console.log(\"nodejs start listen 8100 port!\"); 开启nodejs服务 node hello.js 8 浏览器访问 http://127.0.0.1:8100/ 6","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"Linux下C语言实现Socket通信","slug":"2017/linux-socket-c","date":"2017-06-24T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/linux-socket-c/","link":"","permalink":"https://summxu.github.io/2017/linux-socket-c/","excerpt":"","text":"网络协议与分析让做一个利用Socket(套接字)来实现双方的即时通信功能，参考网络的源代码和介绍并实现Linux下的C语言编程。 1、网络中进程之间如何通信？ 2、Socket是什么？ 3、socket的基本操作 3.1、socket()函数 3.2、bind()函数 3.3、listen()、connect()函数 3.4、accept()函数 3.5、read()、write()函数等 3.6、close()函数 4、socket中TCP的三次握手建立连接详解 5、socket中TCP的四次握手释放连接详解 6、代码实现 7、运行结果 1、网络中进程之间如何通信？本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类： 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris门和Sun RPC） 但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。 2、Socket是什么？上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。 在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。” 3、socket的基本操作既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。 3.1、socket()函数 int socket(int domain, int type, int protocol);socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。 正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为： domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。 protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。 3.2、bind()函数正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 函数的三个参数分别为： sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。 addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。 addrlen：对应的是地址的长度。 通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。 主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下： a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。 所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。 3.3、listen()、connect()函数如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。 int listen(int sockfd, int backlog); int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。 connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。 3.4、accept()函数TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。 注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。 3.5、read()、write()函数等万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组： read()/write() recv()/send() readv()/writev() recvmsg()/sendmsg() recvfrom()/sendto() read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。 write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。 其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。 3.6、close()函数在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。 #include &lt;unistd.h&gt; int close(int fd); close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。 注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 4、socket中TCP的三次握手建立连接详解我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下： 客户端向服务器发送一个SYN J 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1 客户端再想服务器发一个确认ACK K+1 只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图： 1 从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。 总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。 5、socket中TCP的四次握手释放连接详解上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图： 图示过程如下： 2 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M； 另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N； 接收到这个FIN的源发送端TCP对它进行确认。 这样每个方向上都有一个FIN和ACK。 6、代码实现服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;strings.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;memory.h&gt;#include &lt;unistd.h&gt;//#include &lt;linux/in.h&gt;#include &lt;netinet/in.h&gt;//#include &lt;linux/inet_diag.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#define PORT 11910 //定义通信端口#define BACKLOG 5 //定义侦听队列长度#define buflen 1024void process_conn_server(int s);void sig_pipe(int signo);int ss,sc; //ss为服务器socket描述符，sc为某一客户端通信socket描述符int main(int argc,char *argv[])&#123; struct sockaddr_in server_addr; //存储服务器端socket地址结构 struct sockaddr_in client_addr; //存储客户端 socket地址结构 int err; //返回值 pid_t pid; //分叉进行的ID /*****************socket()***************/ ss = socket(AF_INET,SOCK_STREAM,0); //建立一个序列化的，可靠的，双向连接的的字节流 if(ss&lt;0) &#123; printf(&quot;server : server socket create error\\n&quot;); return -1; &#125; //注册信号 sighandler_t ret; ret = signal(SIGTSTP,sig_pipe); if(SIG_ERR == ret) &#123; printf(&quot;信号挂接失败\\n&quot;); return -1; &#125; else printf(&quot;信号挂接成功\\n&quot;); /******************bind()****************/ //初始化地址结构 memset(&amp;server_addr,0,sizeof(server_addr)); server_addr.sin_family = AF_INET; //协议族 server_addr.sin_addr.s_addr = htonl(INADDR_ANY); //本地地址 server_addr.sin_port = htons(PORT); err = bind(ss,(struct sockaddr *)&amp;server_addr,sizeof(sockaddr)); if(err&lt;0) &#123; printf(&quot;server : bind error\\n&quot;); return -1; &#125; /*****************listen()***************/ err = listen(ss,BACKLOG); //设置监听的队列大小 if(err &lt; 0) &#123; printf(&quot;server : listen error\\n&quot;); return -1; &#125; /****************accept()***************/ /** 为类方便处理，我们使用两个进程分别管理两个处理： 1，服务器监听新的连接请求;2,以建立连接的C/S实现通信 这两个任务分别放在两个进程中处理，为了防止失误操作 在一个进程中关闭 侦听套接字描述符 另一进程中关闭 客户端连接套接字描述符。注只有当所有套接字全都关闭时 当前连接才能关闭，fork调用的时候父进程与子进程有相同的 套接字，总共两套，两套都关闭掉才能关闭这个套接字 */ for(;;) &#123; socklen_t addrlen = sizeof(client_addr); //accept返回客户端套接字描述符 sc = accept(ss,(struct sockaddr *)&amp;client_addr,&amp;addrlen); //注，此处为了获取返回值使用 指针做参数 if(sc &lt; 0) //出错 &#123; continue; //结束此次循环 &#125; else &#123; printf(&quot;server : connected\\n&quot;); &#125; //创建一个子线程，用于与客户端通信 pid = fork(); //fork 调用说明：子进程返回 0 ；父进程返回子进程 ID if(pid == 0) //子进程，与客户端通信 &#123; close(ss); process_conn_server(sc); &#125; else &#123; close(sc); &#125; &#125;&#125;/** 服务器对客户端连接处理过程；先读取从客户端发送来的数据， 然后将接收到的数据的字节的个数发送到客户端 *///通过套接字 s 与客户端进行通信void process_conn_server(int s)&#123; ssize_t size = 0; char buffer[buflen]; //定义数据缓冲区 for(;;) &#123; //等待读 for(size = 0;size == 0 ;size = read(s,buffer,buflen)); //输出从客户端接收到的数据 printf(&quot;%s&quot;,buffer); //结束处理 if(strcmp(buffer,&quot;quit&quot;) == 0) &#123; close(s); //成功返回0，失败返回-1 return ; &#125; sprintf(buffer,&quot;%d bytes altogether\\n&quot;,size); write(s,buffer,strlen(buffer)+1); &#125;&#125;void sig_pipe(int signo)&#123; printf(&quot;catch a signal\\n&quot;); if(signo == SIGTSTP) &#123; printf(&quot;接收到 SIGTSTP 信号\\n&quot;); int ret1 = close(ss); int ret2 = close(sc); int ret = ret1&gt;ret2?ret1:ret2; if(ret == 0) printf(&quot;成功 : 关闭套接字\\n&quot;); else if(ret ==-1 ) printf(&quot;失败 : 未关闭套接字\\n&quot;); exit(1); &#125;&#125; 客户端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;stdio.h&gt;#include &lt;strings.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;//#include &lt;linux/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;signal.h&gt; //添加信号处理 防止向已断开的连接通信/** 信号处理顺序说明：在Linux操作系统中某些状况发生时，系统会向相关进程发送信号， 信号处理方式是：1，系统首先调用用户在进程中注册的函数，2，然后调用系统的默认 响应方式,此处我们可以注册自己的信号处理函数，在连接断开时执行 */#define PORT 11910#define Buflen 1024void process_conn_client(int s);void sig_pipe(int signo); //用户注册的信号函数,接收的是信号值int s; //全局变量 ， 存储套接字描述符int main(int argc,char *argv[])&#123; sockaddr_in server_addr; int err; sighandler_t ret; char server_ip[50] = &quot;&quot;; /********************socket()*********************/ s= socket(AF_INET,SOCK_STREAM,0); if(s&lt;0) &#123; printf(&quot;client : create socket error\\n&quot;); return 1; &#125; //信号处理函数 SIGINT 是当用户按一个 Ctrl-C 建时发送的信号 ret = signal(SIGTSTP,sig_pipe); if(SIG_ERR == ret) &#123; printf(&quot;信号挂接失败\\n&quot;); return -1; &#125; else printf(&quot;信号挂接成功\\n&quot;) ; /*******************connect()*********************/ //设置服务器地址结构，准备连接到服务器 memset(&amp;server_addr,0,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); server_addr.sin_addr.s_addr = htonl(INADDR_ANY); /*将用户数入对额字符串类型的IP格式转化为整型数据*/ //inet_pton(AF_INET,argv[1],&amp;server_addr.sin_addr.s_addr); printf(&quot;please input server ip address : \\n&quot;); read(0,server_ip,50); //err = inet_pton(AF_INET,server_ip,&amp;server_addr.sin_addr.s_addr); server_addr.sin_addr.s_addr = inet_addr(server_ip); err = connect(s,(struct sockaddr *)&amp;server_addr,sizeof(sockaddr)); if(err == 0) &#123; printf(&quot;client : connect to server\\n&quot;); &#125; else &#123; printf(&quot;client : connect error\\n&quot;); return -1; &#125; //与服务器端进行通信 process_conn_client(s); close(s);&#125;void process_conn_client(int s)&#123; ssize_t size = 0; char buffer[Buflen]; for(;;) &#123; memset(buffer,&apos;\\0&apos;,Buflen); /*从标准输入中读取数据放到缓冲区buffer中*/ size = read(0,buffer,Buflen); // 0，被默认的分配到标准输入 1，标准输出 2，error if(size &gt; 0) &#123; //当向服务器发送 “quit” 命令时，服务器首先断开连接 write(s,buffer,strlen(buffer)+1); //向服务器端写 //等待读取到数据 for(size = 0 ; size == 0 ; size = read(s,buffer,Buflen) ); write(1,buffer,strlen(buffer)+1); //向标准输出写 &#125; &#125;&#125;void sig_pipe(int signo) //传入套接字描述符&#123; printf(&quot;Catch a signal\\n&quot;); if(signo == SIGTSTP) &#123; printf(&quot;接收到 SIGTSTP 信号\\n&quot;); int ret = close(s); if(ret == 0) printf(&quot;成功 : 关闭套接字\\n&quot;); else if(ret ==-1 ) printf(&quot;失败 : 未关闭套接字\\n&quot;); exit(1); &#125;&#125; 运行结果 21 22","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"C语言","slug":"C语言","permalink":"https://summxu.github.io/tags/C语言/"}],"author":"BoomXu"},{"title":"通过CSS添加网页的动画效果","slug":"2017/add-css-effect","date":"2017-06-16T06:03:56.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/add-css-effect/","link":"","permalink":"https://summxu.github.io/2017/add-css-effect/","excerpt":"","text":"昨天写了通过jQuery添加网页的动画效果来美化了一下博客，发现jQuery的动画效果卡出翔，别说美观了，用户体验都没保证，今天更新下用CSS添加网页特效，顺便记录下自己的CSS的学习；。 在网上查阅相关CSS动画特效的资料，发现了一个CSS样式库：Aninmate.css这次主要是对这个样式库进行介绍，里面有很多好看的动画样式。 Aninmate.css这里有个Aninmate样式的各个效果预览：点我查看 我打包了Aninmate.css的引入文件几Demo：在此下载 简介animate.css 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果 ，几乎包含了所有常见的动画效果。 虽然借助 animate.css 能够很方便、快速的制作 CSS3 动画效果，但还是 建议看看 animate.css 的代码，也许你能从中学到一些东西。 兼容浏览器兼容：当然是只兼容支持 CSS3 animate 属性的浏览器，他们分别是：IE10+、Firefox、Chrome、Opera、Safari。 使用方法 当然首先要引入样式文件 1&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.min.css&quot;&gt; HTML 及使用 1&lt;div class=&quot;animated bounce&quot; id=&quot;dowebok&quot;&gt;&lt;/div&gt; 给元素加上 class 后，刷新页面，就能看到动画效果了。animated 类似于全局变量，它定义了动画的持续时间；bounce 是动画具体的动画效果的名称，你可以选择任意的效果。 如果动画是无限播放的，可以添加 class infinite。 你也可以通过 JavaScript 或 jQuery 给元素添加这些 class，比如： 123$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;);&#125;); 有些动画效果最后会让元素不可见，比如淡出、向左滑动等等，可能你又需要将 class 删除，比如： 123456$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;); setTimeout(function()&#123; $(&apos;#dowebok&apos;).removeClass(&apos;bounce&apos;); &#125;, 1000);&#125;); animate.css 的默认设置也许有些时候并不是我们想要的，所以你可以重新设置，比如： 12345#dowebok &#123; animate-duration: 2s; //动画持续时间 animate-delay: 1s; //动画延迟时间 animate-iteration-count: 2; //动画执行次数&#125; Github地址 https://github.com/daneden/animate.css 我的引用代码本次引用了两个页面，一个文章Post页，一个是博客首页： post页： 123&lt;a class=&quot;tag animated bounceInDown&quot; href=&quot;&#123; &#123; site.baseurl &#125; &#125;/tags/#&#123; &#123; tag &#125; &#125;&quot; title=&quot;&#123; &#123; tag &#125; &#125;&quot;&gt;&#123; &#123; tag &#125; &#125;&lt;/a&gt;&lt;h1 class=&quot;animated rotateInDownLeft&quot;&gt;&#123; &#123; page.title &#125; &#125;&lt;/h1&gt;&lt;h2 class=&quot;subheading animated rotateInUpRight&quot;&gt;&#123; &#123; page.subtitle &#125; &#125;&lt;/h2&gt; 首页： 12&lt;h1 class=&quot;animated flipInX&quot;&gt;&#123;% if page.title %&#125;&#123; &#123; page.title &#125; &#125;&#123;% else %&#125;&#123; &#123; site.title &#125; &#125;&#123;% endif %&#125;&lt;/h1&gt;&lt;span class=&quot;subheading animated flipInY&quot;&gt;&#123; &#123; page.description &#125; &#125;&lt;/span&gt; 为什么jQuery会卡顿?让我们从基本开始说起： Javascript 和 jQuery 两者不能混为一谈。Javascript 动画很快，而 jQuery 动画很慢。为什么呢？因为尽管 jQuery 异常强大，但是它的设计目标并不是一个高效的动画引擎： jQuery 不能避免 layout thrashing （有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。 jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易让动画卡住。 jQuery使用了setInterval而不是 reqeustAnimationFrame(RAF)，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF） 注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。 总结CSS3也是个很强大的东西，前端的资源真的是很多很多。没想到还有专门的动画效果CSS库，在以后还会更加灵活的去运用其他第三方的库。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}],"author":"BoomXu"},{"title":"Git的常用操作","slug":"2017/git-usually-opera","date":"2017-06-15T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/git-usually-opera/","link":"","permalink":"https://summxu.github.io/2017/git-usually-opera/","excerpt":"","text":"Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。 *Git 是 Linus Torvalds *为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 常用操作查看、添加、提交、删除、找回，重置修改文件git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异 git diff git diff # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支git br -r # 查看远程分支 git br # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b # 创建新的分支，并且切换过去 git co -b # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b origin/ # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin # 创建远程分支， origin是远程仓库名 git push origin : # 创建远程分支 git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理GitHub git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库 git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://summxu.github.io/tags/Git/"}],"author":"BoomXu"},{"title":"通过jQuery添加网页的动画效果","slug":"2017/add-jquery-effect","date":"2017-06-14T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/add-jquery-effect/","link":"","permalink":"https://summxu.github.io/2017/add-jquery-effect/","excerpt":"","text":"看了下同学的Hexo博客，Next的动态主题简直帅炸，不服气，我的Jekyll也可以做到。刚会点jQuery正好顺便研究一下动画效果。随便弄弄也花费了2个小时，不过学到了很多。 jQuery 效果函数由于新手所以只弄了jQuery提供的默认动画（感觉已经很好看了）。查阅相关资料： 方法 描述 animate() 对被选元素应用“自定义”的动画 clearQueue() 对被选元素移除所有排队的函数（仍未运行的） delay() 对被选元素的所有排队函数（仍未运行）设置延迟 dequeue() 运行被选元素的下一个排队函数 fadeIn() 逐渐改变被选元素的不透明度，从隐藏到可见 fadeOut() 逐渐改变被选元素的不透明度，从可见到隐藏 fadeTo() 把被选元素逐渐改变至给定的不透明度 hide() 隐藏被选的元素 queue() 显示被选元素的排队函数 show() 显示被选的元素 slideDown() 通过调整高度来滑动显示被选元素 slideToggle() 对被选元素进行滑动隐藏和滑动显示的切换 slideUp() 通过调整高度来滑动隐藏被选元素 stop() 停止在被选元素上运行动画 toggle() 对被选元素进行隐藏和显示的切换 这是jQuery提供的效果函数，发现可以用到的默认的其实只有两个：fadeIn() 、 slideToggle() 代码因为fadeIn() 、 slideToggle() 函数都是在元素为隐藏的情况下才能显示效果，所以要先在样式里把div给隐藏掉，为了不出错，我先写了一个小例子： 可以点击此处预览下效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .demo&#123; display:none; &#125; .demo1&#123; display:none; &#125; &lt;/style&gt; &lt;script&gt; $(document).ready(function () &#123; $(\".demo1\").slideToggle(1500); $(\"#effect1\").slideToggle(1500); $(\"#effect2\").fadeIn(\"slow\"); $(\"#effect3\").slideDown(1500); &#125;); $(function()&#123; $(\"#ok\").click(function()&#123; $(\"#effect4\").animate(&#123;left: \"500px\"&#125;,3000) .animate(&#123;height:\"200px\"&#125;,1000); &#125;);&#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"effect1\" class=\"demo\"&gt; &lt;p&gt;我是逐渐下拉的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div id=\"effect2\" class=\"demo\"&gt; &lt;p&gt;我是淡入淡出的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div id=\"effect3\" class=\"demo\"&gt; &lt;p&gt;我是向下滑动的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div id=\"effect4\"&gt; &lt;p&gt;我是向上滑动的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div class=\"demo1\"&gt; &lt;p&gt;我没有id&lt;/p&gt; &lt;/div&gt; &lt;input id=\"ok\" type=\"button\" value=\"点我试试\"&gt;&lt;/body&gt; 然后写到了Jekyll _post里: 1234567891011121314151617181920212223242526&lt;style type=&quot;text/css&quot;&gt; .tags&#123; display: none; &#125; .title&#123; display: none; &#125; .effect&#123; display: none; &#125;&lt;/style&gt;&lt;div class=&quot;tags&quot;&gt; &#123;% for tag in page.tags %&#125; &lt;a class=&quot;tag&quot; href=&quot;&#123; &#123; site.baseurl &#125; &#125;/tags/#&#123; &#123; tag &#125; &#125;&quot; title=&quot;&#123; &#123; tag &#125; &#125;&quot;&gt;&#123; &#123; tag &#125; &#125;&lt;/a&gt; &#123;% endfor %&#125;&lt;/div&gt; &lt;h1 class=&quot;title&quot;&gt;&#123; &#123; page.title &#125; &#125;&lt;/h1&gt; &lt;div class=&quot;effect&quot;&gt; &#123;% comment %&#125; &#123;% endcomment %&#125; &#123;% comment %&#125; if page.subtitle &#123;% endcomment %&#125; &lt;h2 class=&quot;subheading&quot;&gt;&#123; &#123; page.subtitle &#125; &#125;&lt;/h2&gt; &#123;% comment %&#125; endif &#123;% endcomment %&#125; &lt;span class=&quot;meta&quot;&gt;Posted by &#123;% if page.author %&#125;&#123; &#123; page.author &#125; &#125;&#123;% else %&#125;&#123; &#123; site.title &#125; &#125;&#123;% endif %&#125; on &#123; &#123; page.date | date: &quot;%B %-d, %Y&quot; &#125; &#125;&lt;/span&gt;&lt;/div&gt; 遇到的问题其实代码很简单，但是我缺花了近一小时的时间去寻找错误（一开始代码写上不能正常显示）。先是更换本地jQuery然后有换远程jQuery引用 ，却一直没有成功。 最后发现，jQuery要放到页面的头部？？？？ 为什么和我学的不太一样？？？不是引用文件放到哪都可以吗？ nm","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://summxu.github.io/tags/jQuery/"}],"author":"BoomXu"},{"title":"CSS控制背景图片亮度","slug":"2017/css-image-lightness","date":"2017-06-14T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/css-image-lightness/","link":"","permalink":"https://summxu.github.io/2017/css-image-lightness/","excerpt":"","text":"不美观引发的技术思考即实现。。 前言打开博客，细细的看了看自己写的小东西，虽说不好但却是自己一点一点的小经验。但是，种感觉有什么怪怪的。。 1 仔细看看： 2 卧槽。。发现文字颜色为什么和图片融为一体了？？？？我是瞎了吗这么久都没看出来！！！！得赶紧想想办法 想法：opacity首先想到的就是，调暗图片颜色 记得可以使用：css3的opacity:x调整图片透明度，上面弄上全黑背景，因为用的jekyll，所以直接改代码。。。 找到post.html 看了看头部发现代码如下： 123header.intro-header&#123; background-image: url(&apos;&#123;% if page.header-img %&#125;&#123; &#123; page.header-img &#125; &#125;&#123;% else %&#125;&#123; &#123; site.header-img &#125; &#125;&#123;% endif %&#125;&apos;);&#125; 很简单，直接就一个 background-image 然后直接加上覆盖上一个css试试。 1234header.intro-header&#123; background-image: url(&apos;&#123;% if page.header-img %&#125;&#123; &#123; page.header-img &#125; &#125;&#123;% else %&#125;&#123; &#123; site.header-img &#125; &#125;&#123;% endif %&#125;&apos;); opacity: 1;&#125; 3 发现可以透明了，但是整个文字也透明了，这不符合要求啊。。。百度了下，原来用 opacity 是不符合要求的。 实现透明的css方法通常有以下3种方式，以下是不透明度都为80%的写法 css3的opacity:x，x 的取值从 0 到 1，如opacity: 0.8 css3的rgba(red, green, blue, alpha)，alpha的取值从 0 到 1，如rgba(255,255,255,0.8) IE专属滤镜 filter:Alpha(opacity=x)，x 的取值从 0 到 100，如filter:Alpha(opacity=80) 使用说明：设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度..那么使用opacity实现《背景透明，文字不透明》是不可取的。 *opacity *代码示例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;css3的rgba&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background-color:#000000;/* IE6和部分IE7内核的浏览器(如QQ浏览器)下颜色被覆盖 */ background-color:rgba(0,0,0,0.2); /* IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂，但解析为透明 */&#125;.demo p&#123; color: #FFFFFF;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;p&gt;背景透明，文字也透明&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; rgba 很奇葩的是，IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂rgba，解析后颜色为透明，其实应该是null. 管不了这么多了，IE这种被时代抛弃的东西，我才不考虑。. 看了下示例代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;css3的rgba&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background-color:#000000;/* IE6和部分IE7内核的浏览器(如QQ浏览器)下颜色被覆盖 */ background-color:rgba(0,0,0,0.2); /* IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂，但解析为透明 */&#125;.demo p&#123; color: #FFFFFF;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;p&gt;背景透明，文字也透明&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; 加到我的Jekyll post 里看看效果： 4 12345678910&lt;style type=&quot;text/css&quot;&gt; .mengban&#123; background-color:#000000; background-color:rgba(0,0,0,0.2); &#125; header.intro-header&#123; background-image: url(&apos;&#123;% if page.header-img %&#125;&#123; &#123; page.header-img &#125; &#125;&#123;% else %&#125;&#123; &#123; site.header-img &#125; &#125;&#123;% endif %&#125;&apos;); opacity: 1; &#125;&lt;/style&gt; 可以了，但是还是有点白 ， 调整下参数。。完美解决。。 5 不过既然写到这了，在说下IE的: IE专属滤镜 filter:Alpha使用说明：IE浏览器专属，问题多多，本文以设置背景透明为例子，如下： 仅支持IE6、7、8、9，在IE10版本被废除 在IE6、7中，需要激活IE的haslayout属性(如：zoom:1或者overflow:hidden)，让它读懂filter:Alpha 在IE6、7、8中，设置了filter:Alpha的元素，父元素设置position:static(默认属性)，其子元素为相对定位，可让子元素不透明 示例代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;opacity&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background: #000000; filter:Alpha(opacity=50);/* 只支持IE6、7、8、9 */ position:static; /* IE6、7、8只能设置position:static(默认属性) ，否则会导致子元素继承Alpha值 */ *zoom:1; /* 激活IE6、7的haslayout属性，让它读懂Alpha */&#125;.demo p&#123; color: #FFFFFF; position: relative;/* 设置子元素为相对定位，可让子元素不继承Alpha值，保证字体颜色不透明 */&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;p&gt;背景透明，文字不透明&lt;/p&gt;&lt;/div&gt; 本文部分文章出处：http://peunzhang.cnblogs.com/","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://summxu.github.io/tags/HTML/"}],"author":"BoomXu"},{"title":"如何在Windows下安装Jekyll","slug":"2017/windows-install-jekyll","date":"2017-06-13T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2017/windows-install-jekyll/","link":"","permalink":"https://summxu.github.io/2017/windows-install-jekyll/","excerpt":"","text":"windows环境下安装1. 安装 Ruby官网：http://rubyinstaller.org/downloads/ 测试： Ruby是否安装成功，执行命令ruby -v 注意：勾选 “Add Ruby executables to your PATH”，安装路径不能包含空格 2. 安装 DevKit官网：http://rubyinstaller.org/downloads/ 步骤： 在命令窗口下切换到安装目录，并执行以下命令 12ruby dk.rb initruby dk.rb install 测试： gem是否安装成功，执行命令gem -v 注意：Ruby与DevKit版本要对应 3. 安装 Jekyll步骤： 在命令窗口下执行以下命令 123456789101112//更换gem源gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org///查看gem源gem sources -l//更新gemgem update --system//安装jekyllgem install jekyll 4. 安装 Python 相关环境a. 安装 Python官网：http://www.python.org/download/ 测试： python是否安装成功，执行命令python -V 注意：下载Python 2安装，如果安装Python 3 可能不会正常工作。安装后添加环境变量。 b. 安装 Easy Install 提示：*需要下载ez_setup.py) 步骤： 执行cmd命令 python “D:\\software\\Jekyll\\ez_setup.py”(这里要改为你自己的目录） 测试： Easy Install 是否安装成功，执行命令easy_install –version 注意：添加 Python Scripts 路径到环境变量 c. 安装 Pygments步骤： 执行命令easy_install Pygments 5. Jekyll启动与调试步骤： 打开命令行窗口，执行以下命令 123456//创建jekyll工程目录jekyll new myblog//切换到工程目录，并开启服务cd myblogjekyll serve 测试： Jekyll是否正常开启，访问localhost:4000 最后：附件附件个自动安装脚本，双击install.bat即可：点此下载","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"初学BootStrap --Form Demo","slug":"2017/bootsrp-form-demo","date":"2017-06-11T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/bootsrp-form-demo/","link":"","permalink":"https://summxu.github.io/2017/bootsrp-form-demo/","excerpt":"","text":"根据MOOC上的教程做了一个小小的demo。也从现在开始创建一个可以直接预览的效果。 点此预览123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;表单和viewport例子&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"bootstrap.min.css\"&gt; &lt;script src=\"jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"text-center\"&gt;请注册您的账号：&lt;/p&gt; &lt;form&gt; &lt;div class=\"form-group has-error\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"请输入您的手机号码\"&gt; &lt;/div&gt; &lt;div class=\"form-group has-success\"&gt; &lt;label for=\"\"&gt;请选择您的城市：&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option value=\"\"&gt;北京&lt;/option&gt; &lt;option value=\"\"&gt;上海&lt;/option&gt; &lt;option value=\"\"&gt;济南&lt;/option&gt; &lt;option value=\"\"&gt;成都&lt;/option&gt; &lt;option value=\"\"&gt;重庆&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"button\" class=\"\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn btn-block\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-success active\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-primary\" disabled=\"disabled\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-info\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-warning\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-danger btn-sm\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-default btn-lg\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-link\" value=\"确定注册\"&gt; &lt;/div&gt; &lt;a href=\"\" class=\"btn btn-default btn-lg\"&gt;这是用a标签的按钮效果&lt;/a&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://summxu.github.io/tags/jQuery/"},{"name":"BootStrap","slug":"BootStrap","permalink":"https://summxu.github.io/tags/BootStrap/"}],"author":"BoomXu"},{"title":"通过JS代码提交连接到百度","slug":"2017/atao-up-link-baidu","date":"2017-06-10T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/atao-up-link-baidu/","link":"","permalink":"https://summxu.github.io/2017/atao-up-link-baidu/","excerpt":"","text":"为了加快百度对博客文章的收录，站长们最好提交网站文章的连接到百度，百度提供了四种方式： 主动推送(实时)百度官方说这是最好的推送方式，但是这种静态博客不支持，像PHP的博客wordprass可以只用这种方式，百度也给出了几个提交例子： initiative sitemap以站点地图的形式来提交网站，站点地图中可以填入你网站所有的连接，我认为这适用与一些比较大的网站且是第一次提交连接。 sitmao 手动提交把连接逐条填写到网站中提交，如果连接过多的情况下挺麻烦的。 manual 自动推送自动推送是百度站长平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。 aoto 其代码如下： 12345678910111213141516&lt;!-- 百度实时网页推送 --&gt; &lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https')&#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else&#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&lt;!-- 百度实时网页推送 END--&gt; 本站是采用自动提交的JavaScript代码来提交网站连接。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"HTTPS自动跳转JS代码","slug":"2017/coding-301-baidu-spider","date":"2017-06-10T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/coding-301-baidu-spider/","link":"","permalink":"https://summxu.github.io/2017/coding-301-baidu-spider/","excerpt":"","text":"前言 因为某种原因，本站的博客部署在了 Coding Pages 。其很大原因主要是为了兼顾百度的收录问题（GitHub停止了百度收录），但是却遇到了重重困难。 Coding pages开启了https https enble 如果启用了强制HTTPS访问，百度抓取就会 出现一下错误： error 上面提示异常信息：连接重定向次数超过5次的上限。这里就有两个疑问： 我是hrtps的站点，抓取的时候确实http？ 我确实做了强行301到https（刚才coding上那个选项），但是为什么说重定向超过5次？ 我感觉这次抓取的结果可以重三个方面分析： 我是hrtps的站点，抓取的时候确实http？ 首先这个原因，暂且认为百度抓取只会抓HTTP的页面并不会抓HTTPS，这个原因直接导致了抓取http出现有跳转的情况。(但是想了想可能又不是这样，百度搜索引擎是不可能连一个HTTPS都不抓的。不过从抓取结果上来看，它确实只是抓取的http) 为什么说重定向超过5次？ 有可能是因为Coding.Coding的强制跳转到HTTPS是不是就跳转了一次，还中间做了其他的页面？ 百度抓取问题。 所以说这个问题至今都很奇怪，除了百度，其他所有的搜索引擎都可以成功去抓取。 索性关掉CodingPages的301功能来用JavaScript代码试下。 代码实现检测来自百度蜘蛛并跳转12345678910111213&lt;!-- 判断百度爬虫 --&gt;&lt;script&gt; $(function()&#123; var s=document.referrer; //获取来源地址 var targetProtocol = \"https:\"; if(s.indexOf(\"baidu\")&gt;0)&#123; if (window.location.protocol != targetProtocol)&#123; window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); //跳转到HTTPs &#125; &#125; &#125;);&lt;/script&gt;&lt;!-- 判断百度爬虫END --&gt; 这段代码其实是检测百度抓取而不是其他引擎或者用户正常访问来做的跳转，其中： document.referrer //获取来源地址window.location.href //只身跳转，可传递搜索引擎权重并不会引起各种浏览器屏蔽indexOf() // 方法可返回某个指定的字符串值在字符串中首次出现的位置。 直接HTTP到https跳转123456&lt;script&gt; var targetProtocol = \"https:\"; if (window.location.protocol != targetProtocol)&#123; window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); //跳转到HTTPs &#125; &lt;/script&gt; window.location.protocol //检测当前访问是不是HTTP 结果 rithg 百度能正常抓取了，看样子是http的页面，不知道为什么，真的是好乱，而且JS跳转真的是不入直接301.唉，为了百度的索引。 更新下，已经有页面抓取到了。 end 先这么滴把。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"巧用VScode“用户代码片段”来提高效率","slug":"2017/vscode-snippet","date":"2017-06-09T16:00:00.000Z","updated":"2023-07-21T12:35:55.259Z","comments":true,"path":"2017/vscode-snippet/","link":"","permalink":"https://summxu.github.io/2017/vscode-snippet/","excerpt":"","text":"前言刚学前端，用VS code写代码很爽，而且还支持git、markdown可以直接上传刚写完的博客。而用来写HTML、JavaScript也是相当方便。最近在学习bootstrap，总感觉每次引入js或者样式文件非常麻烦，但发现VS code有代码片段功能，在此记录下。 使用找到入口这里提供了两种方法： 按「Alt」键切换菜单栏，通过文件 &gt; 首选项 &gt; 用户代码片段，选择进入目的语言的代码段设置文件； 通过快捷键「Ctrl + Shift + P」打开命令窗口（all command window），输入「snippet」，通过候选栏中的选项进入目的语言的代码段设置文件。 VSCode 中 snippet 的文法12345678910111213// Place your snippets for C here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: &quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;log&quot;,, &quot;body&quot;: [ &quot;console.log(&apos;$1&apos;);&quot;, &quot;$2&quot; ], &quot;description&quot;: &quot;Log output to console&quot;&#125; snippet 各参数介绍snippet 由三部分组成： prefix：前缀，定义了 snippets 从 IntelliSense 中呼出的关键字; body： 主体，即模板的主体内容，其中每个字符串表示一行; description：说明，会在 IntelliSense 候选栏中出现。未定义的情况下直接显示对象名，上例中将会显示 Print to console。 其中 body 部分可以使用特殊结构来控制光标和要插入的文本。 支持的功能及其文法如下： Tabstops：制表符用「Tabstops」可以让编辑器的指针在 snippet 内跳转。使用 $1，$2 etc. 指定光标位置。这些数字指定了Tabstops将被访问的顺序，特别地，$0表示最终光标位置。相同序号的「Tabstops」被链接在一起，将会同步更新，比如下列用于生成头文件封装的 snippet 被替换到编辑器上时，光标就将同时出现在所有$1位置。 123&quot;#ifndef $1&quot;&quot;#define $1&quot;&quot;#end // $1&quot; Placeholders：占位符「placeholder」是带有默认值的「Tabstops」，如 ${1：foo}。「placeholder」文本将被插入「Tabstops」位置，并在跳转时被全选，以方便修改。占位符还可以嵌套，例如 : struct ${1:name_t} {\\n\\t$2\\n}; Variables：变量使用$name或${name:default}可以插入变量的值。 当未设置变量时，将插入其缺省值或空字符串。 当varibale未知（即，其名称未定义）时，将插入变量的名称，并将其转换为「placeholder」。 可以使用以下「Variable」： TM_SELECTED_TEXT：当前选定的文本或空字符串 TM_CURRENT_LINE：当前行的内容 TM_CURRENT_WORD：光标下的单词的内容或空字符串 TM_LINE_INDEX：基于零索引的行号 TM_LINE_NUMBER：基于一索引的行号 TM_FILENAME：当前文档的文件名 TM_DIRECTORY：当前文档的目录 TM_FILEPATH：当前文档的完整文件路径 引入文件的写入知道了如上支持，我就开始着手写bootstrap的引入文件了： 123456789\"Print to console\": &#123; \"prefix\": \"bootstrap\", \"body\": [ \"&lt;link rel=\\\"stylesheet\\\" href=\\\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\\\"&gt;\", \"&lt;script src=\\\"http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js\\\"&gt;&lt;/script&gt;\", \"&lt;script src=\\\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js\\\"&gt;&lt;/script&gt;\" ], \"description\": \"This Jquery &amp; BootStrap quate\" &#125; 值得注意的是：文件是以json的书写格式来的，而引号在其中要用转义字符，直接输入引号的话，是会产生错误的。 json字符转义官网也给出了 snippet 的 EBNF 范式的正则文法，注意，使用\\（反斜杠）转义$, ,, }和\\。 1234567any ::= tabstop | placeholder | variable | text tabstop ::= &apos;$&apos; int | &apos;$&#123;&apos; int &apos;&#125;&apos; placeholder ::= &apos;$&#123;&apos; int &apos;:&apos; any &apos;&#125;&apos; variable ::= &apos;$&apos; var | &apos;$&#123;&apos; var &#125;&apos; | &apos;$&#123;&apos; var &apos;:&apos; any &apos;&#125;&apos; var ::= [_a-zA-Z] [_a-zA-Z0-9]* int ::= [0-9]+ text ::= .* 而在代码里我们的引号换成了： &quot; 结果 jg1 jg2","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"},{"name":"BootStrap","slug":"BootStrap","permalink":"https://summxu.github.io/tags/BootStrap/"},{"name":"HTML","slug":"HTML","permalink":"https://summxu.github.io/tags/HTML/"}],"author":"BoomXu"},{"title":"初学BootStrap --引入模板","slug":"2017/html-jquery-bootstrap-temp","date":"2017-06-08T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/html-jquery-bootstrap-temp/","link":"","permalink":"https://summxu.github.io/2017/html-jquery-bootstrap-temp/","excerpt":"","text":"在此记录下自己一步步学习前端的过程！ 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\"&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 以上是引用JQery和BootStrap的html模板。","categories":[],"tags":[{"name":"BootStrap","slug":"BootStrap","permalink":"https://summxu.github.io/tags/BootStrap/"}],"author":"BoomXu"},{"title":"关闭Linux强行杀掉进程服务","slug":"2017/linux-oom-kill","date":"2017-06-07T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/linux-oom-kill/","link":"","permalink":"https://summxu.github.io/2017/linux-oom-kill/","excerpt":"","text":"本人搭建了个Minecraft的服务器运行在了Centos上，本身机器内存为1G，我设置的Java *Xms700m -Xmx700m *. 那么问题来了，我的世界玩着的时候经常断开，而且服务器也连接不上了？ Minecraft 仔细查看系统日志发现： kill java 竟然因为内存占用过多被系统直接Kill掉了。我们都知道，Linux系统为了保护系统运行，会把内存占用过高的程序杀掉，那么这个进程就是 OOM_killer OOM_killerOOM_killer是Linux自我保护的方式，当内存不足时不至于出现太严重问题，有点壮士断腕的意味在kernel 2.6，内存不足将唤醒oom_killer，挑出/proc//oom_score最大者并将之kill掉 为了保护重要进程不被oom-killer掉，我们可以： 1echo -17 &gt; /proc/&lt;pid&gt;/oom_adj,-17表示禁用OOM 我们也可以对把整个系统的OOM给禁用掉： 12sysctl -w vm.panic_on_oom=1 （默认为0，表示开启）sysctl -p 值得注意的是，有些时候 free -m 时还有剩余内存，但还是会触发OOM-killer，可能是因为进程占用了特殊内存地址 平时我们应该留意下新进来的进程内存使用量，免得系统重要的业务进程被无辜牵连可用 top M 查看最消耗内存的进程，但也不是进程一超过就会触发oom_killer参数/proc/sys/vm/overcommit_memory可以控制进程对内存过量使用的应对策略 123当overcommit_memory=0 允许进程轻微过量使用内存，但对于大量过载请求则不允许(默认）当overcommit_memory=1 永远允许进程overcommit当overcommit_memory=2 永远禁止overcommit OK 了，果然没在出现掉线的情况了，不过这个方式还是会存在问题，就是当内存实在是过大的时候，会破坏系统的整体稳定性，极大可能会宕机！ 22：54更新 宕机了！！！重启后发现： error 这就悲剧了！！！ 看来还是老老实实的 Java *Xms256m -Xmx256m * 这样确实不出现连接问题，但是这样会损失一点游戏的流畅性(比如在铁路上做很长距离的矿车，会卡成狗。。) 什么？？？想完美解决？ 还是 ： 给服务器加大内存把@！！@！","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"游戏","slug":"游戏","permalink":"https://summxu.github.io/tags/游戏/"}],"author":"BoomXu"},{"title":"精简实用的VScode前端扩展","slug":"2017/vscode-extended-html","date":"2017-06-07T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/vscode-extended-html/","link":"","permalink":"https://summxu.github.io/2017/vscode-extended-html/","excerpt":"","text":"前言vscode是一款跨平台的代码编辑器，她轻量、美观、一致、功能完整，自带完美git支持，非常适合前端同学使用。下面总结下我对于这个软件的使用技巧，希望对大家有帮助。 快捷键注意：当下列快捷键不起作用时，请考虑是否是其他软件已经占用了快捷键，如输入法、聊天软件等 vscode内置了emmet，使用tab键可快速编写html/css等，具体请查询emmet语法说明 快捷键 备注 Ctrl + N 新建文件 Ctrl + S 保存文件 Ctrl + F 在当前文件内查找 Ctrl + H 在当前文件内替换 Ctrl + Shift + F 在文件内查找 Ctrl + Shift + H 在文件内替换 Ctrl + Tab 切换文档 Ctrl + PgUp/PgDn 向前/向后切换文档 Ctrl + 1/2/3 切换分栏 Ctrl + P 转到文件 Ctrl + P 转到文件 Ctrl + G 转到行，输入行号，转到该行号处 Ctrl + 鼠标滚轮 缩放编辑器显示比例 Ctrl + F1 在浏览器中打开当前正在编辑的html文件，这个功能需要插件支持，安装插件：View In Browser F12 转到定义，可跳转到变量定义处，定义较为复杂时，会找不到 F1 打开命令输入框 Shift + Alt + F 格式化代码 Ctrl + Alt + Up/Down/Left/Right 按区域选中代码，并编辑 Alt + Up/Down 移动光标所在行或者光标选中代码的位置 Alt + Left/Right 前进或后退操作历史，这个历史不是编辑历史（Ctrl + Z/Y操作的是编辑历史），它包含如：第一步，光标在12行6列处；第二步，光标在20行10列处；第三步，打开另外一个文件。 Shift + Alt + Up/Down 复制光标所在行至上一行或下一行 Alt + 光标选中 光标多选，同时编辑 扩展/插件vscode支持扩展，官方商店里有很多扩展，网址：https://marketplace.visualstu…安装方式：点击编辑器左侧的【扩展】按钮，在搜索框中输入你想要安装的插件，点击安装即可。 推荐插件 链接 名称 备注 查看 Path Intellisense 在编辑器中输入路径时，自动补全 查看 Auto Close Tag 自动补全html标签，如输入将自动补全 查看 Auto Rename Tag 自动重命名html标签，如修改为，将自动修改结尾标签为 查看 REST Client 在编辑器中发送http请求，可直接得到结果，测试接口时很有用处，用法请看插件详情 查看 Easy LESS 自动编译less文件（文件保存后自动变为为同名.css文件），如果你只是想用less，而又不想配置grunt等工具来使用它时，请使用这个插件，他绝对是更效率的 查看 View In Browser 按Ctrl + F1在浏览器中打开正在编辑的html文件 查看 vscode-icons 为文件添加炫酷的图标，图标种类很全，包括各种配置文件、常见语言、常见js框架等，你值得拥有；安装后，需要使用管理员权限启动vscode，并打开命令输入框(F1或者Ctrl+Shift+P)执行Icons Enable 如有任何问题可以在下方留言或者给我邮件。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"无需后台的集成式评论系统","slug":"2017/choose-Comments","date":"2017-06-01T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/choose-Comments/","link":"","permalink":"https://summxu.github.io/2017/choose-Comments/","excerpt":"","text":"然而图片和此文章没有一点毛关系，只是为了好看。 前言：作为一个博客系统，评论系统几乎是必备的。而很多静态博客像Jekyll几乎没有自己开发评论系统的可能性，所以我们就介绍下比较常用的几家评论系统，和自己去搭建评论系统。 国内评论系统 多说——-(已关闭)多说算是国内最好用的评论系统了，但是多说宣布与2017年6月1日关闭。 友言不支持HTTPS，友言在评论管理方面比较全面，允许管理员自主灵活设置匿名评论功能，并且还支持数量最多的11种建站平台安装方式，但是友言在评论方式上表现较为不足。 网易云跟帖总体而言，网易云跟贴在用户评价方面表现也较为全面，但是账号登录方式也较少，在评论管理方面最为不足。 畅言总体而言，畅言表现最为全面，且唯一支持管理员分权管理，但是畅言账号的登录方式较少，支持PC端安装的建站平台数量也较少。本站也是正在使用畅言。 国外评论系统 Disqus Disqus是国外的评论插件，自从多说关闭后也是现在很多站长都在使用的评论系统，其界面美观简单。但是，被墙了。。。 搭建自己的评论系统issoIsso是一个轻量级的类似Disqus第三方评论系统，它允许匿名评论、注册评论、回复邮件通知以及自定义外观等功能。它的接口设计和Disqus高度相似，所以要集成这个评论系统只需要在Disqus接口上改几个单词，非常简单。 Isso是基于Python写的开源软件，你可以随意修改评论框外观。 isso 我在这里说下我看到的Docker容器的ISSO的安装方法，比较简单，不用去配置复杂的python环境。 用docker你首先要安装docker环境 和 Compose 。两个工具的安装在此不多赘述。。 下载Docker镜像 在docker上有人做出来了一个docker包，直接pull下来就可以，地址在这：https://hub.docker.com/r/wonderfall/isso/ 配置ISSO 新建一个文件夹名为config，在里面新建一个配置文件isso.conf： 12345[general]dbpath = /db/comments.dbhost = https://www.BoomXu.com[server]listen = http://0.0.0.0:8080/ 下面是一个Compose配置文件：123456789101112version: &apos;2&apos;services: isso: image: wonderfall/isso environment: - GID=1000 - UID=1000 volumes: - ./config:/config - ./db:/db ports: - &quot;8080:8080&quot; 保存为docker-compose.yml然后执行：1dokcer-compose up -d 搞定之后就可以通过8080端口的接口使用Isso评论系统了。 启动后目录应该是这样的：12345678.├── config│ └── isso.conf├── db│ └── comments.db└── docker-compose.yml2 directories, 3 files 设置 Isso服务已经运行了，当然直接访问8080端口是没有什么界面的，只有一个API接口。接下来我们要在静态博客中集成这个评论系统。 如果你使用的主题是纯HTML，那么嵌入下面两句即可： 1234&lt;script data-isso=&quot;//comments.example.tld/&quot; src=&quot;//comments.example.tld/js/embed.min.js&quot;&gt;&lt;/script&gt;&lt;section id=&quot;isso-thread&quot;&gt;&lt;/section&gt; 如果你是Jade或者Ejs等模板引擎，那么复制一下Disqus的代码，替换为Isso即可，例如Jade格式。 下面是Disqus的Jade模板：1234567891011121314if theme.disqus a#comments #disqus_thread script. var disqus_shortname = &apos;#&#123;theme.disqus&#125;&apos;; var disqus_identifier = &apos;#&#123;page.path&#125;&apos;; var disqus_title = &apos;#&#123;page.title&#125;&apos;; var disqus_url = &apos;#&#123;config.url&#125;/#&#123;page.path&#125;&apos;; (function() &#123; var dsq = document.createElement(&apos;script&apos;); dsq.type = &apos;text/javascript&apos;; dsq.async = true; dsq.src = &apos;//&apos; + disqus_shortname + &apos;.disqus.com/embed.js&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(dsq); &#125;)(); script(id=&apos;dsq-count-scr&apos; src=&apos;//#&#123;theme.disqus&#125;.disqus.com/count.js&apos; async) 现在改写为Isso评论系统（类似）：12345678910111213if theme.isso a#comments .isso-thread script. var isso-path = &#123;short_name:\"#&#123;theme.isso&#125;\"&#125;; (function() &#123; var isso = document.createElement('script'); isso.type = 'text/javascript';ds.async = true; isso.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//example.com/isso/js/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); 评论计数 如何在首页中显示文章计数？ 加入下面一句到页面中： 1&lt;a href=&quot;/my-uri.html#isso-thread&quot;&gt;Comments&lt;/a&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"免费搭建博客Github+Jekyll","slug":"2017/how-free-blog-pages","date":"2017-05-26T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/how-free-blog-pages/","link":"","permalink":"https://summxu.github.io/2017/how-free-blog-pages/","excerpt":"","text":"这篇博客将会为大家从0开始详细的讲解下怎么利用Github Pages来免费的搭建自己的博客，如果你自己有空间或者服务器，也可以换成自己的。如果你能看下去就一定可以搭建的出来。这篇文章虽说是教程向，但是对我自己来说更是一个自己研究搭建博客的过程记录，我希望这个教程能帮助到大家更能帮助到我自己。本人是第一次写博客， 难免有些激动。如果我有什么不对的地方和一些疏忽掉的地方，还请大家到博客下面浏览，或者可以在右边的小About里点击邮件图标给我发邮件。 废话少说，就是干！不过在这之前先介绍下咱们的Leading roles: Github Git Jekyll Freenom Markdown 就是这么简单，就可以轻而易举的去完成我们的工作，下面进入正文！ 注册并使用Github对于Github这个社区我想作为一个代码交流者或许无人不知，即使现在没有加入Github，但是如果你想继续你的代码事业，注册个Github是早完的事，而且这是必须的。在这里我不不谈论这个社区的历史、作用，如果你想了解，我推荐你看本PDF，内容不多，但是很有用。（从0开始学Github）我们只说怎么使用他的Pages功能，这里是Github的注册地址。Github 注册 创建repository 进入Github后直接点开始一个项目 项目名字这么输入，前面一定是你在Github的名字（不要输入成我的啊。），Description可以输入成自己喜欢的，如：我的个人博客 😆?? 出现这个页面代表你的Github仓库已经创建成功了，这也代表这，你在Github上的工作就先告一段落了。 **这个仓库也可以当作是一个虚拟空间，你可以在创建的时候勾选上创建README就能以网页上的形式去上传、修改、下载代码。但是这不是Github的正确用法,下面才是我们的正确的用法GIT! 现在这个仓库是空的，下面我们要用GIT 的方法去里面添加文件：** 使用GitGit是个复杂的东西，他可以理解成一种多人共享去管理仓库的方法。如果你没有基础的Git知识，跟着我做也可以达到目标，但是你如果想理解什么是Git，里面的语句怎么用，可以看看我的这篇博客。 git常用操作 如果你想使用GithubPages，就必须要了解相关的Git知识.正如上面所说的，你可以看看 这本PDF","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"},{"name":"Git","slug":"Git","permalink":"https://summxu.github.io/tags/Git/"}],"author":"BoomXu"},{"title":"Jekyll文章的格式和写法","slug":"2017/Jekyll-word-wirtd","date":"2017-05-23T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/Jekyll-word-wirtd/","link":"","permalink":"https://summxu.github.io/2017/Jekyll-word-wirtd/","excerpt":"","text":"Jekyll文章Markdown语法 Jekyll文章完全使用Markdown的语法规则。Markdown 是一种「电子邮件」风格的「标记语言」。 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 Jekyll文章格式123456789101112---layout: posttitle: &quot;Jekyll文章的格式和写法&quot;subtitle: &quot;初入Jekyll,基于Markdown语法的个人博客.&quot;date: 2017-5-24author: &quot;BoomXu&quot;header-img: &quot;123123.jpg&quot;tags: - Jekyll - Markdown - 博客--- 以下是Note配置介绍 123456789101112---layout: keynotetitle: &quot;Example Post using Keynote Layout&quot;subtitle: &quot;Keynote: JavaScript Modularization Journey&quot;iframe: &quot;http://huangxuan.me/js-module-7day/&quot;date: 2015-07-09author: &quot;Hux&quot;header-img: &quot;img/post-bg-js-version.jpg&quot;tags: - 前端开发 - JavaScript--- Jekyll和Markdown的相关链接Github LessOrMore 模板 献给写作者的 Markdown 新手指南 –简书","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"为自定义的域名添加免费SSL","slug":"2017/free-cloudflare-ssl-for-github-pages","date":"2017-05-23T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/free-cloudflare-ssl-for-github-pages/","link":"","permalink":"https://summxu.github.io/2017/free-cloudflare-ssl-for-github-pages/","excerpt":"","text":"原文连接 为自定义域名的GitHub Pages添加SSL 完整方案 简单总结一下这个过程： 在 github page 的设置中填入 custom domain 去你的域名注册商更改 dns server 成 cloudflare 所提供的 在 cloudflare 设置 A record ，参照 在 cloudflare 配置 crypto ，选择 flexiable （这一步要一段时间才能起效） 在 cloudflare 配置 page rule ，一个是 always use https ，一个是 redirect http 到 https 每一步的操作可能需要 5-30 分钟才能起效 为什么使用Cloudflare提供的免费SSL收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，这是一笔不必要的开销。我只是需要看到网站地址栏有绿色的锁头，那就证明我们的网站相对安全了。 此外，使用https之后，谷歌、百度等搜索排名权值（PR等）也会有相对提升。还有其他的一些，例如Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验~~ 好了，说了那么多，直接看教程~~ 创建CloudFlare帐户，并添加网站首先你已经有自己的自定义域名的GitHub Pages ，我的 GitHub Pages cname文件写的是 yicodes.com 实现目标： 当访客输入 yicodes.com 强制跳转使用https，访问wwww 也会跳转到https://www.yicodes.com 如果你还没有Cloudflare账号，点击注册 登陆后，点击这里 增加你的域名，如下图，输入你的域名，例如 yicodes.com *并点击 *Begin Scan 注意不要写WWW前缀，大约60秒即可完成域名解析扫描。完成后点击 Continue Setup 继续下一步 你看到DNS记录（包括子域）列表之后，按照下图提示设置后，其中cname是为了重定向www准备的，点击 Continue 下一步 选择免费计划，然后下一步~ 到你域名控制面板修改cloudflare给出的域名服务器，我这里以 Godaddy 为例 注：官方说明，域名服务器修改最长需要72小时生效 ，用了两个域名测试，大约需要 5~30 分钟，看到 Status: Active 即可 设置SSL 点击 crypto 菜单 , 然后设置 Flexible SSL ，如下图 添加www重定向到https://www.yicodes.com 添加自动重定向到 SSL页面 添加SSL的教程就此完成，一般需要5~30分钟生效！！！ 如果你有疑问，欢迎到我博客留言","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"如何在网页里插入全局新窗口打开超链接","slug":"2017/how-links-blank","date":"2017-05-23T16:00:00.000Z","updated":"2023-07-21T12:35:55.255Z","comments":true,"path":"2017/how-links-blank/","link":"","permalink":"https://summxu.github.io/2017/how-links-blank/","excerpt":"","text":"很多站长朋友都遇到了自己写的文章或者网站里的一些页面打开的时候都是以_myself的方式打开的，这样很多阅读者就会遇到想看着自己写的教程而又点开操链接都是直接在本页面上打开，这样我们就直接用一点小技术可以解决 JavaScript代码实现所有超链接以_blank方式打开12345678910&lt;!--把一下js代码放到页面的尾部，也就是&lt;/body&gt;标签的上面--&gt;&lt;script language=\"JavaScript\" type=\"text/javascript\"&gt; &lt;!-- var a = document.getElementsByTagName(\"A\"); for(var i = 0;i &lt; a.length;i++)&#123; a[i].target = \"_blank\"; &#125; //--&gt;&lt;/script&gt; 完全可以把以上代码粘贴到HTML的body内就可以实现全局超链接了！！😀是不是很开心！！！！Jekyll博客模板可以以下： 全局包括在首页上的所有连接，把代码复制到“_inclouds/footer.html”的末尾 文章内上的所有连接，，把代码复制到“_layouts/post.html”（根据自己的模板来，默认是post）的末尾 以上就是现所有超链接以_blank方式打开的方法，希望小伙伴们能成功 如果各位喜欢我的博客内容或者有什疑问可以在我的博客下方留言，或者给我发邮件！！ enjoy！ ###后记： 刚刚发现了点问题，我想把我的文章页面弄成_blank方式打开，但是不包括下面这个“上一篇博文”和“下一篇博文”这样，但是一但加入到最底部整个文章页面的超链接都是会以_blank的方式打开网页，这怎么办呢，其实只需仔细分析下这个JS的运行原理： 12345678&lt;script language=\"JavaScript\" type=\"text/javascript\"&gt; &lt;!-- var a = document.getElementsByTagName(\"A\"); //重要的是这一步 for(var i = 0;i &lt; a.length;i++)&#123; a[i].target = \"_blank\"; &#125; //--&gt;&lt;/script&gt; 这个 “getElementsByTagName()” 到底是什么作用呢： 如果把特殊字符串 “*” 传递给 getElementsByTagName() 方法，它将返回文档中所有元素的列表，元素排列的顺序就是它们在文档中的顺序。 也就是说这段JS是以代码以上的超链接数来计算的。这样就好办了，把程序代码段放到按钮前面，搞定！ 2017.06.02更新 几天时间内一直在弄只修改{ {–content–} }变量内的a标签的target值，后来还是通过jQuery寻找div的a标签来实现了，在这里谢谢KeJun大神 下面看看代码： 1234567&lt;script&gt;$(function()&#123; $('article').find(\"#content\").find('a').on('click',function()&#123; $(this).attr(\"target\",\"_blank\") &#125;)&#125;)&lt;/script&gt; 其中需要注意的是 jQuery的选择器，“#” 是选择ID “.”是选择class 总算是弄完了，下面开始弄自己搭建isso评论系统，还有好多事情做，这里end！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://summxu.github.io/tags/HTML/"}],"author":"BoomXu"}]}