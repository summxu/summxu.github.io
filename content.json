{"meta":{"title":"小兵旭旭的博客","subtitle":null,"description":"小兵旭旭","author":"summxu","url":"https://summxu.github.io","root":"/"},"pages":[{"title":"小兵旭旭","date":"2023-12-12T04:51:40.867Z","updated":"2023-12-12T04:51:40.867Z","comments":false,"path":"about/index.html","permalink":"https://summxu.github.io/about/index.html","excerpt":"","text":"@card{ 末批90后，大学网络工程。现居山东，不入流前端开发 。 会一点儿TypeScript和ReactNative，听说过Flutter。现着迷WebGL，至今不会修电脑。 喜欢游戏，尝试去做开发，但难以脱离Web，看好Cocos。 轻度强迫症，常年代码洁癖，会影响开发进度，不过还是想再慢一些。 兴趣众多，然无一精通。正努力成为一个有趣的人。 1console.log(\"👆以上是不完整的我\") }"},{"title":"标签分类","date":"2019-09-14T08:39:14.000Z","updated":"2023-12-12T04:51:40.867Z","comments":false,"path":"tags/index.html","permalink":"https://summxu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端面试题","slug":"2023/前端面试题","date":"2023-12-21T01:49:38.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2023/前端面试题/","link":"","permalink":"https://summxu.github.io/2023/前端面试题/","excerpt":"","text":"面试技巧 知识体系学习 书籍 博客 开源社区 反思复盘，整理零散知识点，完善知识体系 React组件为什么不能返回多个元素 React组件最后会编译为render函数，函数的返回值只能是1个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的 react的虚拟DOM是一个树状结构，树的根节点只能是1个，如果有多个根节点，无法确认是在哪棵树上进行更新 React组件怎样可以返回多个组件 使用HOC（高阶函数） 使用React.Fragment，会创建一个虚拟节点，但不会渲染到真实DOM中 使用数组返回 手写Promise（没有考虑链式调用）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 创建MyPromise类 class MyPromise &#123; // 通过构造函数constructor，在执行这个类的时候需要传递一个执行器进去并立即调用 constructor(executor) &#123; this.status = 'pending' // 定义 fulfilled 情况下的返回值 this.result = null // 定义 rejected 情况下的返回值 this.reason = null // 定义回调函数数组 this.onFulfilledCallbacks = [] this.onRejectedCallbacks = [] executor(this.resolve, this.reject) &#125; // 定义resolve函数，改变状态和调用回调 resolve = result =&gt; &#123; if (this.status !== 'pending') return this.result = result this.status = 'fulfilled' // 执行数组里的 回调函数 this.onFulfilledCallbacks.forEach(callback =&gt; callback(result)) &#125; // 定义reject函数，改变状态和调用回调 reject = reason =&gt; &#123; if (this.status !== 'pending') return this.reason = reason this.status = 'rejected' // 执行数组里的 回调函数 this.onFulfilledCallbacks.forEach(callback =&gt; callback(reason)) &#125; // 定义then方法，接受两个回调函数 then = (onFulfilled, onRejected) =&gt; &#123; // 判断接受的回调函数，并可以为空给默认值 onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123; throw reason &#125; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : result =&gt; result if (this.status === 'fulfilled') &#123; // fulfilled状态，调用第一个 fulfilled回调函数 // 添加到宏任务，尽量晚于执行器后 setTimeout(() =&gt; &#123; onFulfilled(this.result) &#125;); &#125; else if (this.status === 'rejected') &#123; // rejected状态，调用第二个 rejected回调函数 // 添加到宏任务，尽量晚于执行器后 setTimeout(() =&gt; &#123; onRejected(this.reason) &#125;); &#125; else if (this.status === 'pending') &#123; // 如果执行器中为异步（执行时机晚）不会立即改变状态，此时调用then一定是pending // 这个时候可以把回调函数保存到数组里，等待resolve/reject调用执行then this.onFulfilledCallbacks.push(onFulfilled) this.onRejectedCallbacks.push(onRejected) &#125; &#125; catch = (onRejected) =&gt; &#123; setTimeout(() =&gt; &#123; onRejected(this.reason) &#125;); &#125;&#125;new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('2秒之后执行then') &#125;, 200);&#125;).then(res =&gt; &#123; console.log(res) &#125;) mini Vuemini React","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"样式隔离与穿透","slug":"2023/样式隔离与穿透","date":"2023-11-23T06:49:38.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2023/样式隔离与穿透/","link":"","permalink":"https://summxu.github.io/2023/样式隔离与穿透/","excerpt":"","text":"css没有作用域，在书写的时候容易照成classname相同，产生样式污染、css规则层叠，单页面应用，多组件开发模式更容易出现此类问题，这就需要采用一些方法实现样式隔离。 BEM规范主动约束 BEM 是 Block Element Modifiyer 的缩写，指块-元素-修饰符.blockname-elementname-modifier Block 以元素本身所具备的功能为主 Element 以元素本身的位置、形状、描述为主 Modifier 以元素本身的状态、颜色为主 例如ElementUI中采用的BEM示例：el-cascader-nodelabel、el-date-table-celltext 可以配合Less、Scss预处理器协同开发： 12345.selector &#123; &amp;-item &#123; &amp;-foucs&#123; &#125; &#125;&#125; CSS Moudle css Moudle 是一种编译时的webpack插件，可以像js一样引入css，并且每一个css都是一个独立的模块，可以在使用的时候以变量的形式引入。在构建的过程中，通过映射关系把className生成唯一的hash，一般采用的css module插件是css-loader。 在React中，css Module 默认（css-loader 文件名正则）需要对css文件命名做约束：以 .module.less/css/sass 结尾，不仅如此，css Module 还提供了一些特殊的伪类。 :global，需要不对组件的类名进行哈希，保留原始类名，能起到样式覆盖的作用 :local，默认启用的伪类，需要不对组件的类名进行哈希 CSS In Js 其核心思想是将css直接写入到组件中，并不是通过引入的方式，而是通过js的形式去写css，然后在jsx中使用变量，ReactNative 默认采用的此方案。 Vue style scoped 使用 scoped 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。 如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用一下深度作用选择器：&gt;&gt;&gt; ::v-deep ::depp /deep/ ShadowDOM ShandowDOM 是一组 JavaScript API ，用于封装影子DOM树附加到元素，与主文档分开呈现，并且能控制其关联的功能。这样可以保持元素的功能私有，也可以支持脚本化和样式化，不用担心与其他文档发生冲突，ShadowDOM可以用js创建： 12345const hostEle = document.querySelector(&quot;#host&quot;)const treeEle = document.createElement(&quot;span&quot;)treeEle.textContent = &quot;treeEle&quot;const rootEle = hostEle.attachShadow(&#123; mode: &apos;closed&apos; &#125;);// 不允许外部访问rootEle.appendChild(treeEle) ShadowDOM是WebComponents的重要组成部分。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}]},{"title":"前端八股文","slug":"2023/前端八股文","date":"2023-11-21T01:49:38.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2023/前端八股文/","link":"","permalink":"https://summxu.github.io/2023/前端八股文/","excerpt":"","text":"传输协议&amp;&amp;浏览器https 协议的工作原理 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。 web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 web 服务器通过自己的私钥解密出会话密钥。 web 服务器通过会话密钥加密与客户端之间的通信。 从输入URL到页面加载的全过程 网络请求部分： 检查是否有浏览器缓存结果或缓存标识。 DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。 建立TCP连接：解析出IP地址后，根据IP地址和端口号，和服务器建立TCP连接。 发起HTTP请求：浏览器发起读取文档的HTTP请求，通过TCP三次握手请求数据。 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器。 关闭TCP连接：通过四次挥手释放TCP连接。 浏览器渲染部分： 构建DOM树：文档分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象 构建CSS规则树：生成CSS规则树（CSS Rule Tree） 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree） 布局（Layout）：计算出每个节点在屏幕中的位置（计算的过程） 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。 浏览器的重绘与重排 重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。 重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。 如何触发重排和重绘？ 添加、删除、更新DOM节点 通过display: none隐藏一个DOM节点-触发重排和重绘 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化 移动或者给页面中的DOM节点添加动画 添加一个样式表，调整样式属性 用户行为，例如调整窗口大小，改变字号，或者滚动。 如何避免重绘或者重排（性能优化）？ 集中改变样式，不要一条一条地修改 DOM 的样式。 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存 浏览器与服务器通信的方式为应答模式，浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。 接下来浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 知道了缓存机制是怎么运作的时候，在进一步了解具体的缓存规则，可以将浏览器缓存的过程分为两个部分： 服务器会将缓存规则放入HTTP响应头中，控制强制缓存的字段分别是 Expires 和 Cache-Control。Cache-Control高于Expires，一般控制的是强制缓存在什么时间之后失效。 强制缓存判断过程： 不存在该缓存结果和缓存标识，则直接向服务器发起请求（这也是第一次发起请求） 存在该缓存结果和缓存标识，且结果尚未失效，直接返回缓存结果。 存在该缓存结果和缓存标识，但该结果已失效，则使用协商缓存。 协商缓存在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，控制协商缓存的字段分别有 Last-Modified 、Etag，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。 强制缓存判断结果： 协商缓存生效，返回304 协商缓存失效，返回200和请求结果 HTML&amp;&amp;CSSscript 标签中 defer 和 async的区别 如果是&lt;script defer&gt;标签，那么就会js脚本与html文档并行加载，并在html文档加载完后再执行js脚本。 如果是&lt;script async&gt;标签，那么js脚本与html文档并行加载，但是与前者不同的是，async在js脚本加载完后会立刻执行。（执行时不能加载html文档） 常见的 meta 标签有哪些？ charset 用来描述HTML文档的编码类型 keywords 页面关键字 description 页面描述 refresh 页面重定向和刷新 viewport 适配移动端，可以控制视口大小和比例 robots 搜索引擎索引方式 什么是盒模型？ 在HTML中的所有的元素，都可以看作为一个盒子。 盒子的组成：margin、padding、border、content 盒模型的类型： 标准盒模型(box-sizing:content-box)：margin + padding + border + content IE盒模型(box-sizing:border-box):margin + content(padding + border) 文档定位方案 普通流： 元素按照HTML的先后位置上下布局 行内元素水平排列，当前行被占满之后换行，块级元素渲染为新的一行 所有元素的默认定位是普通流 浮动： 元素首先按照普通流的方式呈现，然后尽可能的向左或者向右偏移 浮动脱离了普通流元素 绝对/相对定位 绝对/相对脱离了普通流元素，不会影响兄弟元素 position 属性的值有哪些及其区别 固定定位 fixed：元素相对于浏览器窗口的固定定位，定位元素脱离文档流，不占据空间。 绝对定位 absolute：元素相对于最近的已定位的父元素定位，定位元素脱离文档流，不占据空间。 相对定位 relative：元素出现在本来的位置上，但是可以设置left、top等定位属性，如果设置了定位属性，元素会进行移动，但是仍占据本来所在的空间，所以相对定位也可以层叠到其他元素上面。 默认定位 Static：默认值。没有定位，在文档流中，占据空间，不能使用定位属性和z-index。 粘性定位 sticky：依赖于用户的滚动，在 relative 与 fixed 定位之间切换，而当页面滚动超出目标区域时，它会使用fixed固定在目标位置，否则使用relative定位在本来的位置上。 浮动的解决办法 清除浮动解决的是浮动元素的父元素的高度问题。原因是父元素没有设置高度，原本的高度，是由子元素撑起来的。当子元素浮动的时候，子元素是脱离文档流的,而父元素还是文档流里，这个时候，父元素的content没有东西，所以父元素的height就变为原本没有设置的高度（为0）。 把父元素创建为BFC（计算BFC高度的时候，浮动元素也会参与计算）。 为下一个块级兄弟元素添加样式 clear:both 父元素使用after，创建块级子伪元素，设置属性 clear:both; clear:both;(告诉浏览器一直到这个元素都不需要浮动); BFC(Block Formatting Context)：块级格式化上下文 BFC是指块级元素区域在页面中的渲染（排版）规则： 普通流的元素垂直方向的外边距会发生重叠。属于不同BFC的元素外边距不会发生重叠。 BFC元素是一个独立的容器，外面的元素不会影响里面的元素。 计算BFC高度的时候，BFC内部的浮动元素也会参与计算。 BFC作用 清除浮动（计算BFC高度的时候，浮动元素也会参与计算） 解决垂直外边距塌陷（属于不同BFC的元素外边距不会发生重叠） 防止兄弟float元素覆盖（BFC的区域不会与浮动元素的布局重叠,float也是BFC) BFC的创建（为元素添加属性触发BFC渲染）： overflow:hidden; float:left;float:right; position:absolute;position:fixed; display属性为inline-block,table,table-cell,table-caption,flex,inline-flex,grid; CSS优先级 css选择器冲突（多个选择器选择了相同的元素）导致出现选择器优先级问题 选择器类型：!important &gt; 行内 &gt; ID &gt; 类\\伪类\\属性 &gt; 标签 &gt; 全局（*） 选择器层级：（兄弟、子、后代）选择器，层级多的覆盖层级少的 代码先后顺序：后出现的代码覆盖先出现的 CSS继承 css三大特性：继承、层叠、优先级 字体属性：font 文本属性：line-height、color、text-align 元素可见性：visibility: hidden 表格布局：border-spacing 列表属性：list-style 隐藏元素的方法 display: none 隐藏元素，不占据页面位置 opactiy: 0 设置元素完全透明，占据页面位置 visibility: hidden 隐藏元素，占据页面位置 CSS 单位 px 在屏幕上显示出的绝对像素 em 相对与父级元素font-size比例的长度/大小（1em = 父级元素的font-size(px)) rem 相对与HTML元素font-size比例的长度/大小（1em = HTML元素的font-size(px)) % 相对于父级长度/大小的百分比 vw 把屏幕的宽度切成100份，每一份就是1vw vh 把屏幕的高度切成100份，每一份就是1vh 响应式布局方案 媒体查询：一套代码针对电脑、pad和移动设备，屏幕宽度相差悬殊的时候，使用@media(min-width) and (max-width)方法划分区域，单独做适应不同屏幕宽度的样式适配。 rem 计算屏幕宽度，动态设置html字体大小，等比缩放整体页面。 postcss 通过设计稿比例，在编译过程中把px转换成 vm/rem 单位。 用CSS实现三角符号 123456789/* 通过元素border的渲染机制实现的 */div&#123; width: 0px; height: 0px; border-top: 100px solid #ff0; border-right: 100px solid transparent; border-left: 100px solid transparent; border-bottom: 100px solid transparent;&#125; JavaScript类型判断 typeof &#39;123&#39; 可以区分基本数据类型，但引用数据类型都返回Object &#39;123&#39; instanceof String 可以区分引用数据类型，但不能区分基本数据类型 Object.prototype.toString.call(&#39;123&#39;) 返回 [Object Array] 可以判断所有数据类型 作用域 &amp;&amp; 闭包 作用域 全局作用域，在js中的任何地方都可以访问。 函数作用域，只能在函数内部或子函数中访问。 块级作用域 { }，if for… 变量提升 var 的变量声明会提升到当前作用域（无视块级作用域）最顶部在进行赋值。 function的声明会提升到当前作用域（无视块级作用域）最顶部，function 的提升优先级大于 var。 const 和 let 不会提升，并且之在块级作用域生效，他们在作用域内只能被声明一次 const 声明的时候必须赋值，let 可以只声明不赋值，默认是 undefind const 的值不可修改，但引用类型的赋值，可以修改其属性。 闭包 函数在执行时会形成属于函数的作用域，在函数执行完后，作用域就会被清理，内存也会被回收。但是在函数嵌套的时候，内部函数可以访问上级函数的变量，导致即使上级函数执行完，也不会被销毁，这时的内部函数就是闭包。 特点： 保护外部函数的变量不受污染 延长局部变量的生命周期（不会被回收） 会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏 用途： 节流、防抖记录timer 模仿块级作用域创建模块 对象 &amp;&amp; 原型 &amp;&amp; 原型链 创建对象： 字面量 const obj = {} Object.create(prototype, descriptors) 构造函数 function Person() { this.name = &#39;张三&#39; };new Person()，构造函数拥有constructor属性，也有原型的概念。 原型：在 JS 中，每创建一个对象时，对象中都会包含一些预定义的属性。其中每个构造函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。 原型链：构造函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现对象的继承，还有一个原型链指针proto，该指针指向的是上层原型对象，因此可以利用proto一直向上引用到 Object 再到 null 。这样就形成了原型链的概念。 特点：JavaScript对象是通过引用来传递的，创建的每个新对象实例中并没有一份属于自己的原型副本，所以修改原型时，与之相关的对象也会继承这一改变。 new 的实现步骤 创建一个新的空对象。 把对象的原型__proto__指向传入的构造函数的原型链prototype. 把构造函数的this，绑定到新对象上（对象添加了构造函数的新属性）。 判断构造函数的返回值，如果是值类型则返回这个对象，如果是引用类型，就返回这个引用类型的对象。123456const newFun = (Fun, ...args) =&gt; &#123; const newObj = &#123;&#125; newObj.__proto__ = Fun.prototype const result = Fun.apply(newObj, args) return result instanceof Object ? result : newObj &#125; this &amp;&amp; apply &amp;&amp; call &amp;&amp; bind apply 接受参数的是数组Function.apply(this,[arg1,arg2]) call 接受参数的是参数列表Function.call(this,arg1,arg2) bind 返回一个改变了this的新函数Function.bind(this)(arg1,arg2) this 全局作用域下或者作为普通函数执行时，this指向window。 当函数作为对象的方法被调用时，this就会指向该对象。 new 会改变函数的this指向，构造函数中的this指向的是实例对象。 箭头函数的this指向当前函数在哪个对象下面。 Function原型上的apply、call、bind改变this指向到指定的调用函数。 事件循环 EventLoop JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以区分了同步代码和异步队列，异步队列又分为宏任务队列和微任务队列，通过先后顺序反复将不同任务压入执行栈中执行的过程就形成了事件循环。因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列，事件循环是由浏览器来实现的。 函数入执行栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空； 此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列） 当同步代码执行栈执行完毕，Event Loop开始找微任务队列，并把微任务放到执行栈中执行。 微任务执行栈执行完毕后，进入宏任务队列。在一轮循环里，先执行一个宏任务，执行完成后查看微任务队列是否有任务，有的话，清空微任务队列，在执行下一个红任务，再继续查找微任务队列，如此循环，清空微任务队列，直至清空所有的任务。 宏任务（浏览器提供的）： setTimeout setInterval ajax onClick 微任务（语言本身提供的） Promise.then async await VueVue响应式原理 vue.js是MVVM框架，数据变化的时候，视图也会自动更新。采用数据劫持+发布者-观察者模式的方式，在数据变动时触发相应的监听回调，从而使视图更新。 Observer（数据监听器） : Observer的核心是遍历data对象里的属性，通过Object.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。在被遍历到的每一个属性中，都会添加一个Dep的实例，它内部有个subscribes队列，保存着依赖本数据的观察者，当本数据发生变化时，调用dep.notify()通知观察者watcher。 Watcher（观察者） : Watcher的实例有很多，它可以是视图模板中使用的变量、计算属性、侦听器。 在自身实例化时往属性订阅器(dep)里面添加自己。 自身必须有一个update()方法。 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。 Compile（指令解析器） : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，每个指令对应的节点绑定更新函数，一旦数据有变动，收到通知，更新视图。 React/Vue 项目中 key 的作用 是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM;在vue的diff函数中，会根据key去数组中对比新旧节点，而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找，map映射的速度更快。 在v-for的时候，vue采用了“就地复用”的更新策略，如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是使用key作为索引来显示已被渲染过的每个元素，重复的key会造成渲染错误。 nextTick的作用和实现原理 nextTick是解决vue在数据变化操作之后，立即获取DOM元素而取不到的问题。nextTick接受一个回调函数作为参数，同时在vue3中，nextTick会返回一个Promise。 Vue在更新DOM时是异步执行的，更改响应式状态时，Vue将开启一个缓存队列，同一事件循环如果一个watcher被多次触发，只会被推入到队列中一次，直到下一个“tick”才一起执行，这样避免不必要的计算。 vue2中的DOM异步更新和nextTick主要使用了宏任务和微任务执行回调的时机来实现，根据执行环境分别尝试采用Promise、MutationObserver、setTimeout。nextTick的任务队列在DOM更新的后面。 vue3中的nextTick默认采用了Pormise来实现，并且他默认返回一个Promise，这样同时也能使用 await 在事件循环结束之后操作DOM。 Vue3的新特性 响应式原理改变，数据劫持由Object.defineProperty改为Proxy/Reflect。 defineProperty只能劫持对象里某个属性的getter/setter，需要对vueData里的对象进行遍历递归，后添加的属性也无法实现响应式拦截，还需要重写大量的js原型实现完美响应式。 而Porxy利用ES6原生实现可以劫持整个对象的增删改查操作，配合上Reflect，提升了响应式实现的性能。 Reflect是为了操作对象而提供的API，他能把对象的操作都变成函数的行为，配合Proxy它能起到的作用是: 触发代理对象的劫持时保证正确的 this 上下文指向 能使框架避免在操作对象时更健壮，避免一些报错。 Composition API的引入能更加灵活地组织代码和重用组件逻辑，不像Options API那样需要写在特定的代码块内，常见的新API有： createApp 创建应用实例，相当于 new Vue provide、inject 局部范围内组件的传值，类似React useContext ref、reactive 定义响应式数据。ref 定义基本结构数据，reactive 定义复杂结构数据(Proxy只能代理对象，而ref又可以定义一个响应式的基本属性，vue在ref内部把基本属性包装成了对象，对象里只有一个属性是 value) computed 计算属性，有返回值，依赖数据发生改变就会重新计算 watch、watchEffect watch 是监听一个值的变化，watchEffect是收集依赖数据发生变化就执行 toRef、toRefs 解构单个reactive中的数据和解构整个reactive中的数据 getCurrentInstance 获取当前vue组件的实例 teleport、Suspense、Fragment组件 teleport 控制渲染位置，组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去，多用于modal弹出控制位置 Suspense 当要加载的组件都满足条件时，才会进行渲染。 Fragment 组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中。 ReactReact是一个网页UI库，它主要通过组件化的方式解决视图层开发复用的问题。 数据驱动视图：如果要渲染界面，不应该直接操作DOM，而是通过修改数据(state或prop)，数据驱动视图更新 组件化：每个组件都符合开放-封闭原则，封闭是针对渲染工作流来说的，指的是组件内部的状态都由自身维护，只处理内部的渲染逻辑。开放是针对组件通信来说的，指的是不同组件可以通过props（单项数据流）进行数据交互。 虚拟DOM：浏览器的DOM操作是一个昂贵的操作，很耗性能，因此产生了虚拟DOM。虚拟DOM是对真实DOM的映射，React通过新旧虚拟DOM对比，得到需要更新的部分，实现数据的增量更新。同时React因为虚拟DOM带来了很强的通用性，一次学习随处编写，比如ReactNative。这使得React的范围足够广，web、native都可以开发，这也是React的优势。 React的灵活性诞生出了很多优秀的设计模式，类组件和函数组件，hooks，hoc这些概念。 React作为视图层的框架，他并没有提供一揽子的解决方案，在开发大型应用时需要在社区寻找、整合解决方案，在技术选型和学习上造成了一些成本。 React18有哪些更新？ setState自动批处理 引入了新的root API，支持new concurrent renderer(并发模式的渲染) 去掉了对IE浏览器的支持，react18引入的新特性全部基于现代浏览器，如需支持需要退回到react17版本 flushSync react组件返回值更新，支持null和undefined Suspense不再需要fallback捕获 Concurrent Mode hooks增加：useSyncExternalStore、usId、useInsertionEffect jsx 转换过程 jsx的解析和转换主要依靠Babel来实现，通过Babel转换成React.createElement对节点的描述 React.createElement函数，它接收三个参数，分别是type元素类型，props元素属性，children子元素 babel转换是通过元素的首字母大小写来判断是原生元素还是自定义组件。 React.createElement生成虚拟DOM树，通过几种不同的节点类型来判断虚拟DOM生成： 原生标签节点 文本节点 函数组件 类组件 最后通过 ReactDom.render() 根据不同类型挂载成真实DOM. 生命周期生命周期指的是组件实例从创建到销毁的流程，函数组件没有生命周期，只有类组件才有，因为只有class组件会创建组件实例组件的生命周期可以分为挂载、更新、卸载阶段 挂载： constructor 可以进行state和props的初始化 static getDerivedStateFromProps render componentDidMount 第一次渲染后调用，可以访问DOM，进行异步请求和定时器、消息订阅 更新（当组件的props或state变化会触发更新） static getDerivedStateFromProps shouldComponentUpdate 返回一个布尔值，默认返回true，可以通过这个生命周期钩子进行性能优化，确认不需要更新组件时调用 render getSnapShotBeforeUpdate componentDidUpdate 在组件完成更新后调用 卸载 componentWillUnmount 组件从DOM中被移除的时候调用 错误捕获 static getDerivedStateFromError 在errorBoundary中使用 componentDidCatch React事件机制React基于浏览器的事件机制实现了一套自身的事件机制，它符合W3C规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等这么设计的目的： 在底层磨平不同浏览器的差异，React实现了统一的事件机制，我们不再需要处理浏览器事件机制方面的兼容问题 React把握了事件机制的主动权，实现了对所有事件的中心化管控 React引入事件池避免垃圾回收，在事件池中获取或释放事件对象，避免频繁的创建和销毁 DOM事件流事件在目标元素和祖先元素间的触发顺序。 捕获阶段：事件从最顶层元素 window 一直传递到目标元素的父元素。 目标阶段：事件到达目标元素，如果事件指定不冒泡，那就会在这里中止。 冒泡阶段：事件从目标元素父元素向上逐级传递直到最顶层元素 window。 事件绑定方式： 在html 中使用 onclick，或者在js中使用 btn.onclick() 使用addEventListener React实现事件的过程 绑定（建立合成事件与原生事件的对应关系） registrationNameModule, 它建立了React事件到plugin的映射，它包含React支持的所有事件的类型，用于判断一个组件的prop是否是事件类型 12345678910&#123; onBlur:SimpleEventPlugin, onClick:SimpleEventPlugin, onClickCapture:SimpleEventPlugin, onChange:ChangeEventPlugin, onChangeCapture:ChangeEventPlugin, onMouseEnter:EnterLeaveEventPlugin, onMouseLeave:EnterLeaveEventPlugin, ... &#125; registrationNameDependencies， 这个对象记录了React事件到原生事件的映射 12345678&#123; onBlur: [&apos;blur&apos;], onClick: [&apos;click&apos;], onClickCapture: [&apos;click&apos;], onChange: [&apos;blur&apos;, &apos;change&apos;, &apos;click&apos;, &apos;focus&apos;, &apos;input&apos;, &apos;keydown&apos;, &apos;keyup&apos;, &apos;selectionchange&apos;], onMouseEnter: [&apos;mouseout&apos;, &apos;mouseover&apos;], onMouseLeave: [&apos;mouseout&apos;, &apos;mouseover&apos;],&#125; plugins对象, 记录了所有注册的插件列表 1plugins = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...] 派发(针对同一个事件，即使可能存在多次回调，document（container）也只需要注册一次监听) React注册到document(container)上的并不是一个某个DOM节点具体的回调逻辑，而是一个统一的事件分发函数dispatchEvent - &gt; 事件委托思想 事件触发的本质是对dispatchEvent函数的调用 事件工作流程 事件触发，冒泡至document(container) 执行dispatchEvent 创建事件对应的合成事件对象（SyntheticEvent） 收集事件在捕获阶段所波及的回调函数和节点实例 收集事件在冒泡阶段所波及的回调函数和节点实例 将前两步收集来的回调按顺序执行，执行时（SyntheticEvent）会作为参数传进去。 React怎么阻止事件冒泡 阻止合成事件间的冒泡，用e.stopPropagation() 阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation() 阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免 函数组件，hooks和类class 类组件需要声明constructor，函数组件不需要 类组件需要手动绑定this，函数组件不需要 类组件有生命周期钩子，函数组件没有 类组件可以定义并维护自己的state，属于有状态组件，函数组件是无状态组件 类组件需要继承class，函数组件不需要 类组件使用的是面向对象的方法: 封装：组件属性和方法都封装在组件内部 继承:通过extends React.Component继承; 函数组件使用的是函数式编程思想 React hooks https://juejin.cn/post/7118937685653192735 优点： 告别难以理解的class组件 解决业务逻辑难以拆分的问题 使状态逻辑复用变的简单可行 函数组件从设计理念来看，更适合react 局限性： hooks还不能完整的为函数组件提供类组件的能力 函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求 Hooks 在使用层面有着严格的规则约束 组件的设计模式 https://juejin.cn/post/7007214462813863950 组合模式组合模式适合一些容器组件场景，通过外层组件包裹内层组件，外层组件可以轻松的获取内层组件的 props 状态，还可以控制内层组件的渲染，组合模式能够直观反映出 父 -&gt; 子组件的包含关系 12345&lt;Tabs onChange=&#123; (type)=&gt; console.log(type) &#125; &gt; &lt;TabItem name=\"react\" label=\"react\" &gt;React&lt;/TabItem&gt; &lt;TabItem name=\"vue\" label=\"vue\" &gt;Vue&lt;/TabItem&gt; &lt;TabItem name=\"angular\" label=\"angular\" &gt;Angular&lt;/TabItem&gt;&lt;/Tabs&gt; render props 模式render props 模式和组合模式类似。区别不同的是，用函数的形式代替 children。函数的参数，由容器组件提供，这样的好处，将容器组件的状态，提升到当前外层组件中。 12345678export default function App ()&#123; const aProps = &#123; name:'《React进阶实践指南》' &#125; return &lt;Container&gt; &#123;(cProps) =&gt; &lt;Children &#123;...cProps&#125; &#123; ...aProps &#125; /&gt;&#125; &lt;/Container&gt;&#125; HOChoc 高阶组件模式，高阶函数是接收一个函数，返回一个函数，而所谓高阶组件，就是接收一个组件，返回一个组件，返回的组件是根据需要对原始组件的强化。 HOC 本质是一个函数，传入 Component ，也就是原始组件本身。 返回一个新的包装的组件 Wrap ，我们可以在 Wrap 中做一些强化原始组件的事。 Wrap 中挂载原始组件本身 Component。12345678910function Hoc (Component)&#123; return class Wrap extends React.Component&#123; //--------- // 强化操作 //--------- render()&#123; return &lt;Component &#123; ...this.props &#125; /&gt; &#125; &#125;&#125; 提供者模式(Provider)React组件树 Root 节点，用 Provider 提供者注入 theme，然后在需要 theme的 地方，用 Consumer 消费者形式取出theme，供给组件渲染使用即可，这样减少很多无用功。用官网上的一句话形容就是Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 通过 Consumer 订阅 context 变化，context 变化， render children 函数重新执行。 render children 函数中第一个参数就是保存的 context 信息。123456function ThemeProvider()&#123; const theme = &#123; color:'pink' &#125; return &lt;ThemeContext.Provider value=&#123; theme &#125; &gt; &lt;Index /&gt; &lt;/ThemeContext.Provider&gt;&#125; 类组件继承继承模式的应用前提是，你需要知道被继承的组件是什么，内部都有什么状态和方法，对继承的组件内部的运转是透明的。接下来用一幅图表示继承模式原理。 React渲染流程和fiber性能优化 shouldComponentUpdate、pureComponent useMemo useCallback getDerviedStateFromProps 使用Fragment v-for/map使用正确的key 拆分尽可能小的可复用组件，ErrorBoundary 使用React.lazy和React.Suspense延迟加载不需要立马使用的组件 TypeScript Typescript是js的超集，为js提供了静态类型检查，在js的基础上引入了面向对象的一些概念：类、接口、继承、范型。ts提供了类型注解、类型推断，在编译时就能保证类型的正确。 泛型 泛型是提供创建可重用组件的方法的工具，使用传参的形式将类型传递给函数或者接口，并在使用时指定具体的类型。 联合类型和交叉类型 交叉类型：将多个类型合并成一个类型，新类型将具有多个类型的所有特性。&amp; 联合类型：表示一个值可以有多种类型的之一。｜ type&amp;&amp;interface 相同点： 都可以描述一个对象或者函数类型 都允许extends，并且可以互相扩展 不同点： type 可以声明基本类型别名、联合类型、元组类型 type 支持typeof获取实例的类型进行赋值 interface 可以声明合并（交叉） any 和 unknown 有什么区别 any和unknown都能在不能确定变量类型的时候使用，unknown更加严格，any直接不做类型检查。 任何类型的数据都可以赋给 unknown 类型，unknown 类型的值也不能将值赋给 any 和 unknown 之外的类型变量 unknown类型的值不能确定内部属性。 never和void的区别 void表示没有任何类型（可以赋值为null和undefind） never表示一个不包含值的类型，never类型的变量永远不存在值 拥有void返回值的函数可以正常运行，拥有never返回值的函数无法正常返回。 断言和类型推断 类型推断：Typescript允许编译器根据上下文自动推断出变量的类型，从而减少手动类型输入的工作量。 类型断言：类似于类型强制转换，它建议编译器忽略自动推断，将变量强制视为某种类型。 常用内置函数及手动实现 keyof关键字，用于获取对象类型的所有键的联合类型 Partial 生成一个新的对象类型，属性全部变成可选的 123type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;; Required 将一个对象类型中的所有属性变为必需的。 123type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P];&#125;; Readonly 将类型中的所有属性都变成只读的 123type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;; Record&lt;K, T&gt; 创建一个新的对象类型，指定对象属性名类型和属性值类型。其属性名类型为 K，属性值类型为 T 123type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T;&#125;; Pick&lt;T, K&gt; 从类型中选择指定的属性，并返回一个新的对象类型：Pick&lt;Person, ‘name’ | ‘age’&gt; 123type Pick&lt;SourceType, KeysType extends keyof SourceType&gt; = &#123; [KeyType in KeysType]: SourceType[KeyType];&#125;; Omit&lt;T, K&gt; 创建新的类型，可以从一个类型中省略指定的属性。 1234567const omit = &lt;T, K extends keyof T&gt;(obj: T, ...keys: K[]): Omit&lt;T, K&gt; =&gt; &#123;const result = &#123; ...obj &#125;;keys.forEach((key) =&gt; &#123; delete result[key]; &#125;); return result;&#125; 装饰器&amp;&amp;类型守卫 装饰器是一种特殊的语法，它可以用来修饰类、方法、属性以及参数等元素，在ts中用@开头声明装饰器 类型守卫是判断类型的一种方法，常见的方法包括：instanceof、typeof、in操作符等，也可以自定义函数实现类型判断。 Futrue微前端 样式隔离 https://blog.csdn.net/qiwoo_weekly/article/details/127399589 manifest.json web components vite&amp;&amp;gulp","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"现代CSS解决方案：原生支持的三角函数","slug":"2023/现代CSS解决方案：原生支持的三角函数","date":"2023-08-25T06:11:48.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2023/现代CSS解决方案：原生支持的三角函数/","link":"","permalink":"https://summxu.github.io/2023/现代CSS解决方案：原生支持的三角函数/","excerpt":"","text":"CSS 三角函数语法介绍首先看看 CSS 三角函数的使用方式： 12345678910111213.box &#123; /* 设置元素的宽度为 sin(30deg) 的值 */ width: calc(sin(30deg) * 100px); /* 反正弦 根据弧度值返回对应的角度值 */ transform: rotate(asin(-0.2)); /* 设置元素的高度为 cos(45deg) 的值 */ height: calc(cos(45deg) * 100%); /* 设置元素的透明度为 tan(60deg) 的值 */ opacity: calc(tan(60deg));&#125; 上述代码中，使用了 calc() 函数进行了计算，然后通过 sin()、cos() 和 tan() 函数对计算结果进行了进一步的处理，从而实现了不同的效果。 三角函数在 CSS3 中仅对弧度（radian）单位进行支持。如果想要在开发中使用三角函数，可以借助转换函数 deg() 和 rad() 将角度（degree）和弧度进行转换。 CSS3 的这些函数使得开发者可以更加方便处理一些复杂的数学问题，增强了 CSS 的表现力。 三角函数的运动轨迹三角函数的运用，可以体现在动画当中。以正弦、余弦函数为例，代码如下： 12345678910111213141516171819202122232425262728293031323334@property --angle &#123; syntax: '&lt;angle&gt;'; inherits: false; initial-value: 0deg;&#125;@property --dis &#123; syntax: '&lt;length&gt;'; inherits: false; initial-value: 0px;&#125;.g-single &#123; background: #000; margin: auto; width: 20px; height: 20px; border-radius: 50%; animation: move 5s infinite ease-in-out; transform: translate(calc(var(--dis) - 40vw), calc(5 * sin(var(--angle)) * 1em));&#125;@keyframes move &#123; 0% &#123; --dis: 0px; --angle: 0deg; &#125; 100% &#123; --dis: 80vw; --angle: 1080deg; &#125;&#125; 上述的核心在于这一段代码 -- transform: translate(calc(var(--dis) - 40vw), calc(5 * sin(var(--angle)) * 1em))内部使用了两个 CSS @property 变量： x 轴方向是 0px 到 80vw 的水平位移动画 y 轴方向是 5 * sin(0deg) * 1em 到 5 * sin(1080deg) * 1em 的竖直动画 通过动画，动态的修改这两个变量的值，就可以得到一个三角函数曲线动画图形： CSS 钟表钟表上1-12折12个数字按照圆形等间距排布，也是CSS三角函数的典型应用。 排版定位的相关代码： 1234567891011121314151617181920212223.clock-face time &#123; --x: calc(var(--radius) + (var(--radius) * cos(var(--index) * 30deg))); --y: calc(var(--radius) + (var(--radius) * sin(var(--index) * 30deg))); display: grid; place-content: center; height: 2em; width: 2em; position: absolute; left: var(--x); top: var(--y);&#125;.clock-face time:nth-child(1) &#123; --index: 9; &#125;.clock-face time:nth-child(2) &#123; --index: 10; &#125;.clock-face time:nth-child(3) &#123; --index: 11; &#125;.clock-face time:nth-child(4) &#123; --index: 0; &#125;.clock-face time:nth-child(5) &#123; --index: 1; &#125;.clock-face time:nth-child(6) &#123; --index: 2; &#125;.clock-face time:nth-child(7) &#123; --index: 3; &#125;.clock-face time:nth-child(8) &#123; --index: 4; &#125;.clock-face time:nth-child(9) &#123; --index: 5; &#125;.clock-face time:nth-child(10) &#123; --index: 6; &#125;.clock-face time:nth-child(11) &#123; --index: 7; &#125;.clock-face time:nth-child(12) &#123; --index: 8; &#125; 实现的效果（完整的代码可以查看一下iframe的源代码信息）： CSS 数学函数 sqrt() 求平方根 pow() 幂指数 exp() 自然常数e为底的指数函数 log() 对数函数 abs() 绝对值 round() 四舍五入 sign() 正负零判断 …. 总结CSS 原生支持的三角函数，给 CSS 打开了更多的可能性，这也导致 CSS 的复杂度也是愈来愈高，CSS 已经不再是非常纯粹的负责样式了，很多时候，很多计算也可以直接在 CSS 当中完成。至于好坏，或许已经成了一个哲学问题。 记录两个css项目，第二个相当炸裂： css-doodle css-fps-demo","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}]},{"title":"Pinia使用和源码解析","slug":"2023/Pinia使用和源码解析","date":"2023-06-26T01:36:37.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2023/Pinia使用和源码解析/","link":"","permalink":"https://summxu.github.io/2023/Pinia使用和源码解析/","excerpt":"","text":"创建pinia基本使用 123456789101112131415const pinia = createPinia()const app = createApp(App)app.use(pinia)app.mount('#app')//vue2 使用import &#123; createPinia, PiniaVuePlugin &#125; from 'pinia'Vue.use(PiniaVuePlugin)const pinia = createPinia()new Vue(&#123; el: '#app', pinia,&#125;) createPinia 将pinia绑定到实例上 创建一个scope用来保存之后创建的每一个store的state，也可以直接通过pinia.state.value[storeId]直接设置state 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//ceatePinia.tsexport function createPinia(): Pinia &#123; // 创建个scope effct来单独管理state const scope = effectScope(true) // 通过pinia.state.value[storeId]会保存之后创建的store的state const state = scope.run&lt;Ref&lt;Record&lt;string, StateTree&gt;&gt;&gt;(() =&gt; ref&lt;Record&lt;string, StateTree&gt;&gt;(&#123;&#125;) )! // 插件相关 let _p: Pinia['_p'] = [] // plugins added before calling app.use(pinia) let toBeInstalled: PiniaPlugin[] = [] // markRaw标记pinia不可被代理,避免存在用户将其响应式化影响性能的情况 const pinia: Pinia = markRaw(&#123; install(app: App) &#123; // 设置当前活跃的pinia，方便其他地方获取 setActivePinia(pinia) if (!isVue2) &#123; pinia._a = app // 内部通过inject获取pinia,因为piniaSymbol没有导出，所以开发者无法通过inject获取pinia app.provide(piniaSymbol, pinia) // 通过app.config.globalProperties将pinia挂载到组件实例上 app.config.globalProperties.$pinia = pinia if (USE_DEVTOOLS) &#123; registerPiniaDevtools(app, pinia) &#125; toBeInstalled.forEach((plugin) =&gt; _p.push(plugin)) toBeInstalled = [] &#125; &#125;, // pinia插件相关，暂不分析 use(plugin) &#123; if (!this._a &amp;&amp; !isVue2) &#123; toBeInstalled.push(plugin) &#125; else &#123; _p.push(plugin) &#125; return this &#125;, _p, // it's actually undefined here // @ts-expect-error _a: null, _e: scope, // 每个创建的store都会放在这个Map里 _s: new Map&lt;string, StoreGeneric&gt;(), state, &#125;) //... return pinia&#125; 设置、获取pinia pinia会被保存到一个全局变量上，内部可以通过setActivePinia、getActivePinia快速获取到pinia，然后使用上一步挂在pinia上的属性或方法 12345678910//rootStore.tsexport let activePinia: Pinia | undefinedexport const setActivePinia = (pinia: Pinia | undefined) =&gt; (activePinia = pinia) // 如果在vue组件中，通过inject获取（在createPinia中导出）、否则直接取全局变量 export const getActivePinia = () =&gt; (getCurrentInstance() &amp;&amp; inject(piniaSymbol)) || activePinia 兼容vue2 看过vuex的这段应该很熟悉 通过Object.defineProperty仿造了个Provide功能 通过mixins将pinia注入到每一个组件中 PiniaVuePlugin 12345678910111213141516171819202122232425262728293031323334353637383940//vue2-plugin.tsexport const PiniaVuePlugin: Plugin = function (_Vue) &#123; _Vue.mixin(&#123; beforeCreate() &#123; const options = this.$options if (options.pinia) &#123; // 获取注册到根组件上的pinia const pinia = options.pinia as Pinia // 通过Object.defineProperty实现的hack版provid、inject... if (!(this as any)._provided) &#123; const provideCache = &#123;&#125; Object.defineProperty(this, '_provided', &#123; get: () =&gt; provideCache, set: (v) =&gt; Object.assign(provideCache, v), &#125;) &#125; ;(this as any)._provided[piniaSymbol as any] = pinia if (!this.$pinia) &#123; this.$pinia = pinia &#125; pinia._a = this as any if (IS_CLIENT) &#123; // this allows calling useStore() outside of a component setup after // installing pinia's plugin setActivePinia(pinia) &#125; if (USE_DEVTOOLS) &#123; registerPiniaDevtools(pinia._a, pinia) &#125; &#125; else if (!this.$pinia &amp;&amp; options.parent &amp;&amp; options.parent.$pinia) &#123; this.$pinia = options.parent.$pinia &#125; &#125;, destroyed() &#123; delete this._pStores &#125;, &#125;)&#125; 创建store创建store的三种方式 123456789101112131415161718192021222324252627282930313233const useUserStore = defineStore('counter', &#123; state: () =&gt; (&#123; count: 0 &#125;), actions: &#123; increment() &#123; this.count++ &#125; &#125;&#125;)// orconst useUserStore = defineStore(&#123; id: 'counter', state: () =&gt; (&#123; count: 0 &#125;), actions: &#123; increment() &#123; this.count++ &#125; &#125;&#125;)// orconst useUserStore = defineStore('counter', () =&gt; &#123; const count = ref(0) function increment() &#123; count.value++ &#125; return &#123; count, increment &#125;&#125;) defineStore 主要根据defineStore的不同方式选择调用函数式createSetupStore还是选项式createOptionsStore 创建好的store会根据defineStore时传入的id，挂载到pinia._s这个map上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596export function defineStore( // TODO: add proper types from above idOrOptions: any, setup?: any, setupOptions?: any): StoreDefinition &#123; let id: string let options const isSetupStore = typeof setup === 'function' // 抹平不同格式参数 if (typeof idOrOptions === 'string') &#123; id = idOrOptions options = isSetupStore ? setupOptions : setup &#125; else &#123; options = idOrOptions id = idOrOptions.id &#125; // 最终交给开发者获取store的方法 function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric &#123; const currentInstance = getCurrentInstance() // 如果存在currentInstance说明在vue组件中，通过inject获取到pinia pinia = (__TEST__ &amp;&amp; activePinia &amp;&amp; activePinia._testing ? null : pinia) || (currentInstance &amp;&amp; inject(piniaSymbol, null)) //设置当前活跃的pinia对象，如果存在多个pinia对象，方便快速获取当前pinia对象 if (pinia) setActivePinia(pinia) if (__DEV__ &amp;&amp; !activePinia) &#123; throw new Error( `[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\\n` + `\\tconst pinia = createPinia()\\n` + `\\tapp.use(pinia)\\n` + `This will fail in production.` ) &#125; // 从rootStore文件中取的全局变量 pinia = activePinia! // 如果没有创建过id对应的store,则会调用createSetupStore或createOptionsStore进行创建 if (!pinia._s.has(id)) &#123; // 区分第二个参数是函数还是options对象 if (isSetupStore) &#123; createSetupStore(id, setup, options, pinia) &#125; else &#123; createOptionsStore(id, options as any, pinia) &#125; /* istanbul ignore else */ if (__DEV__) &#123; // @ts-expect-error: not the right inferred type useStore._pinia = pinia &#125; &#125; // 获取上面创建好的store，pinia._s是一个Map结构 const store: StoreGeneric = pinia._s.get(id)! // 热更新相关,重新创建更新store if (__DEV__ &amp;&amp; hot) &#123; const hotId = '__hot:' + id const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign(&#123;&#125;, options) as any, pinia, true) hot._hotUpdate(newStore) // cleanup the state properties and the store from the cache delete pinia.state.value[hotId] pinia._s.delete(hotId) &#125; // 往当前组件实例上缓存store，主要是给devtools使用 if ( __DEV__ &amp;&amp; IS_CLIENT &amp;&amp; currentInstance &amp;&amp; currentInstance.proxy &amp;&amp; // avoid adding stores that are just built for hot module replacement !hot ) &#123; const vm = currentInstance.proxy const cache = '_pStores' in vm ? vm._pStores! : (vm._pStores = &#123;&#125;) cache[id] = store &#125; // StoreGeneric cannot be casted towards Store return store as any &#125; useStore.$id = id return useStore&#125; createSetupStore如果defineStore传入的是一个setup函数，则会调用此方法创建store 响应式处理store store -&gt; reactive(store) pinia.state.value[storeId]初始化，state会往pinia上存一份和在store上存一份 将store注册到pinia._s这个Map上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function createSetupStore( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean)&#123;let scope!: EffectScope //为setup函数返回的内容单独建立一个scopeif (__DEV__ &amp;&amp; !pinia._e.active) &#123; //pinia._e为创建pinia时建立的scope throw new Error('Pinia destroyed') &#125;const initialState = pinia.state.value[$id] as UnwrapRef&lt;S&gt; | undefined// 如果pinia.state.value[storeId]未初始化，进行初始化if (!isOptionsStore &amp;&amp; !initialState &amp;&amp; (!__DEV__ || !hot)) &#123; if (isVue2) &#123; set(pinia.state.value, $id, &#123;&#125;) &#125; else &#123; pinia.state.value[$id] = &#123;&#125; &#125;&#125;//...// 对外暴露的store内容const partialStore = &#123; _p: pinia, // _s: scope, $id, // 调用$onAction会将回调加入到actionSubscriptions中,wrapAction内会触发回调 $onAction: addSubscription.bind(null, actionSubscriptions), $patch, $reset, $subscribe(callback, options = &#123;&#125;) &#123; const removeSubscription = addSubscription( subscriptions, callback, options.detached, () =&gt; stopWatcher() ) // 监听state直接修改 const stopWatcher = scope.run(() =&gt; watch( () =&gt; pinia.state.value[$id] as UnwrapRef&lt;S&gt;, (state) =&gt; &#123; // flush默认为'pre',而在调用$patch时isListening会被设置为false,所以不会触发$patch修改state的监听回调 if (options.flush === 'sync' ? isSyncListening : isListening) &#123; callback( &#123; storeId: $id, type: MutationType.direct, events: debuggerEvents as DebuggerEvent, &#125;, state ) &#125; &#125;, assign(&#123;&#125;, $subscribeOptions, options) ) )! return removeSubscription &#125;, $dispose,&#125; as _StoreWithState&lt;Id, S, G, A&gt;// 返回的store是个reactive对象const store: Store&lt;Id, S, G, A&gt; = reactive( __DEV__ || USE_DEVTOOLS ? assign( &#123; _hmrPayload, _customProperties: markRaw(new Set&lt;string&gt;()), // devtools custom properties &#125;, partialStore // must be added later // setupStore ) : partialStore) as unknown as Store&lt;Id, S, G, A&gt;// 将store注册到pinia上pinia._s.set($id, store)&#125; 处理setup返回的内容 12345678910111213141516171819 function createSetupStore( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean)&#123; // ... // 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect const setupStore = pinia._e.run(() =&gt; &#123; scope = effectScope() return scope.run(() =&gt; setup()) &#125;)! // ...&#125; 同步setup返回内容和pinia.state 因为state会在store上存一份，也会在pinia.state.value[storeId]上存一份，所以为了保证两边都是同一个代理对象，需要进行同步 使用者可以直接通过pinia.state.value设置store内容，所以直接设置的内容也需要同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 function createSetupStore( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean)&#123; // ... // 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effectconst setupStore = pinia._e.run(() =&gt; &#123; scope = effectScope() return scope.run(() =&gt; setup())&#125;)!for (const key in setupStore) &#123; const prop = setupStore[key] // 只处理ref、reactive对象，computed等不处理 if ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123; // mark it as a piece of state to be serialized if (__DEV__ &amp;&amp; hot) &#123; // 热更新相关，忽略 set(hotState.value, key, toRef(setupStore as any, key)) // option结构已经在createOptionsStore将其加入pinia &#125; else if (!isOptionsStore) &#123;// 同步pinia.state -&gt; store // 将用户可能直接调用pinia.state.value[$id]设置的ref、reactive对象设置到setup返回的结果上,让二者的响应式都代理一个对象 // 使得store、pinia能同步更改 if (initialState &amp;&amp; shouldHydrate(prop)) &#123; if (isRef(prop)) &#123; prop.value = initialState[key] &#125; else &#123; // probably a reactive object, lets recursively assign // 同步其他类型 mergeReactiveObjects(prop, initialState[key]) &#125; &#125; // transfer the ref to the pinia state to keep everything in sync // 将setup返回的ref、reactive对象同步到pinia.state上，使得store、pinia能同步更改 if (isVue2) &#123; //同步 store -&gt; pinia.state set(pinia.state.value[$id], key, prop) &#125; else &#123; pinia.state.value[$id][key] = prop &#125; &#125; &#125;&#125;// 合并方法function mergeReactiveObjects&lt; T extends Record&lt;any, unknown&gt; | Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;&gt;(target: T, patchToApply: _DeepPartial&lt;T&gt;): T &#123; // 合并Map类型 if (target instanceof Map &amp;&amp; patchToApply instanceof Map) &#123; patchToApply.forEach((value, key) =&gt; target.set(key, value)) &#125; // 合并Set类型 if (target instanceof Set &amp;&amp; patchToApply instanceof Set) &#123; patchToApply.forEach(target.add, target) &#125; for (const key in patchToApply) &#123; if (!patchToApply.hasOwnProperty(key)) continue const subPatch = patchToApply[key] const targetValue = target[key] // 只有普通对象才会进入递归 if ( isPlainObject(targetValue) &amp;&amp; isPlainObject(subPatch) &amp;&amp; target.hasOwnProperty(key) &amp;&amp; !isRef(subPatch) &amp;&amp; !isReactive(subPatch) ) &#123; target[key] = mergeReactiveObjects(targetValue, subPatch) &#125; else &#123; target[key] = subPatch &#125; &#125; return target&#125; 处理action 将action替换成wrapAction，wrapAction添加了订阅发布相关的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 function createSetupStore( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean)&#123; // ... // 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effectconst setupStore = pinia._e.run(() =&gt; &#123; scope = effectScope() return scope.run(() =&gt; setup())&#125;)!for (const key in setupStore) &#123; const prop = setupStore[key] // 只处理ref、reactive对象，computed等不处理 if ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123; // ... &#125; else if (typeof prop === 'function') &#123; // 将setup中的方法替换成wrapAction包装的方法，wrapAction在订阅发布章节解析 const actionValue = __DEV__ &amp;&amp; hot ? prop : wrapAction(key, prop) if (isVue2) &#123; set(setupStore, key, actionValue) &#125; else &#123; // @ts-expect-error setupStore[key] = actionValue &#125; /* istanbul ignore else */ if (__DEV__) &#123; _hmrPayload.actions[key] = prop &#125; // list actions so they can be used in plugins // @ts-expect-error optionsForPlugin.actions[key] = prop &#125; &#125;&#125; 处理store合并setup 12345678910111213141516171819202122232425262728293031323334353637383940 function createSetupStore( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean)&#123;// ...// 对外暴露的store APIconst partialStore = &#123;//...&#125;const store: Store&lt;Id, S, G, A&gt; = reactive(//...partialStore)// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effectconst setupStore = pinia._e.run(() =&gt; &#123;scope = effectScope()return scope.run(() =&gt; setup())&#125;)!for (const key in setupStore) &#123;// ...&#125; // 将最同步后的结果，合并进store上 if (isVue2) &#123; Object.keys(setupStore).forEach((key) =&gt; &#123; set(store, key, setupStore[key]) &#125;) &#125; else &#123; // 将store的reactive对象、原始对象都进行合并 assign(store, setupStore) assign(toRaw(store), setupStore) &#125;&#125; createOptionsStore当传入的是option配置时，则会调用此方法创建store createSetupStore内部会将option转换成setup方法，然后实际调用createSetupStore进行创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function createOptionsStore&lt; Id extends string, S extends StateTree, G extends _GettersTree&lt;S&gt;, A extends _ActionsTree&gt;( id: Id, options: DefineStoreOptions&lt;Id, S, G, A&gt;, pinia: Pinia, hot?: boolean): Store&lt;Id, S, G, A&gt; &#123; const &#123; state, actions, getters &#125; = options const initialState: StateTree | undefined = pinia.state.value[id] let store: Store&lt;Id, S, G, A&gt; // 将options转化成setup函数 function setup() &#123; // 初始化pinia.state if (!initialState &amp;&amp; (!__DEV__ || !hot)) &#123; if (isVue2) &#123; set(pinia.state.value, id, state ? state() : &#123;&#125;) &#125; else &#123; pinia.state.value[id] = state ? state() : &#123;&#125; &#125; &#125; // 将pinia.state全部转换成ref，和setup中返回ref效果一致 const localState = __DEV__ &amp;&amp; hot ? // use ref() to unwrap refs inside state TODO: check if this is still necessary toRefs(ref(state ? state() : &#123;&#125;).value) : toRefs(pinia.state.value[id]) // 最终options store返回的内容格式和setup store返回的内容格式一致 return assign( localState, actions, // 将 getter 转换成 computed Object.keys(getters || &#123;&#125;).reduce((computedGetters, name) =&gt; &#123; if (__DEV__ &amp;&amp; name in localState) &#123; console.warn( `[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"$&#123;name&#125;\" in store \"$&#123;id&#125;\".` ) &#125;// getter函数不可代理，及不对computed做额外处理，和setup中一致 computedGetters[name] = markRaw( computed(() =&gt; &#123; setActivePinia(pinia) // it was created just before const store = pinia._s.get(id)! // allow cross using stores if (isVue2 &amp;&amp; !store._r) return // @ts-expect-error // return getters![name].call(context, context) return getters![name].call(store, store) &#125;) ) return computedGetters &#125;, &#123;&#125; as Record&lt;string, ComputedRef&gt;) ) &#125; // option选项注册的pinia会被转换成setup函数形式 store = createSetupStore(id, setup, options, pinia, hot, true) store.$reset = function $reset() &#123; const newState = state ? state() : &#123;&#125; // we use a patch to group all changes into one single subscription this.$patch(($state) =&gt; &#123; assign($state, newState) &#125;) &#125; return store as any&#125; 订阅发布pinia能够对修改state、action进行监听，内部通过发布订阅模式、watch API实现 发布订阅模式 将存储订阅器的功能和整个设计解藕，交给外部来传入，好处是能够处理不同类型的发布订阅 1234567891011121314151617181920212223242526272829303132//subscriptions.tsexport function addSubscription&lt;T extends _Method&gt;( subscriptions: T[], //外部传入存储器 callback: T, detached?: boolean, // 是否在组件卸载时清除订阅 onCleanup: () =&gt; void = noop) &#123; subscriptions.push(callback) // 清除订阅 const removeSubscription = () =&gt; &#123; const idx = subscriptions.indexOf(callback) if (idx &gt; -1) &#123; subscriptions.splice(idx, 1) onCleanup() &#125; &#125; // 如果没传detached,则会自动在组件卸载时清除订阅 if (!detached &amp;&amp; getCurrentScope()) &#123; onScopeDispose(removeSubscription) &#125; return removeSubscription&#125;export function triggerSubscriptions&lt;T extends _Method&gt;( subscriptions: T[], ...args: Parameters&lt;T&gt;) &#123; subscriptions.slice().forEach((callback) =&gt; &#123; callback(...args) &#125;)&#125; 监听action 基本使用 12345678910111213141516171819202122232425262728293031const unsubscribe = someStore.$onAction( (&#123; name, // action 名称 store, // store 实例，类似 `someStore` args, // 传递给 action 的参数数组 after, // 在 action 返回或解决后的钩子 onError, // action 抛出或拒绝的钩子 &#125;) =&gt; &#123; // 这将在执行 \"store \"的 action 之前触发。 console.log(`xx`) // 这将在 action 成功并完全运行后触发。它等待着任何返回的 promise after((result) =&gt; &#123; console.log( `Finished \"$&#123;name&#125;\" after $&#123; Date.now() - startTime &#125;ms.\\nResult: $&#123;result&#125;.` ) &#125;) // 如果 action 抛出或返回一个拒绝的 promise，这将触发 onError((error) =&gt; &#123; console.warn( `Failed \"$&#123;name&#125;\" after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.` ) &#125;) &#125;)// 手动删除监听器unsubscribe() 通过$onAction添加订阅123456789101112131415161718192021222324252627282930313233function createSetupStore&lt; Id extends string, SS extends Record&lt;any, unknown&gt;, S extends StateTree, G extends Record&lt;string, _Method&gt;, A extends _ActionsTree&gt;( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean): Store&lt;Id, S, G, A&gt; &#123;// ...// 对外暴露的store内容const partialStore = &#123; _p: pinia, // _s: scope, $id, // 调用$onAction会将回调加入到actionSubscriptions中,调用wrapAction内会触发回调 $onAction: addSubscription.bind(null, actionSubscriptions), $patch, $reset, $subscribe(callback, options = &#123;&#125;) &#123; // ... &#125;, $dispose,&#125; as _StoreWithState&lt;Id, S, G, A&gt;// ...&#125; 通过wrapAction进行发布 setup、option中的方法，会被替换成wrapAction 当调用wrapAction时，会触发actionSubscriptions、afterCallbackList或onErrorCallbackList中的回调 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function createSetupStore&lt; Id extends string, SS extends Record&lt;any, unknown&gt;, S extends StateTree, G extends Record&lt;string, _Method&gt;, A extends _ActionsTree&gt;( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean): Store&lt;Id, S, G, A&gt; &#123;// ...// internal statelet isListening: boolean // 异步监听let isSyncListening: boolean // 同步监听let subscriptions: SubscriptionCallback&lt;S&gt;[] = markRaw([]) // 监听state的订阅集合let actionSubscriptions: StoreOnActionListener&lt;Id, S, G, A&gt;[] = markRaw([]) // 监听action的订阅集合// ...// 包装action调用，追加发布订阅功能function wrapAction(name: string, action: _Method) &#123; return function (this: any) &#123; // 根据闭包上下文，调用时设置当前活跃的pinia setActivePinia(pinia) const args = Array.from(arguments) // 调用action后回调集合 const afterCallbackList: Array&lt;(resolvedReturn: any) =&gt; any&gt; = [] const onErrorCallbackList: Array&lt;(error: unknown) =&gt; unknown&gt; = [] function after(callback: _ArrayType&lt;typeof afterCallbackList&gt;) &#123; afterCallbackList.push(callback) &#125; function onError(callback: _ArrayType&lt;typeof onErrorCallbackList&gt;) &#123; onErrorCallbackList.push(callback) &#125; // 触发action时的回调，同时将after等方法通过参数传入 triggerSubscriptions(actionSubscriptions, &#123; args, name, store, after, onError, &#125;) let ret: any try &#123; ret = action.apply(this &amp;&amp; this.$id === $id ? this : store, args) &#125; catch (error) &#123; // 处理同步错误 triggerSubscriptions(onErrorCallbackList, error) throw error &#125; // 如果是异步方法 if (ret instanceof Promise) &#123; return ret .then((value) =&gt; &#123; // 获取到action调用结果后触发 triggerSubscriptions(afterCallbackList, value) return value &#125;) .catch((error) =&gt; &#123; triggerSubscriptions(onErrorCallbackList, error) return Promise.reject(error) &#125;) &#125; // allow the afterCallback to override the return value triggerSubscriptions(afterCallbackList, ret) return ret &#125;&#125;&#125; 监听修改state修改state有两种方式，一种通过store.state直接修改然后通过watch API进行监听，另一种通过$patch进行批量修改，通过$patch进行批量修改时，为了只触发一次回调需要手动触发 基本使用 12345678910cartStore.$subscribe((mutation, state) =&gt; &#123; // import &#123; MutationType &#125; from 'pinia' mutation.type // 'direct' | 'patch object' | 'patch function' // 和 cartStore.$id 一样 mutation.storeId // 'cart' // 只有 mutation.type === 'patch object'的情况下才可用 mutation.payload // 传递给 cartStore.$patch() 的补丁对象。 // ...&#125;) 直接修改state $subscribe监听state直接修改，内部通过watch API实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function createSetupStore&lt; Id extends string, SS extends Record&lt;any, unknown&gt;, S extends StateTree, G extends Record&lt;string, _Method&gt;, A extends _ActionsTree&gt;( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean): Store&lt;Id, S, G, A&gt; &#123;// internal statelet isListening: boolean // set to true at the endlet isSyncListening: boolean // set to true at the end// ...// 对外暴露的store内容const partialStore = &#123; _p: pinia, // _s: scope, $id, // 调用$onAction会将回调加入到actionSubscriptions中,调用wrapAction内会触发回调 $onAction: addSubscription.bind(null, actionSubscriptions), $patch, $reset, $subscribe(callback, options = &#123;&#125;) &#123; // 使用者调用后将订阅回调添加进subscriptionsconst removeSubscription = addSubscription( subscriptions, callback, options.detached, () =&gt; stopWatcher()) // 通过watch监听store.state直接修改const stopWatcher = scope.run(() =&gt; watch( () =&gt; pinia.state.value[$id] as UnwrapRef&lt;S&gt;, (state) =&gt; &#123; // flush默认为'pre',而在调用$patch时isListening会被设置为false,所以不会触发$patch修改state的监听回调 // 但对于store.state直接修改的情况，store在创建完成后isSyncListening和isListening都会变成true，所以能够监听 if (options.flush === 'sync' ? isSyncListening : isListening) &#123; callback( &#123; storeId: $id, type: MutationType.direct, // type为direct直接修改 events: debuggerEvents as DebuggerEvent, &#125;, state ) &#125; &#125;, assign(&#123;&#125;, $subscribeOptions, options) ))!return removeSubscription &#125;, $dispose,&#125; as _StoreWithState&lt;Id, S, G, A&gt;// ...// 整个store创建结束后将两个监听标识为true,意味着store创建完成,可以进行监听订阅操作isListening = trueisSyncListening = truereturn store&#125; $patch修改 $patch用于批量修改state，内部主要通过两个标识位的修改，不触发watch监听回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function createSetupStore&lt; Id extends string, SS extends Record&lt;any, unknown&gt;, S extends StateTree, G extends Record&lt;string, _Method&gt;, A extends _ActionsTree&gt;( $id: Id, setup: () =&gt; SS, options: | DefineSetupStoreOptions&lt;Id, S, G, A&gt; | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;, pinia: Pinia, hot?: boolean, isOptionsStore?: boolean): Store&lt;Id, S, G, A&gt; &#123;// internal statelet isListening: boolean // set to true at the endlet isSyncListening: boolean // set to true at the end// ...function $patch( partialStateOrMutator: | _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt; | ((state: UnwrapRef&lt;S&gt;) =&gt; void)): void &#123; // 订阅$patch操作type let subscriptionMutation: SubscriptionCallbackMutation&lt;S&gt; // 避免批量修改触发$subscribe isListening = isSyncListening = false if (__DEV__) &#123; debuggerEvents = [] &#125; // 兼容$patch传递函数、对象调用的两种调用方式 if (typeof partialStateOrMutator === 'function') &#123; partialStateOrMutator(pinia.state.value[$id] as UnwrapRef&lt;S&gt;) subscriptionMutation = &#123; type: MutationType.patchFunction, // type类型 storeId: $id, events: debuggerEvents as DebuggerEvent[], &#125; &#125; else &#123; // $patch传递对象走合并流程 mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator) subscriptionMutation = &#123; type: MutationType.patchObject, // type类型 payload: partialStateOrMutator, storeId: $id, events: debuggerEvents as DebuggerEvent[], &#125; &#125; const myListenerId = (activeListener = Symbol()) // 对于异步修改情况，异步还原isListening,让$subscribe不会监听通过$patch修改state nextTick().then(() =&gt; &#123; if (activeListener === myListenerId) &#123; isListening = true &#125; &#125;) isSyncListening = true // 手动触发订阅,实现通过$patch批量修改state只触发一次订阅回调 triggerSubscriptions( subscriptions, subscriptionMutation, pinia.state.value[$id] as UnwrapRef&lt;S&gt; )&#125;// ...// 整个store创建结束后将两个监听标识为true,意味着store创建完成,可以进行监听订阅操作isListening = trueisSyncListening = truereturn store&#125; store API $reset 对于options store提供的还原初始状态的API 1234567891011121314151617// options storestore.$reset = function $reset() &#123; const newState = state ? state() : &#123;&#125; // state为options中的state // 通过$patch批量修改 this.$patch(($state) =&gt; &#123; assign($state, newState) &#125;)&#125;// setup storeconst $reset = __DEV__ // 开发环境下会报错 ? () =&gt; &#123; throw new Error( `🍍: Store \"$&#123;$id&#125;\" is built using the setup syntax and does not implement $reset().` ) &#125; : noop $dispose 卸载store的API 1234567// 卸载storefunction $dispose() &#123; scope.stop() //卸载store的scope effect subscriptions = [] actionSubscriptions = [] pinia._s.delete($id) // 从pinia上删除掉对应的store&#125; storeToRefs解构store通过storeToRefs使得解构store也不会丢失响应式 基本使用 1234567891011121314151617181920212223242526272829303132333435363738394041export default defineComponent(&#123; setup() &#123; const store = useCounterStore() // ❌ 这将无法生效，因为它破坏了响应性 // 这与从 `props` 中解构是一样的。 const &#123; name, doubleCount &#125; = store name // \"eduardo\" doubleCount // 2 return &#123; // 始终是 \"eduardo\" name, // 始终是 2 doubleCount, // 这个将是响应式的 doubleValue: computed(() =&gt; store.doubleCount), &#125; &#125;,&#125;)// 通过storeToRefs调用import &#123; storeToRefs &#125; from 'pinia'export default defineComponent(&#123; setup() &#123; const store = useCounterStore() // `name` and `doubleCount` 都是响应式 refs // 这也将为由插件添加的属性创建 refs // 同时会跳过任何 action 或非响应式(非 ref/响应式)属性 const &#123; name, doubleCount &#125; = storeToRefs(store) // 名为 increment 的 action 可以直接提取 const &#123; increment &#125; = store return &#123; name, doubleCount, increment, &#125; &#125;,&#125;) storeToRefs 类似toRefs，但会跳过方法和非响应式属性 1234567891011121314151617181920212223242526272829303132// storeToRefs.tsexport function storeToRefs&lt;SS extends StoreGeneric&gt;( store: SS): ToRefs&lt; StoreState&lt;SS&gt; &amp; StoreGetters&lt;SS&gt; &amp; PiniaCustomStateProperties&lt;StoreState&lt;SS&gt;&gt;&gt; &#123; if (isVue2) &#123; // @ts-expect-error: toRefs include methods and others return toRefs(store) // vue2 版本直接all in ref &#125; else &#123; store = toRaw(store) // 拿到store原始对象 const refs = &#123;&#125; as ToRefs&lt; StoreState&lt;SS&gt; &amp; StoreGetters&lt;SS&gt; &amp; PiniaCustomStateProperties&lt;StoreState&lt;SS&gt;&gt; &gt; for (const key in store) &#123; const value = store[key] // 只转换ref、reactive属性 if (isRef(value) || isReactive(value)) &#123; // @ts-expect-error: the key is state or getter refs[key] = // --- toRef(store, key) &#125; &#125; return refs &#125;&#125; map系列辅助函数 mapState 基本使用 1234567891011121314151617export default &#123; computed: &#123; // 可以访问组件中的 this.count // 与从 store.count 中读取的数据相同 ...mapState(useCounterStore, ['count']) // 与上述相同，但将其注册为 this.myOwnName ...mapState(useCounterStore, &#123; myOwnName: 'count', // 你也可以写一个函数来获得对 store 的访问权 double: store =&gt; store.count * 2, // 它可以访问 `this`，但它没有标注类型... magicValue(store) &#123; return store.someGetter + this.count + this.double &#125;, &#125;), &#125;,&#125; mapState 123456789101112131415161718192021222324252627282930313233// mapHelpers.tsexport function mapState&lt; Id extends string, S extends StateTree, G extends _GettersTree&lt;S&gt;, A&gt;( useStore: StoreDefinition&lt;Id, S, G, A&gt;, keysOrMapper: any): _MapStateReturn&lt;S, G&gt; | _MapStateObjectReturn&lt;Id, S, G, A&gt; &#123; // 返回一个对象使得能够放到组件的computed属性上 return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) =&gt; &#123; reduced[key] = function (this: ComponentPublicInstance) &#123; // 通过useStore，因为store已经创建，所以内部会直接通过pinia._s.get(id)直接返回store而不会重新创建 return useStore(this.$pinia)[key] &#125; as () =&gt; any return reduced &#125;, &#123;&#125; as _MapStateReturn&lt;S, G&gt;) : Object.keys(keysOrMapper).reduce((reduced, key: string) =&gt; &#123; // @ts-expect-error reduced[key] = function (this: ComponentPublicInstance) &#123; const store = useStore(this.$pinia) const storeKey = keysOrMapper[key] // for some reason TS is unable to infer the type of storeKey to be a // function return typeof storeKey === 'function' ? (storeKey as (store: Store&lt;Id, S, G, A&gt;) =&gt; any).call(this, store) : store[storeKey] &#125; return reduced &#125;, &#123;&#125; as _MapStateObjectReturn&lt;Id, S, G, A&gt;)&#125; mapGetters 1export const mapGetters = mapState //👍 mapActions 123456789101112131415161718192021222324252627282930313233export function mapActions&lt; Id extends string, S extends StateTree, G extends _GettersTree&lt;S&gt;, A, KeyMapper extends Record&lt;string, keyof A&gt;&gt;( useStore: StoreDefinition&lt;Id, S, G, A&gt;, keysOrMapper: Array&lt;keyof A&gt; | KeyMapper): _MapActionsReturn&lt;A&gt; | _MapActionsObjectReturn&lt;A, KeyMapper&gt; &#123; return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) =&gt; &#123; // 和mapState类似,闭包存了下this和其他参数 reduced[key] = function ( this: ComponentPublicInstance, ...args: any[] ) &#123; return useStore(this.$pinia)[key](...args) &#125; return reduced &#125;, &#123;&#125; as _MapActionsReturn&lt;A&gt;) : Object.keys(keysOrMapper).reduce((reduced, key: keyof KeyMapper) =&gt; &#123; // @ts-expect-error reduced[key] = function ( this: ComponentPublicInstance, ...args: any[] ) &#123; return useStore(this.$pinia)[keysOrMapper[key]](...args) &#125; return reduced &#125;, &#123;&#125; as _MapActionsObjectReturn&lt;A, KeyMapper&gt;)&#125; 和vuex区别 不再有嵌套结构的模块 看过vuex的应该知道，整个vuex就是个嵌套的大对象，会根据命名空间一步一步从对象中取出内容，不过内部会帮你拼接命名空间路径，实际调用时也还好 而pinia不再通过命名空间来嵌套对象，通过pinia._s这个Map结构来存储创建的store，通过pinia.state.value[storeId]来存储state，整个就是一平级的结构 创建非常方便，和写一个hook函数一样轻松 虽然但是，总觉得vue越来越像React，用过hox的应该知道，Pinia的使用方式几乎和hox一模一样。。。 无需mutation 见仁见智吧，有个mutation调用流程更规范，没有就是函数调用，无学习成本 总结一下，虽然单项数据流类型的状态管理库（redux、vuex）具有十分严谨的调用步骤，但这种函数式的方式才是未来（主要是开发爽了。。。）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}]},{"title":"Vue3响应式属性Reactive和Ref","slug":"2023/Vue3响应式属性Reactive和Ref","date":"2023-02-27T00:49:38.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2023/Vue3响应式属性Reactive和Ref/","link":"","permalink":"https://summxu.github.io/2023/Vue3响应式属性Reactive和Ref/","excerpt":"","text":"ref 的基本使用1.ref:接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象仅有一个 .value property，指向该内部值。 注意：被ref包装之后需要.value 来进行赋值，因为使用ref包装，返回的是一个对象，Ref TS对应的接口 12345678910111213&lt;template&gt; &lt;button @click=\"onChangeMsg\"&gt;修改数据&lt;/button&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; ref, Ref &#125; from 'vue';const message: Ref&lt;string&gt; = ref('ref响应式数据');const onChangeMsg = () =&gt; &#123; message.value = '修改后的数据';&#125;;&lt;/script&gt; ts的另外一种方式： 12345678910111213&lt;template&gt; &lt;button @click=\"onChangeMsg\"&gt;修改数据&lt;/button&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; ref &#125; from 'vue';const message = ref&lt;string | number&gt;('ref响应式数据');const onChangeMsg = () =&gt; &#123; message.value = '修改后的数据';&#125;;&lt;/script&gt; 3.shallowRef创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的。&lt;template&gt; 1234567891011121314151617181920212223242526&lt;template&gt; &lt;button @click=\"onChangeMsg\"&gt;修改数据&lt;/button&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; ref, shallowRef &#125; from 'vue';type Obj = &#123; name: string; num: number;&#125;;const message = shallowRef&lt;Obj&gt;(&#123; name: 'vue3', num: 100&#125;);const onChangeMsg = () =&gt; &#123; //修改的值无法显示在页面上 message.value.name = '修改了name'; //修改的值可以显示在页面上 //message.value = &#123; name: '修改了name', num: 123 &#125;; //triggerRef强制修改，修改的值可以在页面显示 triggerRef(message); console.log(message, 'message');&#125;;&lt;/script&gt; 4.customRef 是个工厂函数要求我们返回一个对象 并且实现 get 和 set： 应用场景：实现防抖函数 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;button @click=\"onChangeMsg\"&gt;修改数据&lt;/button&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt; &lt;script setup lang=\"ts\"&gt;import &#123; ref, shallowRef, triggerRef, customRef &#125; from 'vue'; let message = MycustomRef('我是原始数据');const onChangeMsg = () =&gt; &#123; message.value = '修改了数据';&#125;; function MycustomRef&lt;T&gt;(value: T) &#123; return customRef((track, trigger) =&gt; &#123; return &#123; get: () =&gt; &#123; track();//通知vue，跟踪数据的变化 return value; &#125;, set: (newVal: T) =&gt; &#123; value = newVal; trigger();//通知vue重新解析模版，挂载数据 &#125; &#125;; &#125;);&#125;&lt;/script&gt; ref 为何要用.value 在Vue2中，所有的数据都通过一个Data进行统一的返回，并且在data中对某个组件要用的数据进行统一的管理，常见的使用形式是这样的： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=\"div\"&gt; &lt;todos :Obj=\"tos\" :removeObj=\"removeObj\"&gt;&lt;/todos&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import search from '@/components/search'import todos from '@/components/todos'import all from '@/components/all'export default &#123; name: 'App', data () &#123; return &#123; tos: [ &#123; id: '001', value: '第一个', done: true &#125;, &#123; id: '002', value: '第二个', done: true &#125;, &#123; id: '003', value: '第三个', done: false &#125;, &#123; id: '004', value: '第四个', done: true &#125;, ], &#125; &#125;, computed: &#123; &#125;, components: &#123; search, todos, all, &#125;, methods: &#123; removeObj (obj) &#123; console.log(obj.id) this.tos = this.tos.filter(item =&gt; item.id !== obj.id) console.log(this.tos) &#125;, &#125;,&#125;&lt;/script&gt; 可以看出来这里定义的内容都在一个数组中进行，或者是一个函数，将要使用的数据返回出来，这里无论怎么进行操作处理，最终进行数据代理的时候得到的都是一个对象，Vue2中直接通过defineProperty进行处理，并绑定对应的监听事件进行响应式的处理。 而Vue3中，数据的定义可以是单独的，Vue可以让随时需要随时定义，这也就带来了另一个问题，我需要的一个数据可能不是对象 如果要定义的数据不是对象，还需要代理会怎么样？ Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 通过这个可以明确看出，只能进行对象的代理，不能进行普通数据的代理 在Vue3中数据代理可以使用单一数据了，并且也改进了数据代理的方式，使用的是Proxy完成了数据代理，而MDN中对Proxy也进行了定义： Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 即使是Vue3中使用的Proxy的代理方式也不能进行普通数据的代理，所以当调用Ref的时候其实仍然创建了一个Proxy对象，并且Vue帮你给这个对象了一个value属性，属性值就是你定义的内容，改变的时候监视的改变依然是通过Proxy的数据劫持来进行响应式的处理，而模板中使用的时候Vue会默认调用对应的value属性，从而完成模板中的内容的直接调用 Reactive 的基本使用1.reactive:用来绑定复杂的数据类型：数组，对象等。 注意:reactive如果绑定的是基础类型数据会报错。 123456789101112131415161718192021&lt;template&gt; &lt;button @click=\"onChangeMsg\"&gt;修改数据&lt;/button&gt; &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; reactive &#125; from 'vue';let obj = reactive(&#123; name: '张三', age: 18, boj: &#123; namespaced: true &#125;&#125;);setTimeout(() =&gt; &#123; obj.name = '异步赋值无效';&#125;, 2000);const onChangeMsg = () =&gt; &#123; obj.name = '李四';&#125;;&lt;/script&gt; 2.readonly:拷贝一份proxy对象并设置为只读属性 12345678910111213141516171819202122&lt;template&gt; &lt;button @click=\"onChangeMsg\"&gt;修改数据&lt;/button&gt; &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; reactive, readonly &#125; from 'vue';let obj = reactive(&#123; name: '张三', age: 18, boj: &#123; namespaced: true &#125;&#125;);let CopyObj = readonly(obj);setTimeout(() =&gt; &#123; CopyObj.name = '异步赋值无效';&#125;, 2000);const onChangeMsg = () =&gt; &#123; CopyObj.name = '李四';&#125;;&lt;/script&gt; 3.shallowReactive:拷贝一份对象，可以修改浅层数据，无法修改深层数据 1234567891011121314151617181920212223242526&lt;template&gt; &lt;button @click=\"onChangeMsg\"&gt;修改数据&lt;/button&gt; &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; reactive, shallowReactive &#125; from 'vue';let obj = reactive(&#123; name: '张三', age: 18, boj: &#123; namespaced: true &#125;&#125;);let CopyObj = shallowReactive(obj);setTimeout(() =&gt; &#123; //可以修改 CopyObj.name = '异步赋值'; //无法修改 CopyObj.boj.namespaced = false;&#125;, 2000);console.log(CopyObj.boj.namespaced);const onChangeMsg = () =&gt; &#123; CopyObj.name = '李四';&#125;;&lt;/script&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}]},{"title":"Vue3中watch和watchEffect的用法和区别","slug":"2022/Vue3中watch和watchEffect的用法和区别","date":"2022-10-12T09:13:34.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2022/Vue3中watch和watchEffect的用法和区别/","link":"","permalink":"https://summxu.github.io/2022/Vue3中watch和watchEffect的用法和区别/","excerpt":"","text":"1.1 watch 基本使用在 Vue3 中的组合式 API 中，watch 的作用和 Vue2 中的 watch 作用是一样的，他们都是用来监听响应式状态发生变化的，当响应式状态发生变化时，都会触发一个回调函数。 代码如下： 123456789101112131415161718&lt;template&gt; &lt;img alt=\"Vue logo\" src=\"./assets/logo.png\" /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button @click=\"changeMsg\"&gt;更改 message&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; ref, watch &#125; from \"vue\";const message = ref(\"李四\");watch(message, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue);&#125;);const changeMsg = () =&gt; &#123; message.value = \"张三\";&#125;;&lt;/script&gt; 上段代码中点击按钮就会更改响应式变量 message 的值。又使用 watch 监听器监听了 message 变量，当它发生变化时，就会触发 watch 监听函数中的回调函数，并且回调函数默认接收两个参数：新值和旧值。 注意：当第一进入页面时，watch 监听函数的回调函数是不会执行的。 1.2 watch 监听类型前面一直强调 watch 监听的是响应式数据，如果监听的数据不是响应式的，那么可能会抛出警告。 （1）ref 和计算属性 ref 定义的数据是可以监听到的，因为前面的代码以及证明了。除此之外，计算属性也是可以监听到的，比如下列代码： 12345678const message = ref(\"李四\");const newMessage = computed(() =&gt; &#123; return message.value;&#125;);watch(newMessage, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue);&#125;); 当 message 发生变化时，计算属性 newMessage 也会重新计算得出新的结果， watch 监听函数是可以监听到计算属性变化的。 （2）getter 函数 这里的 getter 函数可以简单的理解为获取数据的一个函数，说白了该函数就是一个返回值的操作，有点类似与计算属性。 示例代码如下： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;img alt=\"Vue logo\" src=\"./assets/logo.png\" /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; x1 + x2 &#125;&#125;&lt;/p&gt; &lt;button @click=\"changeMsg\"&gt;更改 message&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; ref, watch &#125; from \"vue\";const message = ref(\"李四\");const x1 = ref(12);const x2 = ref(13);watch( () =&gt; x1.value + x2.value, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue); &#125;);const changeMsg = () =&gt; &#123; message.value = \"张三\"; x1.value = 14; x2.value = 23;&#125;;&lt;/script&gt; 上段代码中 watch 监听器中的第一个参数是一个箭头函数，也就是 getter 函数，getter 函数返回的是响应式数据 x1 和 x2 相加的值，当这两个中中有一个变化，都会执行 watch 中的回调函数。有点像是直接把计算属性写到监听器里面去了。 （3）监听响应式对象 前面监听的都是值类型的响应式数据，同样也可以监听响应式的对象。 代码如下： 12345678const number = reactive(&#123; count: 0 &#125;);const countAdd = () =&gt; &#123; number.count++;&#125;;watch(number, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue);&#125;); 当 watch 监听的是一个响应式对象时，会隐式地创建一个深层侦听器，即该响应式对象里面的任何属性发生变化，都会触发监听函数中的回调函数。 需要注意的，watch 不能直接监听响应式对象的属性，即下面的写法是错误的： 12345678const number = reactive(&#123; count: 0 &#125;);const countAdd = () =&gt; &#123; number.count++;&#125;;watch(number.count, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue);&#125;); 上段代码中相当于你直接向 watch 传递了一个非响应式的数字，然而 watch 只能监听响应式数据。 但是： 如果非要监听响应式对象中的某个属性，可以使用 getter 函数的形式，代码如下： 1234567watch( () =&gt; number.count, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue); &#125;); 上段代码也是可以监听到 count 变化的。 （4）监听多个来源的数组 watch 还可以监听数组，前提是这个数组内部含有响应式数据。 代码如下： 123456789const x1 = ref(12);const number = reactive(&#123; count: 0 &#125;);const countAdd = () =&gt; &#123; number.count++;&#125;;watch([x1, () =&gt; number.count], (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue);&#125;); 1.3 深度监听在前面的代码中，如果将一个响应式对象传递给 watch 监听器时，只要对象里面的某个属性发生了变化，那么就会执行监听器回调函数。 究其原因，因为传入响应对象给 watch 时，隐式的添加一个深度监听器，这就让造成了牵一发而至全身的效果。 但是，如果是使用的 getter 函数返回响应式对象的形式，那么响应式对象的属性值发生变化，是不会触发 watch 的回调函数的。 代码如下： 1234567891011const number = reactive(&#123; count: 0 &#125;);const countAdd = () =&gt; &#123; number.count++;&#125;;watch( () =&gt; number, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue); &#125;,); 上段代码中使用 getter 函数返回了响应式对象，当更改 number 中 count 的值时，watch 的回调函数是不会执行的。 为了实现上述代码的监听，可以手动给监听器加上深度监听的效果。 代码如下： 123456789101112const number = reactive(&#123; count: 0 &#125;);const countAdd = () =&gt; &#123; number.count++;&#125;;watch( () =&gt; number, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue); &#125;, &#123; deep: true &#125;); 添加深度监听很简单，只需要给 watch 添加第三个参数即可：{ deep: true }。 注意：上段代码中的 newValue 和 oldValue 的值是一样的，除非把响应式对象即 number 整个替换掉，那么这两个值才会变得不一样。除此之外，深度监听会遍历响应式对象的所有属性，开销较大，当对象体很大时，需要慎用。 所以推荐 getter 函数只返回相应是对象中的某一个属性！！ 2.watchEffect前面使用 watch 监听数据状态时，不知道有没有发现这样一个问题：只有当监听的数据源发生了变化，监听函数的回调函数才会执行。但是需求总是多变的，有些场景下可能需要刚进页面，或者说第一次渲染页面的时候，watch 监听器里面的回调函数就执行一遍。 面对这种需求怎样处理呢？一般有两种方式： 方式一： 这种方式也是通过 watch 实现的，确切的说是巧妙的实现，而不是依赖于 watch 监听器。 代码如下： 123456789101112131415const number = reactive(&#123; count: 0 &#125;);// 进入页面先执行一遍const callback = () =&gt; &#123; console.log(\"新的值:\", number.count); console.log(\"旧的值:\", number.count);&#125;;callback();watch( () =&gt; number.count, (newValue, oldValue) =&gt; &#123; console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue); &#125;, &#123; deep: true &#125;); 既然想要第一次进入页面的时候就执行一遍回调函数，那么不妨把回调函数直接提取出来，进入页面执行一遍即可，这也算是巧妙的实现了的需求。 但是这种方式似乎不太优雅，而且有些繁琐。所以 Vue 推出了更加优雅的方法：watchEffect 监听器。 方式二： watchEffect 也是一个监听器，只不过它不会像 watch 那样接收一个明确的数据源，它只接收一个回调函数。而在这个回调函数当中，它会自动监听响应数据，当回调函数里面的响应数据发生变化，回调函数就会立即执行。 所以可以将方式一中的代码使用 watchEffect 优雅的实现。 代码如下： 1234567const number = reactive(&#123; count: 0 &#125;);const countAdd = () =&gt; &#123; number.count++;&#125;;watchEffect(()=&gt;&#123; console.log(\"新的值:\", number.count);&#125;) 上段代码中，当第一次进入页面时，number 响应数据从无到有，这个时候就会触发 watchEffect 的回调函数，因为在 watchEffect 回调函数中使用了 number 响应数据，所以它会自动跟踪 number 数据的变化。当点击按钮更改 count 的值时，watchEffect 中的回调函数便会再次执行。 这样代码是不是简单很多呀！ 3.watch 和 watchEffect 区别已经大概知道了 watch 和 watchEffect 的用法，那么它们之间的区别相信也了解了一些，这里总结一下它们之间的区别。 watch 和 watchEffect 都能监听响应式数据的变化，不同的是它们监听数据变化的方式不同。 watch 会明确监听某一个响应数据，而 watchEffect 则是隐式的监听回调函数中响应数据。 watch 在响应数据初始化时是不会执行回调函数的，watchEffect 在响应数据初始化时就会立即执行回调函数。 4.回调中的 DOM如果在监听器的回调函数中或取 DOM，这个时候的 DOM 是更新前的还是更新后的？ 不妨实验一下。 代码如下： 1234567891011121314151617181920&lt;template&gt; &lt;img alt=\"Vue logo\" src=\"./assets/logo.png\" /&gt; &lt;p ref=\"msgRef\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button @click=\"changeMsg\"&gt;更改 message&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; computed, reactive, ref, watch, watchEffect &#125; from \"vue\";const message = ref(\"李四\");const msgRef = ref&lt;any&gt;(null);const changeMsg = () =&gt; &#123; message.value = \"张三\";&#125;;watch(message, (newValue, oldValue) =&gt; &#123; console.log(\"DOM 节点\", msgRef.value.innerHTML); console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue);&#125;);&lt;/script&gt; 通过点击按钮更改 message 的值，从“李四”变为“张三”。但是发现在监听器的回调函数里面获取到的 DOM 元素还是“李四”，说明 DOM 还没有更新。 解决方法： 如果想要在回调函数里面获取更新后的 DOM，非常简单，只需要再给监听器多传递一个参数选项即可：flush: ‘post’。watch 和 watchEffect 同理。 代码如下： 123456watch(source, callback, &#123; flush: 'post'&#125;)watchEffect(callback, &#123; flush: 'post'&#125;) 修改后的代码： 1234567891011watch( message, (newValue, oldValue) =&gt; &#123; console.log(\"DOM 节点\", msgRef.value.innerHTML); console.log(\"新的值:\", newValue); console.log(\"旧的值:\", oldValue); &#125;, &#123; flush: \"post\", &#125;); 这个时候在回调函数中获取到的已经是更新后的 DOM 节点了。 补充： 虽然 watch 和 watchEffect 都可以用上述方法解决 DOM 问题，但是 Vue3 单独给 watchEffect 提供了一个更方便的方法，也可以叫做 watchEffect 的别名，代码如下： 123watchPostEffect(() =&gt; &#123; /* 在 Vue 更新后执行 */&#125;) 5.手动停止监听器通常来说，的一个组件被销毁或者卸载后，监听器也会跟着被停止，并不需要手动去关闭监听器。但是总是有一些特殊情况，即使组件卸载了，但是监听器依然存在，这个时候其实式需要手动关闭它的，否则容易造成内存泄漏。 比如下面这中写法，就需要手动停止监听器： 123456789&lt;script setup&gt;import &#123; watchEffect &#125; from 'vue'// 它会自动停止watchEffect(() =&gt; &#123;&#125;)// ...这个则不会！setTimeout(() =&gt; &#123; watchEffect(() =&gt; &#123;&#125;)&#125;, 100)&lt;/script&gt; 上段代码中采用异步的方式创建了一个监听器，这个时候监听器没有与当前组件绑定，所以即使组件销毁了，监听器依然存在。 关闭方法很简单，代码如下： 123const unwatch = watchEffect(() =&gt; &#123;&#125;)// ...当该侦听器不再需要时unwatch() 需要用一个变量接收监听器函数的返回值，其实就是返回的一个函数，然后调用该函数，即可关闭当前监听器。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}]},{"title":"React实现原理及Fiber架构","slug":"2022/React实现原理及Fiber架构","date":"2022-05-12T01:36:14.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2022/React实现原理及Fiber架构/","link":"","permalink":"https://summxu.github.io/2022/React实现原理及Fiber架构/","excerpt":"","text":"vdom定义：vdom 就是根据真实dom的属性使用js重新按照原有结构模拟出一份dom对象，dom api 对真实 dom 做增删改。 123456789&#123; type: 'div', props: &#123; id: 'aaa', className: ['bbb', 'ccc'], onClick: function() &#123;&#125; &#125;, children: []&#125; 有了 vdom 的好处，就没有和 dom 强绑定了，可以跨平台渲染，比如 native、canvas 等等。 但是要让开发去写这样的 vdom 么？ 那肯定不行，这样太麻烦了，大家熟悉的是 html 那种方式，所以要引入一些编译的手段。 dsl 的编译dsl 是 domain specific language，领域特定语言的意思，html、css 都是 web 领域的 dsl。 直接写 vdom 太麻烦了，所以前端框架都会设计一套 dsl，然后编译成 render function，执行后产生 vdom。 vue 和 react 都是这样： jsx -&gt; render function -&gt; vdom 这套 dsl 怎么设计呢？ 前端领域大家熟悉的描述 dom 的方式是 html，最好的方式自然是也设计成那样。 所以 vue 的 template，react 的 jsx 就都是这么设计的。 vue 的 template compiler 是自己实现的，而 react 的 jsx 的编译器是 babel 实现的，是两个团队合作的结果。 渲染 vdom渲染 vdom 也就是通过 dom api 增删改 dom。 比如一个 div，那就要 document.createElement 创建元素，然后 setAttribute 设置属性，addEventListener 设置事件监听器。 如果是文本，那就要 document.createTextNode 来创建。 所以说根据 vdom 类型的不同，写个 if else，分别做不同的处理就行了。 没错，不管 vue 还是 react，渲染器里这段 if else 是少不了的： 12345678910switch (vdom.tag) &#123; case HostComponent: // 创建或更新 dom case HostText: // 创建或更新 dom case FunctionComponent: // 创建或更新 dom case ClassComponent: // 创建或更新 dom&#125; react 里是通过 tag 来区分 vdom 类型的，比如 HostComponent 就是元素，HostText 就是文本，FunctionComponent、ClassComponent 就分别是函数组件和类组件。 状态管理react 没有响应式系统，是通过 setState 的 api 触发状态更新的，更新以后就重新渲染整个 vdom。 vue 是通过对状态做代理，get 的时候收集以来，然后修改状态的时候就可以触发对应组件的 render 了，不管是子组件、父组件、还是其他位置的组件，只要用到了对应的状态，那就会被作为依赖收集起来，状态变化的时候就可以触发它们的 render，不管是组件是在哪里的。 这就是为什么 react 需要重新渲染整个 vdom，而 vue 不用。 react 的 setState 会渲染整个 vdom，而一个应用的所有 vdom 可能是很庞大的，计算量就可能很大。 浏览器里 js 计算时间太长是会阻塞渲染的，会占用每一帧的动画、重绘重排的时间，这样动画就会卡顿。 作为一个有追求的前端框架，动画卡顿肯定是不行的。但是因为 setState 的方式只能渲染整个 vdom，所以计算量大是不可避免的。 那能不能把计算量拆分一下，每一帧计算一部分，不要阻塞动画的渲染呢？ 顺着这个思路，react 就改造为了 fiber 架构。 Fiber一：Fiber的概念React Fiber是react执行渲染时的一种新的调度策略，JavaScript是单线程的，一旦组件开始更新，主线程就一直被React控制，这个时候如果再次执行交互操作，就会卡顿。 React Fiber就是通过对象记录组件上需要做或者已经完成的更新，一个组件可以对应多个Fiber。 在render函数中创建的React Element树在第一次渲染的时候会创建一颗结构一模一样的的Fiber节点树。不同的React Element类型对应不同的Fiber节点类型。一个React Element的工作就由它对应的Fiber节点来负责。 一个React Element可以对应不止一个Fiber，因为Fiber在update的时候，会从原来的Fiber(我们称为current)clone出一个新的Fiber(我们称之为alternate)。俩个Fiber diff出的变化(side effect)记录在alternate上。所以一个组件在更新时最多会有俩个Fiber与其对应，在更新结束后alternate会取代之前的current称为新的current节点。 React Fiber重构这种方式，渲染过程采用切片的方式，每执行一会儿，就歇一会儿。如果有优先级更高的任务到来以后呢，就会先去执行，降低页面发生卡顿的可能性，使得React对动画等实时性要求较高的场景体验更好。 二：什么是Fiber？ 当js在处理大型计算的时候会导致页面出现卡帧的现象，更严重的会出现页面“假死”。所以在这些情况下，必然会导致动画丢帧、不连贯，用户体验就特别差。为了解决这个问题，我们可以将大型的计算拆分成一个个小型计算，然后按照执行顺序异步调用，这样就不会长时间霸占线程，UI也能在俩次小型计算的执行间隙进行更新，从而给与用户及时的反馈，Fiber就是这样做的，并且以一种更高逼格的方式实现了。Driving Idea 如果说v16.0之前的React解决了HOW(如何用最少的DOM操作成本来update视图)的问题，那么这一次Fiber的出现，在这个基础上还解决了WHEN(何时update视图的哪一部分)的问题。 分片优先级！！！ 基于上述这些原因，Fiber实现了一个虚拟调用栈，并给所有的update进行优先级排序，如下： 12345678910111213141516171819&apos;use strict&apos;;export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;module.exports = &#123; NoWork: 0, // No work is pending. SynchronousPriority: 1, // 用于控制文本输入。同步的副作用.AnimationPriority: 2, //需要在下一帧之前完成. HighPriority: 3, // 需要很快完成的互动才能产生反应. LowPriority: 4, // 数据获取，或更新存储的结果. OffscreenPriority: 5, // 将不可见，但做的工作，以防它成为可见.&#125;; 然后根据这些update的优先级，来决定执行的顺序。 我们可以看到动画和页面交互都是优先级比较高的，这也是Fiber能够使得动画、布局和页面交互变得更加的流畅的原因之一。 可以把Priority分为同步和异步两个类别，同步优先级的任务会在当前帧完成，包括SynchronousPriority和TaskPriority。异步优先级的任务则可能在接下来的几个帧中被完成，包括HighPriority、LowPriority以及OffscreenPriority。 React v16.3.2的优先级，不再这么划分，分为三类：NoWork、sync、async，前两类可以认为是同步任务，需要在当前tick完成，过期时间为null，最后一类异步任务会计算一个。 expirationTime，在workLoop中，根据过期时间来判断是否进行下一个分片任务，scheduleWork中更新任务优先级，也就是更新这个expirationTime。至于这个时间怎么计算，可以查看源码。 三：Fiber的基本原则： 更新任务分成俩个阶段，Reconcilition Phase(调和阶段)和Commit Phase(交付阶段)。Reconciliation Phase的任务干的事情是，找出要做的更新工作(Diff Fiber Tree),就是一个计算阶段，计算结果可以被缓存，也就可以被打断；Commit Phase需要提交所有更新并渲染，为了防止页面抖动，被设置为不能打断。 PS：componentWillMount omponentWillReceiveProps componentWillUpdate 几个生命周期方法，在Reconciliation Phase被调用，有被打断的可能（时间用尽等情况），所以可能被多次调用。其实shouldComponentUpdate 也可能被多次调用，只是它只返回true或者false，没有副作用，可以暂时忽略。 四：Fiber的数据结构 fiber是个链表，有child和sibing属性，指向第一个子节点和相邻的兄弟节点，从而构成fiber tree。return 属性指向其父节点。 更新队列，updateQueue，是一个链表，有first和last俩个属性，指向第一个和最后一个update对象。 每个fiber有一个属性updateQueue指向其对应的更新队列。 每个fiber(当前fiber可以称为current)有一个属性alternate，开始时指向一个自己的clone体，update的变化会先更新到alternate上，当更新完毕，alternate替换current。 五：Fiber的执行流程 用户操作引起setState被调用以后，先调用enqueueSetState方法，该方法可以划分成俩个阶段（个人理解），第一阶段Data Preparation，是初始化一些数据结构，比如fiber，updateQueue，update。 新的update会通过insertUpdateIntoQueue方法，根据优先级插入到队列的对应位置，ensureUpdateQueues方法初始化俩个更新队列，queue1和current.updateQueue对应，queue2和current.alternate.updateQueue对应。 第二阶段，Fiber Reconciler，就开始进行任务分片调度，scheduleWork首先更新每个fiber的优先级，这里并没有updatePriority这个方法，但是干了这件事。当fiber.return === null，找到父节点，把所有diff出的变化(side effect)归结到root上。 requestWork，首先把当前的更新添加到schedule list中(addRootToSchedule),然后根据当前是否为异步渲染(isAsync参数)，异步渲染调用。scheduleCallbackWithExpriation方法，下一步高能！！ scheduleCallbackWithExpriation这个方法在不同环境，实现不一样，chrome等浏览器中使用requestIdleCallback API，没有这个API的浏览器中，通过requestAnimationFrame模拟一个requestIdCallback，来在浏览器空闲时，完成下一个分片的工作，注意，这个函数会传入一个expirationTime，超过这个时间活没干完，就放弃了。 执行到performWorkOnRoot，就是fiber文档中提到的Commit Phase和Reconciliation Phase俩阶段。 第一阶段Reconciliation Phase,在workLoop中，通过一个while循环，完成每个分片任务。 performUnitOfWork也可以分成俩阶段，蓝色框表示。beginWork是一个入口函数，根据workInProgress的类型去实例化不同的react element class。workInProgress是通过alternate挂载一些新属性获得的。 实例化不同的react element class时候会调用和will有关的生命周期方法。 completeUnitOfWork是进行一些收尾工作，diff完一个节点以后，更新props和调用生命周期方法等。 然后进入Commit Phase阶段，这个阶段不能被打断。 六：Fiber对开发者有什么影响？ componentWillMount,componentWillReceiveProps,componentWillUpdate几个生命周期方法不再安全，由于任务执行过程可以被打断，这几个生命周期可能会执行多次，如果它们包含副作用(比如Ajax)，会有意想不到的bug。React团队提供了替换的生命周期方法。建议如果使用以上方法，尽量使用纯函数，避免以后踩坑。 需要关注react为任务片设置的优先级，特别是页面用动画的情况。 如果一直有更高的级别任务，那么fiber算法会先执行级别更高的任务，执行完毕后再通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://summxu.github.io/tags/React/"}]},{"title":"Redux源码全面解析","slug":"2022/Redux源码全面解析","date":"2022-02-26T01:36:37.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2022/Redux源码全面解析/","link":"","permalink":"https://summxu.github.io/2022/Redux源码全面解析/","excerpt":"","text":"Redux使用中的几个点： Redux三大设计原则 Create Store Redux middleware combineReducer Provider与Connect Redux流程梳理 Redux设计特点 1. 单一数据源在传统的 MVC 架构中，可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。因为在 Redux 的思想里，一个应用永远只有唯一的数据源。实际上，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样随时可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）。此外，这样的设计也为服务端渲染提供了可能。 2. 状态是只读的在 Redux 中，并不会自己用代码来定义一个 store。取而代之的是，定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里并没有直接修改应用的状态，而是返回了一份全新的状态。 Redux 提供的 createStore 方法会根据 reducer 生成 store。最后，可以利用 store. dispatch方法来达到修改状态的目的。 3.状态修改均由纯函数完成在 Redux 里，通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。 这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux 利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发 action 而改变状态的结果成为了可能。 2.Create Store从store的诞生开始说起。create store函数API文档如下： 1createStore(reducer, [initialState], enhancer) 可以看出，它接受三个参数：reducer、initialState 和 enhancer 。Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。 再来看看他的返回值： 1234567&#123; dispatch: f (action), getState: f (), replaceReducer: f (nextReducer), subscribe: f (listener), Symbol(observable): f () &#125; store的返回值就是一个普通对象，里面有几个常用的方法： dispatch：就是最常用的dispatch方法，派发action。 getState：通过该方法，可以拿到当前状态树state。 replaceReducer：这个方法主要用于 reducer 的热替换，下面介绍该方法。 subscribe：添加一个变化监听器。每当 dispatch（action）的时候就会执行，state 树中的一部分可能已经变化。 observable：观察者模式，用于处理订阅关系。 这里挑几个方法介绍： getState在完成基本的参数校验之后，在 createStore 中声明如下变量及 getState 方法： 123456789101112var currentReducer = reducervar currentState = initialStatevar listeners = [] // 当前监听 store 变化的监听器var isDispatching = false // 某个 action 是否处于分发的处理过程中/*** Reads the state tree managed by the store. ** @returns &#123;any&#125; The current state tree of your application. */function getState() &#123; return currentState&#125; getState方法就是简单返回当前state，如果state没有被reducer处理过，他就是initialState。 subscribe在 getState 之后，定义了 store 的另一个方法 subscribe： 123456789101112function subscribe(listener) &#123; listeners.push(listener) var isSubscribed = true return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false var index = listeners.indexOf(listener) listeners.splice(index, 1) &#125;&#125; Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。你可能会感到奇怪，好像在 Redux 应用中并没有使用 store.subscribe 方法？事实上， React Redux 中的 connect 方法隐式地帮完成了这个工作。 store.subscribe方法返回一个函数，调用这个函数就可以解除监听。 dispatchdispatch是redux的核心方法： 12345678910111213141516171819202122232425function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; listeners.slice().forEach(listener =&gt; listener()) return action&#125; 判断当前是否处于某个 action 的分发过程中，这个检查主要是为了避免在 reducer 中分发 action 的情况，因为这样做可能导致分发死循环，同时也增加了数据流动的复杂度。 确认当前不属于分发过程中后，先设定标志位，然后将当前的状态和 action 传给当前的reducer，用于生成最新的 state。这看起来一点都不复杂，这也是反复强调的 reducer 工作过程——纯函数、接受状态和 action 作为参数，返回一个新的状态。 在得到新的状态后，依次调用所有的监听器，通知状态的变更。需要注意的是，在通知监听器变更发生时，并没有将最新的状态作为参数传递给这些监听器。这是因为在监听器中，可以直接调用 store.getState() 方法拿到最新的状态。 最终，处理之后的 action 会被 dispatch 方法返回。 replaceReducer1234567function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.'); &#125; currentReducer = nextReducer; dispatch(&#123; type: ActionTypes.INIT &#125;); &#125; 这是为了拿到所有 reducer 中的初始状态（你是否还记得在定义 reducer 时，第一个参数为previousState，如果该参数为空，提供默认的 initialState）。只有所有的初始状态都成功获取后，Redux 应用才能有条不紊地开始运作。 3.Redux middleware It provides a third-party extension point between dispatching an action, and the moment it reachesthe reducer 它提供了一个分类处理 action 的机会。在middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的action 进行相应操作，给你一次改变 action 的机会。 常规的同步数据流模式的流程图如下： f2BVgyd4bOqmbmPx.png](https://sslstatic.ktanx.com/images/release/201811/f2BVgyd4bOqmbmPx.png)不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：![Tr2gHBdB9tYoeS97.png 每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware 实现变化多样的功能。比如上面的业务，把处理log的代码封装成一个middleware，处理异步的也是一个middleware，两者串联，却又相互独立。 使用middleware之后，action触发的dispatch并不是原来的dispatch，而是经过封装的new dispatch，在这个new dispatch中，按照顺序依次执行每个middleware，最后调用原生的dispatch。 来看下logger middleware如何实现的： 12345export default store =&gt; next =&gt; action =&gt; &#123; console.log('dispatch:', action); next(action); console.log('finish:', action); &#125; 这里代码十分简洁，就是在next调用下一个middleware之前和之后，分别打印两次。 Redux 提供了 applyMiddleware 方法来加载 middleware，该方法的源码如下： 1234567891011121314151617181920import compose from './compose';export default function applyMiddleware(...middlewares) &#123; return function (next) &#123; return function (reducer, initialState) &#123; let store = next(reducer, initialState); let dispatch = store.dispatch; let chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action), &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123; ...store, dispatch, &#125;; &#125; &#125;&#125; 其中compose源码如下： 123function compose(...funcs) &#123; return arg =&gt; funcs.reduceRight((composed, f) =&gt; f(composed), arg);&#125; 使用的时候，如下： 1const newStore = applyMiddleware([mid1, mid2, mid3, ...])(createStore)(reducer, initialState); ok，相关源码已就位，来详细解析一波。 函数式编程思想设计 ：middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的currying，它是一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个middleware 进行层层调用，动态地将 store 和 next 参数赋值。currying 的 middleware 结构的好处主要有以下两点。 易串联：currying 函数具有延迟执行的特性，通过不断 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeline 来处理数据流。  共享 store: 在 applyMiddleware 执行的过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。 给 middleware 分发 store：newStore创建完成之后，applyMiddleware 方法陆续获得了3个参数，第一个是 middlewares 数组[mid1, mid2, mid3, …]，第二个是 Redux 原生的 createStore ，最后一个是 reducer。然后，可以看到 applyMiddleware 利用 createStore 和 reducer 创建了一个 store。而 store 的 getState方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量 store： 12345const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action),&#125;;chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); 然后，让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍。执行完后，获得 chain数组 [f1, f2, … , fx, …, fn]，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数都可以访问相同的 store，即 middlewareAPI。 middlewareAPI 中的 dispatch 为什么要用匿名函数包裹呢？ 用 applyMiddleware 是为了改造 dispatch，所以 applyMiddleware 执行完后，dispatch 是变化了的，而 middlewareAPI 是 applyMiddleware 执行中分发到各个 middleware 的，所以必须用匿名函数包裹 dispatch，这样只要 dispatch 更新了，middlewareAPI 中的 dispatch 应用也会发生变化。 组合串联 middleware：这一层只有一行代码，却是 applyMiddleware 精华之所在dispatch = compose(...chain)(store.dispatch);，其中 compose 是函数式编程中的组合，它将 chain 中的所有匿名函数 [f1, f2, … , fx, …, fn]组装成一个新的函数，即新的 dispatch。当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行。 compose(…funcs) 返回的是一个匿名函数，其中 funcs 就是 chain 数组。当调用 reduceRight时，依次从 funcs 数组的右端取一个函数 fx 拿来执行，fx 的参数 composed 就是前一次 fx+1 执行的结果，而第一次执行的 fn（n 代表 chain 的长度）的参数 arg 就是 store.dispatch。所以，当 compose 执行完后，得到的 dispatch 是这样的，假设 n = 3： 1dispatch = f1(f2(f3(store.dispatch)))); 这时调用新 dispatch，每一个 middleware 就依次执行了。 在 middleware 中调用 dispatch 会发生什么：经过 compose 后，所有的 middleware 算是串联起来了。可是还有一个问题，在分发 store 时，提到过每个 middleware 都可以访问 store，即 middlewareAPI 这个变量，也可以拿到 store 的dispatch 属性。那么，在 middleware 中调用 store.dispatch() 会发生什么，和调用 next() 有区别吗？现在来说明两者的不同： 12345678910const logger = store =&gt; next =&gt; action =&gt; &#123; console.log('dispatch:', action); next(action); console.log('finish:', action);&#125;;const logger = store =&gt; next =&gt; action =&gt; &#123; console.log('dispatch:', action); store.dispatch(action); console.log('finish:', action);&#125;; 在分发 store 时解释过，middleware 中 store 的 dispatch 通过匿名函数的方式和最终compose 结束后的新 dispatch 保持一致，所以，在 middleware 中调用 store.dispatch() 和在其他任何地方调用的效果一样。而在 middleware 中调用 next()，效果是进入下一个 middleware，下图就是redux middleware最著名的洋葱模型图。 IArjf9kjKecPhnFF.png 4.combineReducer如果一个项目过大，通常按模块来写reducer，但是redux create store只接受一个reducer参数，所以需要合并reducer。这里就用到了redux提供的combineReducer辅助函数： 12345combineReducers(&#123; layout, home, ...asyncReducers &#125;) 这个函数用起来很简单，就是传入一个对象，key是模块reducer对应的名字， 值是对应reducer。值是一个function，相当于是一个新的reducer，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051export default function combineReducers(reducers) &#123; var reducerKeys = Object.keys(reducers) var finalReducers = &#123;&#125; for (var i = 0; i &lt; reducerKeys.length; i++) &#123; var key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; var finalReducerKeys = Object.keys(finalReducers) if (process.env.NODE_ENV !== 'production') &#123; var unexpectedKeyCache = &#123;&#125; &#125; var sanityError try &#123; assertReducerSanity(finalReducers) &#125; catch (e) &#123; sanityError = e &#125; return function combination(state = &#123;&#125;, action) &#123; if (sanityError) &#123; throw sanityError &#125; if (process.env.NODE_ENV !== 'production') &#123; var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; var hasChanged = false var nextState = &#123;&#125; for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; var errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; 源码不是很多，除去一些验证代码，剩下的就是说：return一个function，暂时称呼他combination，就相当于是与一个总的reducer，每次action都会走到combination中，combination会遍历输入的reducer，将action放到每个reducer中执行一下，计算出返回结果就是nextState，nextState于previousState如果!==说明改变了，返回nextState，否则返回执行之前的state。 这也解释了不同模块actionType如果相同的话，两个模块的reducer都会走一遍的问题，在actionType名称前面加上模块前缀即可解决问题。 5. Provider与ConnectProvider与Connet组件都是React-Redux提供的核心组件，两者看起来功能一样，都是帮助容器组件获取store中的数据，但是原理与功能却不同。 ProviderProvider组件在所有组件的最外层，其接受store作为参数，将store里的state使用context属性向下传递。部分源码： 12345678910111213export default class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.store &#125; &#125; constructor(props, context) &#123; super(props, context) this.store = props.store &#125; render() &#123; const &#123; children &#125; = this.props return Children.only(children) &#125;&#125; 利用context这个属性，Provider所有子组件均可以拿到这个属性。 Connectconnect实现的功能是将需要关联store的组件和store的dispatch等数据混合到一块，这块就是一个高阶组件典型的应用： 1234567891011121314151617181920212223242526import hoistStatics from 'hoist-non-react-statics'export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123; // ... return function wrapWithConnect(WrappedComponent) &#123; // ... class Connect extends Component &#123; // ... render() &#123; // ... if (withRef) &#123; this.renderedElement = createElement(WrappedComponent, &#123; ...this.mergedProps, ref: 'wrappedInstance' &#125;) &#125; else &#123; this.renderedElement = createElement(WrappedComponent, this.mergedProps ) &#125; return this.renderedElement &#125; &#125; // ... return hoistStatcis(Connect, WrappedComponent); &#125;&#125; 还是先从他的四个参数说起： 1.mapStateToPropsconnect 的第一个参数定义了需要从 Redux 状态树中提取哪些部分当作 props 传给当前组件。一般来说，这也是使用 connect 时经常传入的参数。事实上，如果不传入这个参数，React 组件将永远不会和 Redux 的状态树产生任何关系。具体在源代码中的表现为： 1234567891011121314export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123; const shouldSubscribe = Boolean(mapStateToProps) // ... class Connect extends Component &#123; // ... trySubscribe() &#123; if (shouldSubscribe &amp;&amp; !this.unsubscribe) &#123; this.unsubscribe = this.store.subscribe(this.handleChange.bind(this)) this.handleChange() &#125; &#125; // ... &#125;&#125; mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。 这块的源码相对较简单： 1234567891011121314151617181920212223242526272829const mapState = mapStateToProps || defaultMapStateToProps class Connect extends Component &#123; computeStateProps(store, props) &#123; if (!this.finalMapStateToProps) &#123; return this.configureFinalMapState(store, props) &#125; const state = store.getState() const stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state) if (process.env.NODE_ENV !== 'production') &#123; checkStateShape(stateProps, 'mapStateToProps') &#125; return stateProps &#125; configureFinalMapState(store, props) &#123; const mappedState = mapState(store.getState(), props) const isFactory = typeof mappedState === 'function' this.finalMapStateToProps = isFactory ? mappedState : mapState this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1 if (isFactory) &#123; return this.computeStateProps(store, props) &#125; if (process.env.NODE_ENV !== 'production') &#123; checkStateShape(mappedState, 'mapStateToProps') &#125; return mappedState &#125;&#125; 这块原理很简单，进行一些参数校验，判断第一个参数mapStateToProps返回值是否为function，如果是递归调用，不是的话算出返回值。如果没传这个参数，默认给{}。 可能会疑惑为什么传给 connect 的第一个参数本身是一个函数，react-redux 还允许这个函数的返回值也是一个函数呢？简单地说，这样设计可以允许在 connect 的第一个参数里利用函数闭包进行一些复杂计算的缓存，从而实现效率优化的目的 当使用的时候： 1234const mapStateToProps = (state, props) =&gt; (&#123; home: state.home, layout: state.layout&#125;); 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染 2.mapDispatchToProps人如其名，它接受 store 的 dispatch 作为第一个参数，同时接受 this.props 作为可选的第二个参数。利用这个方法，可以在 connect 中方便地将 actionCreator 与 dispatch 绑定在一起（利用 bindActionCreators 方法），最终绑定好的方法也会作为 props 传给当前组件。这块的源码与mapStateToProps一样，就不贴了。 bindActionCreator 123function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args))&#125; 3.mergeProps前两个参数返回的对象，都要跟组件自身的props merge一下，形成一个新的对象赋值给对应组件，可以在这一步做一些处理，这个参数就是干这个的，该参数签名： 1mergeProps(stateProps, dispatchProps, ownProps): props 默认情况如果没传该参数，返回Object.assign(ownProps, stateProps, dispatchProps)。 4.options如果指定这个参数，可以定制 connector 的行为。 [pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。*默认值为 true。* [withRef = false] (Boolean): 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 getWrappedInstance() 方法获得。*默认值为 false。* 这个connect组件还干了一件事，状态缓存判断。当store变了的时候，前后状态判断，如果状态不等，更新组件，并且完成事件分发。 6. Redux流程梳理上面讲了大量的函数源码，这么些函数之间的关系： 4g40yEqEfjeRqxs6.png 初始化阶段： createStore创建一个store对象 将store对象通过参数给Provider组件 Provider组件将store通过context向子组件传递 Connect组件通过context获取到store，存入自己的state componentDidMount里面订阅store.subscribe事件 更新数据阶段： 用户事件触发 actionCreator生成action交给dispatch 实际上交给了封装后的中间层（compose(applyMiddleware(…))） 请求依次通过每个中间件，中间件通过next进行下一步 最后一个中间件将action交给store.dispatch dispatch内部将action交给reducer执行 combineReducer将每个子reducer执行一遍算出新的state dispatch内部调用所有订阅事件 Connect组件handleChange事件触发判断新state和旧state是否=== 并且判断新的state是否与mapStateToProps shallowEqual 不等则setState触发更新 7.Redux设计技巧 匿名函数&amp;&amp;闭包使用 redux核心函数大量使用了匿名函数和闭包来实现数据共享和状态同步。 函数柯里化使用 使用函数柯里化s实现参数复用，本质上是降低通用性，提高适用性。 核心状态读取是拷贝而不是地址 对于state这种核心状态使用getState()计算出新的state，而不是直接返回一个state对象。 观察者订阅者是核心实现 使用观察者订阅者模式实现数据响应。 context这个api的使用 平时开发不常接触的api实现Provider与Connect通信。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"深入了解useMemo和useCallback","slug":"2021/深入了解useMemo和useCallback","date":"2021-10-31T01:06:38.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2021/深入了解useMemo和useCallback/","link":"","permalink":"https://summxu.github.io/2021/深入了解useMemo和useCallback/","excerpt":"","text":"从 useMemo 开始。useMemo 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。 React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“re-render”。基于当前应用程序状态，每次重新呈现都是应用程序UI在给定时刻应该是什么样子的快照。可以把它想象成一堆照片，每一张照片都记录了给定每个状态变量的特定值时事物的样子。 每次“re-render”都会根据当前状态在脑海中生成 DOM 应该是什么样子的图像。但实际上它是一堆JS对象，被称为“virtual DOM”。 不直接告诉 React 需要更改哪些 DOM 节点。相反，根据当前状态告诉React UI应该是什么样子。通过重新渲染，React 创建一个新的快照，它可以通过比较快照找出需要更改的内容，就像玩“寻找差异”游戏一样。 React 在开箱即用时进行了大量优化，所以通常情况下，重新渲染不是什么大问题。但是，在某些情况下，创建这些快照确实需要一些时间。这可能会导致性能问题，比如 UI 在用户执行操作后更新不够快。 而 useMemo 和 useCallback 是用来帮助优化重渲染的工具。他们通过两种方式做到这一点： 减少在给定渲染中需要完成的工作量。 减少组件需要重新呈现的次数。 让通过下面的栗子来理解它们吧。 2. 示例1：大量的计算假设正在构建一个工具来帮助用户查找 0 到 selectedNum 之间的所有素数，其中 selectedNum 是用户提供的值。**质数是只能被1和自身整除的数，比如17。**下面是一个可能的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react';function App() &#123; // 存储用户所选号码的状态。 const [selectedNum, setSelectedNum] = React.useState(100); // 计算从 0 到用户选择的数字 selectedNum 之间的所有素数 const allPrimes = []; for (let counter = 2; counter &lt; selectedNum; counter++) &#123; if (isPrime(counter)) &#123; allPrimes.push(counter); &#125; &#125; return ( &lt;&gt; &lt;form&gt; &lt;label htmlFor=\"num\"&gt;Your number:&lt;/label&gt; &lt;input type=\"number\" value=&#123;selectedNum&#125; onChange=&#123;(event) =&gt; &#123; // 为了防止太大，将最大值设定在10万 let num = Math.min(100_000, Number(event.target.value)); setSelectedNum(num); &#125;&#125; /&gt; &lt;/form&gt; &lt;p&gt; There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:&#123;' '&#125; &lt;span className=\"prime-list\"&gt;&#123;allPrimes.join(', ')&#125;&lt;/span&gt; &lt;/p&gt; &lt;/&gt; );&#125;// 计算给定数字是否是素数的 Helper 函数function isPrime(n) &#123; const max = Math.ceil(Math.sqrt(n)); if (n === 2) &#123; return true; &#125; for (let counter = 2; counter &lt;= max; counter++) &#123; if (n % counter === 0) &#123; return false; &#125; &#125; return true;&#125;export default App; 有一个状态，一个叫做 selectedNum 的数字。使用 for 循环，手动计算 0 到 selectedNum 之间的所有素数。呈现一个受控制的数字输入，因此用户可以更改 selectedNum 。向用户显示计算的所有质数。 这段代码需要大量的计算。如果用户选择一个较大的 selectedNum，将需要遍历成千上万个数字，检查是否每个数字都是素数。而且，虽然有比我上面使用的更有效的质数检查算法，但它总是需要大量的计算。 有时确实需要执行这个计算，比如当用户选择一个新的 selectedNum 时。但是可能会遇到一些性能问题，如果在不需要做的时候无偿地做这项工作。 例如，让假设的例子还包含一个数字时钟: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React from 'react';import format from 'date-fns/format';function App() &#123; const [selectedNum, setSelectedNum] = React.useState(100); // time 是一个每秒改变一次的状态变量，因此它总是与当前时间同步。 const time = useTime(); // 计算所有质数（与前面的示例相同） const allPrimes = []; for (let counter = 2; counter &lt; selectedNum; counter++) &#123; if (isPrime(counter)) &#123; allPrimes.push(counter); &#125; &#125; return ( &lt;&gt; &lt;p className=\"clock\"&gt; &#123;format(time, 'hh:mm:ss a')&#125; &lt;/p&gt; &lt;form&gt; &lt;label htmlFor=\"num\"&gt;Your number:&lt;/label&gt; &lt;input type=\"number\" value=&#123;selectedNum&#125; onChange=&#123;(event) =&gt; &#123; // 为了防止太大，将最大值设定在10万 let num = Math.min(100_000, Number(event.target.value)); setSelectedNum(num); &#125;&#125; /&gt; &lt;/form&gt; &lt;p&gt; There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;: &#123;' '&#125; &lt;span className=\"prime-list\"&gt; &#123;allPrimes.join(', ')&#125; &lt;/span&gt; &lt;/p&gt; &lt;/&gt; );&#125;function useTime() &#123; const [time, setTime] = React.useState(new Date()); React.useEffect(() =&gt; &#123; const intervalId = window.setInterval(() =&gt; &#123; setTime(new Date()); &#125;, 1000); return () =&gt; &#123; window.clearInterval(intervalId); &#125; &#125;, []); return time;&#125;function isPrime(n)&#123; const max = Math.ceil(Math.sqrt(n)); if (n === 2) &#123; return true; &#125; for (let counter = 2; counter &lt;= max; counter++) &#123; if (n % counter === 0) &#123; return false; &#125; &#125; return true;&#125;export default App; 的应用程序现在有两个状态，selectedNum 和 time。时间变量每秒更新一次，以反映当前时间，该值用于呈现右上角的数字时钟。 问题在于：每当这些状态变量发生变化时，就会重新运行那些昂贵的质数计算。因为时间每秒改变一次，这意味着不断地重新生成质数列表，即使用户选择的数字没有改变！！！ 在 JavaScript 中，只有一个主线程，通过一遍又一遍地运行这段代码让它非常繁忙，每一秒。这意味着当用户尝试做其他事情时，应用程序可能会感到迟缓，特别是在低端设备上。 但如果可以“跳过”这些计算呢？如果已经有了一个给定数字的质数列表，为什么不重用这个值而不是每次都从头计算呢？这正是 useMemo 允许做的。它看起来是这样的： 123456789const allPrimes = React.useMemo(() =&gt; &#123; const result = []; for (let counter = 2; counter &lt; selectedNum; counter++) &#123; if (isPrime(counter)) &#123; result.push(counter); &#125; &#125; return result;&#125;, [selectedNum]); useMemo 有两个参数： 要执行的工作块，封装在函数中 依赖项列表 在挂载期间，当这个组件第一次呈现时，React 将调用这个函数来运行所有的逻辑，计算所有的质数。无论从这个函数返回什么，都被赋值给 allPrimes 变量。 然而，对于每一个后续渲染，React 都要做出选择。 再次调用函数，重新计算值 重用它上次执行此工作时已经拥有的数据。 为了做出选择，React 查看提供的依赖项列表。对于之前的渲染有任何改变吗？如果是，React 将重新运行提供的函数，以计算一个新的值。否则，它将跳过所有这些工作并重用之前计算的值。 useMemo 本质上类似于缓存，依赖项是缓存失效策略。在本例中，实际上是在说“只有当 selectedNum 发生变化时才重新计算质数列表”。当组件由于其他原因重新呈现时（例如。当时间状态变量发生变化时），useMemo 忽略函数并传递缓存的值。 这通常被称为记忆，这就是为什么这个钩子被称为 useMemo。下面是这个解决方案的实时版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React from 'react';import format from 'date-fns/format';function App() &#123; const [selectedNum, setSelectedNum] = React.useState(100); const time = useTime(); const allPrimes = React.useMemo(() =&gt; &#123; const result = []; for (let counter = 2; counter &lt; selectedNum; counter++) &#123; if (isPrime(counter)) &#123; result.push(counter); &#125; &#125; return result; &#125;, [selectedNum]); return ( &lt;&gt; &lt;p className=\"clock\"&gt; &#123;format(time, 'hh:mm:ss a')&#125; &lt;/p&gt; &lt;form&gt; &lt;label htmlFor=\"num\"&gt;Your number:&lt;/label&gt; &lt;input type=\"number\" value=&#123;selectedNum&#125; onChange=&#123;(event) =&gt; &#123; // 为了防止太大，将最大值设定在10万 let num = Math.min(100_000, Number(event.target.value)); setSelectedNum(num); &#125;&#125; /&gt; &lt;/form&gt; &lt;p&gt; There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;: &#123;' '&#125; &lt;span className=\"prime-list\"&gt; &#123;allPrimes.join(', ')&#125; &lt;/span&gt; &lt;/p&gt; &lt;/&gt; );&#125;function useTime() &#123; const [time, setTime] = React.useState(new Date()); React.useEffect(() =&gt; &#123; const intervalId = window.setInterval(() =&gt; &#123; setTime(new Date()); &#125;, 1000); return () =&gt; &#123; window.clearInterval(intervalId); &#125; &#125;, []); return time;&#125;function isPrime(n)&#123; const max = Math.ceil(Math.sqrt(n)); if (n === 2) &#123; return true; &#125; for (let counter = 2; counter &lt;= max; counter++) &#123; if (n % counter === 0) &#123; return false; &#125; &#125; return true;&#125; 因此，useMemo 钩子确实可以帮助避免这里不必要的计算。但它真的是这里的最佳解决方案吗？通常，可以通过重组应用程序中的内容来避免对 useMemo 的需求。可以这样做： PrimeCalculator.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react';function PrimeCalculator() &#123; const [selectedNum, setSelectedNum] = React.useState(100); const allPrimes = []; for (let counter = 2; counter &lt; selectedNum; counter++) &#123; if (isPrime(counter)) &#123; allPrimes.push(counter); &#125; &#125; return ( &lt;&gt; &lt;form&gt; &lt;label htmlFor=\"num\"&gt;Your number:&lt;/label&gt; &lt;input type=\"number\" value=&#123;selectedNum&#125; onChange=&#123;(event) =&gt; &#123; // 为了防止太大，将最大值设定在10万 let num = Math.min(100_000, Number(event.target.value)); setSelectedNum(num); &#125;&#125; /&gt; &lt;/form&gt; &lt;p&gt; There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;: &#123;' '&#125; &lt;span className=\"prime-list\"&gt; &#123;allPrimes.join(', ')&#125; &lt;/span&gt; &lt;/p&gt; &lt;/&gt; );&#125;function isPrime(n)&#123; const max = Math.ceil(Math.sqrt(n)); if (n === 2) &#123; return true; &#125; for (let counter = 2; counter &lt;= max; counter++) &#123; if (n % counter === 0) &#123; return false; &#125; &#125; return true;&#125;export default PrimeCalculator; Clock.js 123456789101112131415161718192021222324252627282930import React from 'react';import format from 'date-fns/format';function Clock() &#123; const time = useTime(); return ( &lt;p className=\"clock\"&gt; &#123;format(time, 'hh:mm:ss a')&#125; &lt;/p&gt; );&#125;function useTime() &#123; const [time, setTime] = React.useState(new Date()); React.useEffect(() =&gt; &#123; const intervalId = window.setInterval(() =&gt; &#123; setTime(new Date()); &#125;, 1000); return () =&gt; &#123; window.clearInterval(intervalId); &#125; &#125;, []); return time;&#125;export default Clock; App.js 123456789101112131415import React from 'react';import Clock from './Clock';import PrimeCalculator from './PrimeCalculator';function App() &#123; return ( &lt;&gt; &lt;Clock /&gt; &lt;PrimeCalculator /&gt; &lt;/&gt; );&#125;export default App; 我提取了两个新组件，Clock 和 PrimeCalculator。通过从 App 分支，这两个组件各自管理自己的状态。一个组件中的重新渲染不会影响另一个组件。 或许你听到很多关于提升状态的说法，但有时，更好的方法是将状态向下推。每个组件应该有一个单独的职责，在上面的例子中，App 正在做两件完全不相关的事情。 现在，这并不总是一个选择。在一个大型的现实应用中，有许多状态需要向上提升，而不能向下推。对于这种情况，我还有另一个妙计。让看一个例子。假设需要将 time 变量提升到 PrimeCalculator 之上： PrimeCalculator.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react';function PrimeCalculator() &#123; const [selectedNum, setSelectedNum] = React.useState(100); const allPrimes = []; for (let counter = 2; counter &lt; selectedNum; counter++) &#123; if (isPrime(counter)) &#123; allPrimes.push(counter); &#125; &#125; return ( &lt;&gt; &lt;form&gt; &lt;label htmlFor=\"num\"&gt;Your number:&lt;/label&gt; &lt;input type=\"number\" value=&#123;selectedNum&#125; onChange=&#123;(event) =&gt; &#123; // 为了防止太大，将最大值设定在10万 let num = Math.min(100_000, Number(event.target.value)); setSelectedNum(num); &#125;&#125; /&gt; &lt;/form&gt; &lt;p&gt; There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;: &#123;' '&#125; &lt;span className=\"prime-list\"&gt; &#123;allPrimes.join(', ')&#125; &lt;/span&gt; &lt;/p&gt; &lt;/&gt; );&#125;function isPrime(n)&#123; const max = Math.ceil(Math.sqrt(n)); if (n === 2) &#123; return true; &#125; for (let counter = 2; counter &lt;= max; counter++) &#123; if (n % counter === 0) &#123; return false; &#125; &#125; return true;&#125;export default PrimeCalculator; Clock.js 123456789101112import React from 'react';import format from 'date-fns/format';function Clock(&#123; time &#125;) &#123; return ( &lt;p className=\"clock\"&gt; &#123;format(time, 'hh:mm:ss a')&#125; &lt;/p&gt; );&#125;export default Clock; App.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React from 'react';import &#123; getHours &#125; from 'date-fns';import Clock from './Clock';import PrimeCalculator from './PrimeCalculator';// 将的PrimeCalculator转换为一个纯组件const PurePrimeCalculator = React.memo(PrimeCalculator);function App() &#123; const time = useTime(); // 根据一天中的时间选择一个合适的背景色 const backgroundColor = getBackgroundColorFromTime(time); return ( &lt;div style=&#123;&#123; backgroundColor &#125;&#125;&gt; &lt;Clock time=&#123;time&#125; /&gt; &lt;PurePrimeCalculator /&gt; &lt;/div&gt; );&#125;const getBackgroundColorFromTime = (time) =&gt; &#123; const hours = getHours(time); if (hours &lt; 12) &#123; // 早晨用的淡黄色 return 'hsl(50deg 100% 90%)'; &#125; else if (hours &lt; 18) &#123; // 下午暗淡的蓝色 return 'hsl(220deg 60% 92%)' &#125; else &#123; // 夜晚的深蓝色 return 'hsl(220deg 100% 80%)'; &#125;&#125;function useTime() &#123; const [time, setTime] = React.useState(new Date()); React.useEffect(() =&gt; &#123; const intervalId = window.setInterval(() =&gt; &#123; setTime(new Date()); &#125;, 1000); return () =&gt; &#123; window.clearInterval(intervalId); &#125; &#125;, []); return time;&#125;export default App; React.memo 包在组件周围，保护它免受不相关的更新。PurePrimeCalculator 只有在接收到新数据或内部状态发生变化时才会重新呈现。这就是所谓的纯组件。本质上，告诉 React 这个组件将总是在相同的输入条件下产生相同的输出，可以跳过没有任何改变的重新呈现。 在上面的例子中，我应用了 React.memo 到导入的 PrimeCalculator 组件。事实上,我选择了这样的结构，以便所有内容都在同一个文件中可见，以便更容易理解。在实践中，使用 React.memo 组件导出，如下所示： 12345// PrimeCalculator.jsfunction PrimeCalculator() &#123; /* 这里的组件内容 */&#125;export default React.memo(PrimeCalculator); 的 PrimeCalculator 组件现在将始终是纯的，当要使用它时，不需要对它进行修补。 这里有一个视角转换：之前，在记忆一个特定计算的结果，计算质数。然而，在本例中，我记住了整个组件。无论哪种方式，只有当用户选择一个新的 selectedNum 时，昂贵的计算才会重新运行。但优化的是父组件，而不是特定的慢代码行。 我并不是说一种方法比另一种更好；每种工具在工具箱中都有自己的位置。但在这个特定的情况下，我更喜欢这种方法。现在，如果您曾经尝试在现实世界的设置中使用纯组件，您可能会注意到一些特殊的东西：纯组件经常重新渲染相当多，即使看起来没有任何变化！这很好地将引入了 useMemo 解决的第二个问题。 3. 示例2：保留引用在下面的示例中，我创建了一个 Boxes 组件。它展示了一组彩色的盒子，用于某种装饰目的。我还有一个不相关的状态：用户名。 Boxes.js 1234567891011121314151617import React from 'react';function Boxes(&#123; boxes &#125;) &#123; return ( &lt;div className=\"boxes-wrapper\"&gt; &#123;boxes.map((boxStyles, index) =&gt; ( &lt;div key=&#123;index&#125; className=\"box\" style=&#123;boxStyles&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default React.memo(Boxes); App.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React from 'react';import Boxes from './Boxes';function App() &#123; const [name, setName] = React.useState(''); const [boxWidth, setBoxWidth] = React.useState(1); const id = React.useId(); // 尝试改变这些值 const boxes = [ &#123; flex: boxWidth, background: 'hsl(345deg 100% 50%)' &#125;, &#123; flex: 3, background: 'hsl(260deg 100% 40%)' &#125;, &#123; flex: 1, background: 'hsl(50deg 100% 60%)' &#125;, ]; return ( &lt;&gt; &lt;Boxes boxes=&#123;boxes&#125; /&gt; &lt;section&gt; &lt;label htmlFor=&#123;`$&#123;id&#125;-name`&#125;&gt; Name: &lt;/label&gt; &lt;input id=&#123;`$&#123;id&#125;-name`&#125; type=\"text\" value=&#123;name&#125; onChange=&#123;(event) =&gt; &#123; setName(event.target.value); &#125;&#125; /&gt; &lt;label htmlFor=&#123;`$&#123;id&#125;-box-width`&#125;&gt; First box width: &lt;/label&gt; &lt;input id=&#123;`$&#123;id&#125;-box-width`&#125; type=\"range\" min=&#123;1&#125; max=&#123;5&#125; step=&#123;0.01&#125; value=&#123;boxWidth&#125; onChange=&#123;(event) =&gt; &#123; setBoxWidth(Number(event.target.value)); &#125;&#125; /&gt; &lt;/section&gt; &lt;/&gt; );&#125;export default App; 由于在 boxes.js 中使用了React.memo() 封装默认导出，Boxes 是一个纯组件。这意味着它应该只在它的props改变时重新渲染。然而，每当用户更改其名称时，Boxes 也会重新呈现。 为什么的 React.memo() 没有保护？盒子组件只有1个prop，盒子，它看起来好像给它在每次渲染完全相同的数据。总是一样的东西：一个红盒子，一个紫色的宽盒子，一个黄色的盒子。确实有一个影响boxes 数组的 boxWidth 状态变量，但没有更改它！ 问题在于：每次 React 重新渲染时，都会生成一个全新的数组。它们在值上是相等的，但在参照物上是不同的。我想如果先不谈 React，只谈普通的 JavaScript，会很有帮助。让来看一个类似的情况： 123456function getNumbers() &#123; return [1, 2, 3];&#125;const firstResult = getNumbers();const secondResult = getNumbers();console.log(firstResult === secondResult); 你怎么看？firstResult 是否等于 secondResult？从某种意义上说，的确如此。两个变量都具有相同的结构[1,2,3]。但这不是 === 运算符实际检查的内容。相反，=== 检查两个表达式是否相同。已经创建了两个不同的数组。它们可能包含相同的内容，但它们不是同一个数组。 每次调用 getNumbers 函数时，都会创建一个全新的数组，它是保存在计算机内存中的一个不同的东西。如果多次调用它，将在内存中存储该数组的多个副本。注意，简单的数据类型——比如字符串、数字和布尔值——可以按值进行比较。但是当涉及到数组和对象时，它们只能通过引用进行比较。 让回到 React：的 Boxes React组件也是一个 JavaScript 函数。当渲染它时，调用那个函数： 12345678910111213// 每次渲染这个组件时，调用这个函数…function App() &#123; // 最后创造了一个全新的数组 const boxes = [ &#123; flex: boxWidth, background: 'hsl(345deg 100% 50%)' &#125;, &#123; flex: 3, background: 'hsl(260deg 100% 40%)' &#125;, &#123; flex: 1, background: 'hsl(50deg 100% 60%)' &#125;, ]; // .然后将其作为 prop 传递给该组件! return ( &lt;Boxes boxes=&#123;boxes&#125; /&gt; );&#125; 当名称状态改变时，的 App 组件将重新呈现，这将重新运行所有的代码。构造一个全新的 boxes 数组，并将其传递给的 Boxes 组件。从而导致盒子重新渲染，因为给了它一个全新的数组。盒子数组的结构在渲染之间没有改变，但这无关紧要。React 所知道的是，箱子 prop 已经收到了一个新创建的，从未见过的数组。要解决这个问题，可以使用 useMemo hook： 1234567const boxes = React.useMemo(() =&gt; &#123; return [ &#123; flex: boxWidth, background: 'hsl(345deg 100% 50%)' &#125;, &#123; flex: 3, background: 'hsl(260deg 100% 40%)' &#125;, &#123; flex: 1, background: 'hsl(50deg 100% 60%)' &#125;, ];&#125;, [boxWidth]); 与之前看到的质数例子不同，这里不担心计算成本很高的计算。的唯一目标是保留对特定数组的引用。将 boxWidth 列为一个依赖项，因为确实希望在用户调整红色框的宽度时重新呈现 Boxes 组件。然而，在 useMemo 中，重用了之前创建的 boxes 数组。 通过在多个渲染中保留相同的引用，允许纯组件按希望的方式工作，忽略不影响 UI 的渲染。 4. useCallback前面了解了 useMemo。那 useCallback 呢？这是一个简短的版本：这是完全相同的事情，但用于函数而不是数组/对象。与数组和对象类似，函数是根据引用比较的，而不是根据值： 1234567const functionOne = function() &#123; return 5;&#125;;const functionTwo = function() &#123; return 5;&#125;;console.log(functionOne === functionTwo); // false 这意味着，如果在组件中定义一个函数，它将在每次渲染时重新生成，每次生成一个相同但唯一的函数。让看一个例子： MegaBoost.js 12345678910111213141516import React from 'react';function MegaBoost(&#123; handleClick &#125;) &#123; console.log('Render MegaBoost'); return ( &lt;button className=\"mega-boost-button\" onClick=&#123;handleClick&#125; &gt; MEGA BOOST! &lt;/button&gt; );&#125;export default React.memo(MegaBoost); App.js 123456789101112131415161718192021222324252627import React from 'react';import MegaBoost from './MegaBoost';function App() &#123; const [count, setCount] = React.useState(0); function handleMegaBoost() &#123; setCount((currentValue) =&gt; currentValue + 1234); &#125; return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125; &gt; Click me! &lt;/button&gt; &lt;MegaBoost handleClick=&#123;handleMegaBoost&#125; /&gt; &lt;/&gt; );&#125;export default App; 这个栗子描述了一个典型的计数器应用程序，但有一个特殊的“Mega Boost”按钮。这个按钮大大增加了计数，以防你很匆忙，不想多次点击标准按钮。 多亏了 React.memo, MegaBoost 组件是一个纯组件。它不依赖于计数，但每当计数改变时它就会重新呈现！就像看到的盒子数组，这里的问题是在每个渲染上生成一个全新的函数。如果渲染 3 次，将创建 3 个单独的 handleMegaBoost 函数，突破 React.memo的保护。利用对 useMemo 的了解，可以像这样解决问题： 12345const handleMegaBoost = React.useMemo(() =&gt; &#123; return function() &#123; setCount((currentValue) =&gt; currentValue + 1234); &#125;&#125;, []); 返回的不是一个数组，而是一个函数。然后将此函数存储在 handleMegaBoost 变量中。这很有效，但还有更好的方法： 123const handleMegaBoost = React.useCallback(() =&gt; &#123; setCount((currentValue) =&gt; currentValue + 1234);&#125;, []); useCallback 的作用与 useMemo 相同，但它是专门为函数构建的。直接给它一个函数，它记住那个函数，在渲染之间进行线程处理。换句话说，这两个表达有相同的效果： 123React.useCallback(function helloWorld()&#123;&#125;, []);// 在功能上等价于React.useMemo(() =&gt; function helloWorld()&#123;&#125;, []); useCallback 是语法糖。它的存在纯粹是为了让在记忆回调函数时更加方便。 5. 什么时候使用这些 hook好了，已经看到了 useMemo 和 useCallback 如何允许跨多个渲染线程引用重用复杂的计算或避免破坏纯组件。问题是：应该多经常使用它？ 在我个人看来，将每个对象/数组/函数包装在这些钩子中是浪费时间。在大多数情况下，好处是可以忽略不计的；React 是高度优化的，重新渲染通常不像通常认为的那样缓慢或昂贵！ 使用这些钩子的最佳方式是响应问题。如果你注意到你的应用程序变得有点迟缓，你可以使用 React Profiler 来查找缓慢的渲染。在某些情况下，可以通过重构应用程序来提高性能。在其他情况下，useMemo 和useCallback 可以帮助加快速度。 5.1 用于自定义 hook 内部例如下面这个自定义 hook useToggle，它的工作方式几乎和 useState 完全一样，但只能在 true 和 false 之间切换状态变量： 123456789function App() &#123; const [isDarkMode, toggleDarkMode] = useToggle(false); return ( &lt;button onClick=&#123;toggleDarkMode&#125;&gt; Toggle color theme &lt;/button&gt; );&#125; 下面是如何定义这个自定义 hook 的： 123456789function useToggle(initialValue) &#123; const [value, setValue] = React.useState(initialValue); const toggle = React.useCallback(() =&gt; &#123; setValue(v =&gt; !v); &#125;, []); return [value, toggle];&#125; 注意，toggle 函数是用 useCallback 记忆的。当我构建这样的自定义可重用钩子时，我希望使它们尽可能高效，因为我不知道将来会在哪里使用它们。在95%的情况下，这可能是多余的，但如果我使用这个钩子30或40次，这很有可能有助于提高应用程序的性能。 5.2 在 context 提供者当在具有 context 的应用程序之间共享数据时，通常会传递一个大对象作为 value 属性。记住这个对象通常是个好主意： 1234567891011121314151617const AuthContext = React.createContext(&#123;&#125;);function AuthProvider(&#123; user, status, forgotPwLink, children &#125;)&#123; const memoizedValue = React.useMemo(() =&gt; &#123; return &#123; user, status, forgotPwLink, &#125;; &#125;, [user, status, forgotPwLink]); return ( &lt;AuthContext.Provider value=&#123;memoizedValue&#125;&gt; &#123;children&#125; &lt;/AuthContext.Provider&gt; );&#125; 为什么这是有益的？可能有几十个纯组件使用这个上下文。如果没有 useMemo，如果 AuthProvider 的父组件碰巧重新渲染，那么所有这些组件都将被迫重新渲染。","categories":[],"tags":[]},{"title":"Vue的响应式原理","slug":"2021/Vue的响应式原理","date":"2021-05-07T01:07:32.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2021/Vue的响应式原理/","link":"","permalink":"https://summxu.github.io/2021/Vue的响应式原理/","excerpt":"","text":"vue2使用Object.defineProperty实现响应式 遍历属性，对每一个属性的值用Object.defineProperty进行getter和setter的改造； 123456789101112131415161718192021222324252627282930313233343536373839404142//getfunction track(data, key)&#123; console.log('get data:', key)&#125;// setfunction trigger(data, key, value)&#123; console.log('set data:', key,'-', value)&#125;function observe(data)&#123; if(!data || typeof data !== 'object') return for(let key in data)&#123; let value = data[key] Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get()&#123; track(data, key) return value &#125;, set(newVal)&#123; trigger(data, key, newVal) value = newVal &#125; &#125;) if(typeof value === 'object')&#123; observe(value) &#125; &#125;&#125;var obj = &#123; name: 'win', family: [2,5,8]&#125;observe(obj)obj.name = 'ten'obj.family[3] = 6 //不是响应式，没有被Object.defineProperty包装一下obj.age = 18 //不是响应式，没有被Object.defineProperty包装一下console.log(obj, 'obj') Vue3相对于Vue2响应式原理也发生了变化，由原先的 Object.defineproperty 改成了使用 Proxy 替代。Proxy 相对于 Object.defineproperty 有以下几个优化点： 对象新增属性不再需要手动 $set 添加响应式，Proxy 默认会监听动态添加属性和属性的删除等操作。 消除无法监听数组索引，length 属性等等，不再需要在数组原型对象上重写数组的方法。 Object.defineproperty 是劫持所有对象属性的 get/set 方法,需要遍历递归去实现，Proxy 是代理整个对象。 Vue2 只能拦截对象属性的 get 和 set 操作,而 Proxy 拥有 13 种拦截方法。 Vue3中的响应式原理实现原理： 通过Proxy（代理）： 拦截对象中任意属性的变化，包括：属性值的读写，属性的增加，属性的删除等。 通过Reffect（反射）： 对源对象的属性进行操作 Proxy Proxy对象对于创建一个对象的代理，也可以理解成在对象前面设了一层拦截，可以实现基本操作的拦截和一些自定义操作（比如一些赋值、属性查找、函数调用等）； 用法：var proxy = new Proxy(target, handler);target：目标函数（即进行改造的函数）；handler：一些自定义操作（比如vue中getter和setter的操作）； Reflect Reflect是es6为操作对象而提供的新API，设计它的目的有：① 把Object对象上一些明显属于语言内部的方法放到Reflect对象身上，比如Object.defineProperty；② 修改了某些object方法返回的结果；③ 让Object操作都变成函数行为；④ Reflect对象上的方法和Proxy对象上的方法一一对应，这样就可以让Proxy对象方便地调用对应的Reflect方法； Reflect.get(target, propertyKey, receiver)：等价于target[propertyKey]，Reflect.get方法查找并返回target对象的propertyKey属性，如果没有该属性，则返回undefined。 Reflect.set(target, propertyKey, value, receiver)：等价于target[propertyKey] = value，Reflect.set方法设置target对象的propertyKey属性等于value。 Proxy和Reflect的使用123456789101112131415161718const obj = &#123; name: 'win'&#125;const handler = &#123; get: function(target, key)&#123; console.log('get--', key) return Reflect.get(...arguments) &#125;, set: function(target, key, value)&#123; console.log('set--', key, '=', value) return Reflect.set(...arguments) &#125;&#125;const data = new Proxy(obj, handler)data.name = 'ten'console.log(data.name,'data.name22') 使用Proxy和Reflect完成响应式12345678910111213141516171819202122232425262728293031323334353637function track(target, key)&#123; console.log('get--', key)&#125;function trigger(target, key, value)&#123; console.log('set--', key, '=', value)&#125;function reactive(obj)&#123; const handler = &#123; get(target, key, receiver)&#123; track(target, key) const value = Reflect.get(...arguments) if(typeof value === 'object')&#123; return reactive(value) &#125;else&#123; return value &#125; &#125;, set(target, key, val, receiver)&#123; trigger(target, key, val) return Reflect.set(...arguments) &#125; &#125; return new Proxy(obj, handler)&#125;const obj = &#123; name: 'win'&#125;const data = reactive(obj)data.list = [5] //响应式 这两句话是执行Reflect.set()data.age = 18 //响应式console.log(data, 'data111')","categories":[],"tags":[]},{"title":"ReactNative踩坑记","slug":"2020/ReactNative踩坑记","date":"2020-07-21T04:16:24.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2020/ReactNative踩坑记/","link":"","permalink":"https://summxu.github.io/2020/ReactNative踩坑记/","excerpt":"","text":"最近在使用react-native的时候遇到了很多坑,这里记录一下样式react-native 虽然支持flex布局，但是所有的样式均是css样式的一个很小的集合，尤其是在安卓机下问题尤为凸显： View内部的元素千万不要超出父级的范围，iso上问题倒是不大，安卓上就什么超出的都看不到了 lineHeight 可以用，不过千万不要写成小数，否则安卓上会直接崩溃 rn的样式不存在继承的情况，所以基本上每个节点都要写style，真的是体力活 如果Text的父级元素设置了背景颜色，那么ios下Text的背景颜色也是父级的背景颜色，要么自己写个Text重置下样式，要么就遇到了再改 react-native的字号是没有设置单位的，所以会随着系统设置的字体大小而变化，我也不知道这是不是坑，不过貌似有的app也没有管这个，如果硬要去设置Text的文字不随系统改变，安卓是可以统一设置的，ios上Text设置allowFontScaling ={false}就可以解决 异常react-native 在发生js异常的时候，debug的时候会直接红屏幕，但是再release的时候直接会崩溃退出，解决办法 1234import ErrorUtils from \"ErrorUtils\" &lt;br&gt;//这里应该做个判断，如果不是debug的才做这样的异常全局处理ErrorUtils.setGlobalHandler((e)=&gt;&#123;&lt;br&gt; //发生异常的处理方法,当然如果是打包好的话可能你找都找不到是哪段代码出问题了 Alert.alert(\"异常\",JSON.stringify(e))&#125;); fetchreact-native虽然自带有fetch，不过在使用的时候发现了一个问题，如果需要获取http的header头的时候问题就来了，可能得到的是一些千奇百怪的样式，这并不是react-native的错，而是第三方的 whatwg-fetch 留下的坑，当然也有人再github上跟react-native反映过这个问题，不过得到的解决方案都很坑，唯有一个办法，就是拷贝自己修改，修改如下: 注释该注释的 123456(function(self) &#123; 'use strict'; //注释这里，不然总是用的是全局的fetch // if (self.fetch) &#123; // return // &#125; 修改该修改的 1234567891011121314function parseHeaders(rawHeaders) &#123; var headers = new Headers()&lt;br&gt; //把\\t\\n改成\\t，因为一般header都是用\\n来分割的 rawHeaders.split('\\n').forEach(function(line) &#123; //rawHeaders.split('\\t\\n').forEach(function(line) &#123; var parts = line.split(':') var key = parts.shift().trim() if (key) &#123; var value = parts.join(':').trim() headers.append(key, value) &#125; &#125;) &#125; return headers&#125; 直接import你改好的文件，fetch就可以用了 ModalMode控件在使用的时候要注意了，因为这个是rn提供的，并且也写的很清楚是最高层级的一个弹出层，所以你想要又打开Model又要跳转基本是无望的了，所以建议不要使用这个，最好是使用第三方的控件，我们用的是 react-native-modalbox + 高阶控件 实现的全遮盖的弹出层 点击屏幕其他位置关闭的菜单这类菜单有个共同的特点就是点击屏幕其他地方然后菜单就关闭，我们的解决办法就是用自己写的 react-native-modalbox + 高阶控件 也就是说放在一个弹出层里面，当然可以试试把当前页面套进一个大的 TouchableWithoutFeedback 里面 接口请求非特殊情况下都应该这样做 123456import &#123;InteractionManager&#125; from \"react-native\"componentDidMount()&#123; InteractionManager.runAfterInteractions(() =&gt; &#123; fetch(\"xxx.xxx.xxx\",&#123;&#125;) &#125;); &#125; 键盘官方提供的自定义隐藏键盘的方法是 12import &#123; Keyboard &#125; from 'react-native'Keyboard.dismiss() 但是我试了很多次之后发现根本不能，而且还报错，楼主的react-native版本是0.35.0 看了官方的issue才知道这个不行，推荐下面方法 1import dismissKeyboard from 'dismissKeyboard'dismissKeyboard() 这样就可以隐藏了，太坑了 还有个很坑的地方，官方提供的移除键盘事件的方法不可用 1234componentDidMount () &#123; Keyboard.addListener('keyboardDidShow', this.keyboardDidShow.bind(this)) Keyboard.addListener('keyboardDidHide', this.keyboardDidHide.bind(this))&#125;componentWillUnmount () &#123; Keyboard.removeAllListeners('keyboardDidShow') Keyboard.removeAllListeners('keyboardDidHide')&#125; 这样的方式特么的如果操作快了，或者有时候莫名其妙的就会出错,下面的才是正确的打开方式： 12345678componentDidMount () &#123; this.keyboardDidShowListener = Keyboard.addListener('keyboardDidShow', this.keyboardDidShow.bind(this)) this.keyboardDidHideListener = Keyboard.addListener('keyboardDidHide', this.keyboardDidHide.bind(this))&#125;componentWillUnmount () &#123; this.keyboardDidShowListener.remove() this.keyboardDidHideListener.remove()&#125; httpshttps这个问题上ios还好，安卓问题就来了，前期我们准备将ajax请求的库丢给原生安卓和ios来做我们直接调用就是了，但是后来发现问题这样那样的问题太多了， 所以在热更新服务器启动或者打包的时候就把源代码先改了在进行打包或者启动服务器 文件位置： 1node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java 这个文件的最后一个方法修改如下： 12345678910111213141516private static OkHttpClient createClient() &#123; // No timeouts by default return new OkHttpClient.Builder() .sslSocketFactory(sslContext.getSocketFactory()) .hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; //忽略所有的认证，直接返回了true &#125; &#125;) .connectTimeout(0, TimeUnit.MILLISECONDS) .readTimeout(0, TimeUnit.MILLISECONDS) .writeTimeout(0, TimeUnit.MILLISECONDS) .cookieJar(new ReactCookieJarContainer()) .build();&#125; 修改源代码的方式有点略坑，不过可以解决很多问题，还节约时间！！！ BackAndroid安卓机有独特的点击按键返回，所以在最外层会注册一个监听方法 123456789101112131415161718192021222324252627282930313233bindHardwareBackPress()&#123; if (Platform.OS === 'android') &#123; BackAndroid.addEventListener('hardwareBackPress', this._onHomeBackPress); &#125;&#125; onHomeBackPress()&#123; let routeList = this.getRouteList(); if (routeList.length !== 1) &#123; this.navigator.pop(); return true; &#125; this.handleHomeBackPress(); return true;&#125; handleHomeBackPress()&#123; if (Platform.OS === \"android\") &#123; ToastAndroid.show(\"再按一次退出应用\", ToastAndroid.SHORT); BackAndroid.removeEventListener(\"hardwareBackPress\", this._onHomeBackPress); BackAndroid.addEventListener(\"hardwareBackPress\", this._onExitApp); this.timer = TimerMixin.setInterval(() =&gt; &#123; TimerMixin.clearInterval(this.timer); BackAndroid.removeEventListener(\"hardwareBackPress\", this._onExitApp); BackAndroid.addEventListener(\"hardwareBackPress\", this._onHomeBackPress); &#125;, 2000); &#125;&#125; exitApp()&#123; BackAndroid.exitApp();&#125; 上面的代码是监听返回键，如果不是在最外层的路由就返回上一个,如果在最外层就直接关闭app，但是有很多这样那样的需求要去对安卓的返回键进行操作，坑就来了，你以为提供的removeEventListener方法是没问题的？no ！！！ 他会移除所有的监听，这是不是很坑！！！！ 所以：在需要对安卓返回键进行特殊处理的时候记得其他地方做了监听的再重新监听一次！！！！","categories":[],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://summxu.github.io/tags/ReactNative/"}]},{"title":"HTTP缓存-ETag","slug":"2019/http-cache-etag","date":"2019-08-10T12:44:11.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/http-cache-etag/","link":"","permalink":"https://summxu.github.io/2019/http-cache-etag/","excerpt":"","text":"最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。 ETag验证缓存的响应在本地通过 express 启了一个非常简单的个服务，具体如下 1234567891011// app.jsconst express = require('express');const app = express();app.get('/', (req, res) =&gt; &#123; res.send('hello http')&#125;)app.listen(3000, () =&gt; &#123; console.log('The server is running at http://127.0.0.1:3000/')&#125;) 但是仔细看却发现，第一次进入页面http://127.0.0.1:3000/时，Status为200而再次刷新发现Status却是304 仔细对比发现 第一次请求时候请求参数中并没有 If-None-Match 字段但是却有个Pragma；同时在请求的Response中有一个 ETag: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg”字段。 刷新页面后再次请求在请求头中却有个 *If-None-Match: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg” *，If-None-Match 的值和第一次请求的ETag的值相同。 经过查询才了解原理浏览器会根据HTTP请求的ETag验证请求的资源是否发生了改变，如果它未发生变化，服务器将返回“304 Not Modified”响应，并且资源从浏览器缓存中读取，这样就不必再次下载请求。 由此看来整个的过程就是下面这样： 如果缓存中有ETag 令牌，客户端请求时会自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。 服务器根据当前资源核对令牌，验证是否发生变化，将验证结果通知给客户端，客户端根据结果看看是否需要从缓存中读取还是发送资源请求。 补充一个很直白的 TCP协议的三次握手 的理解。 为了验证查证的结果，我又添加一个请求处理。这个过程是，客户端明确返回一个ETag, 但是这里每次请求的的返回值都不相同，这里简单的使用了个etag++。 1234567891011121314151617181920// app.jsconst express = require('express');const app = express();app.get('/', (req, res) =&gt; &#123; res.send('hello http');&#125;)// 验证ETaglet etag = 0;app.get('/test', (req, res) =&gt; &#123; etag++; res.set('ETag', etag); res.send('ETag');&#125;)app.listen(3000, () =&gt; &#123; console.log('The server is running at http://127.0.0.1:3000/')&#125;) 查看下 /test 地址的请求结果，会发现If-None-Match 的值和 Response中的 ETag值每次都不相同，并且是 浏览器会将每次的 ETag 值都缓存起来在下次请求的时候发送给服务器。这样一来，每次服务器每次校验的值都是不相同的，所以这种就没有做缓存，因此每次请求 /test 地址都是 200 的状态。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://summxu.github.io/tags/网络/"}]},{"title":"fixed 定位失效 与 CSS 层叠上下文","slug":"2019/fixed-stacking-context","date":"2019-05-22T15:38:51.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/fixed-stacking-context/","link":"","permalink":"https://summxu.github.io/2019/fixed-stacking-context/","excerpt":"","text":"第一部分，position: fixed失效的问题；第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。 关于 position: fixedposition: fixed 在日常布局中比较常用，如移动端头部和底部导航定位、模态框、悬浮按钮等，设置了这个属性值得元素会相对于屏幕视口（viewport）进行定位，其位置在屏幕进行滚动时会保持不变，不占用文档流中的位置，而且打印时这个元素会出现在 每一页 的相同位置。设置了 position: fixed 的元素最终的位置由它的 top, right, bottom, left 来决定，这个值会创建一个新的 stacking context但是，有些情况下，这种定位方式会失效，使得元素相对于视窗定位的定位不符合预期（其实是 fixed 定位的参考元素变了）。当该元素的父元素中（广义，包含祖先元素）有元素的 transform 或 perspective 的值不是 none，该元素就会相对于这个父元素而不是视口进行定位。具体的原因是这样： Specifying a value other than none for the transform property establishes a new local coordinate system at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element’s transformation matrix. Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent. From the perspective of the user, an element effectively accumulates all the transform properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a current transformation matrix for the element. 解释一下，transform 或 perspective 的非 none 值会影响元素的包含块和层叠上下文，这些值会在应用它的元素上建立一个局部的坐标系（X轴向右水平增加; Y轴垂直向下增加），由变换矩阵（transform 的值）给出元素到该局部坐标系的映射，而且 transform 带来的局部坐标系的改变是可以累积的——也就是说，子元素会在它的父元素的坐标系内建立子元素自己的局部坐标系：父元素的 transform 们一层层积累定义了子元素当前的变换矩阵（一个元素的变换矩阵是从 transform 和 transform-origin 属性中计算出来的），步骤如下： 通过 transform-origin 的值对坐标原点 X 和 Y 的位置进行转换 以变换后的 X、Y 为坐标原点原点，根据 transform 的属性值进行变换 X 和 Y 根据 transform-origin 的相反值平移回去 如图 transform 会影响最终的渲染效果，但是不影响除overflow外的CSS布局，当通过 getClientRects()、getBoundingClientRect() 这些接口获取 client rectangles 时，transform 的效果也会被考虑进去。 可以应用 transform 的元素（transformable elements）有： 满足CSS盒模型的块级元素或行内元素，或者它的 display 值为 table-row, table-row-group, table-header-group, table-footer-group, table-cell, table-caption 中的一个 SVG 命名空间中具有 transform, patternTransform 或 gradientTransform 属性的元素 p.s. 关于上面的应用transform后元素位置的计算方式。原文如下： Start with the identity matrix. Translate by the computed X and Y of transform-origin Multiply by each of the transform functions in transform property from left to right Translate by the negated computed X and Y values of transform-origin 参考文档： The transform Property - W3C Working Draft - 30 November 2017 The Transform Rendering Model - W3C Working Draft - 30 November 2017 层叠上下文 Stacking Context通过上文我们知道了有层叠上下文这么一个东西，层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。和BFC还有IFC这些xx context一样，创建层叠上下文也是有条件的，文档中的层叠上下文由满足以下任意一个条件的元素形成： 根元素 (HTML), z-index 值不为 auto 的 绝对/相对定位元素 position 不是 static 的元素（sticky 也会创建层叠上下文，这是一个神奇的实验中的属性值） 一个 z-index 值不为 auto 的 flex 项目 (flex item) opacity 属性值小于 1 的元素（参考 the specification for opacity） transform 属性值不为 none 的元素 mix-blend-mode 属性值不为 normal 的元素 有 transform、filter、perspective、clip-path、mask / mask-image / mask-border 这些属性中任意一个或多个属性的元素 isolation 属性被设置为 isolate的元素 在 will-change 中指定了任意CSS` 属性的元素（即使没有直接指定这些属性的值） -webkit-overflow-scrolling 属性被设置 touch的元素 设置了 transform-style: preserve-3d 的元素 在层叠上下文中的子元素也会按照上面的规则进行层叠，子元素的 z-index 值只在父级层叠上下文中有意义，子级层叠上下文被自动视为父级层叠上下文的一个独立单元。 但是，并不是创建了新的层叠上下文的元素并不一定都会对其拥有position: fixed的子元素的效果产生影响，在Chrome（Blink内核）中，可以明确看到产生了影响的是： transform 属性值不为 none 的元素 设置了 transform-style: preserve-3d 的元素 perspective 值不为 none 的元素 在 will-change 中指定了任意 CSS 属性的元素 但是，在不同的浏览器内核下，上述结论也会有所差异，例如，在 Safari（Webkit内核） 中，只有transform 属性值不为 none 的元素会对 fixed 定位的效果产生影响. 参考文档： the specification for opacity - W3C The stacking context - MDN","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}]},{"title":"css3 transform对普通元素的n多渲染影响","slug":"2019/transform-element-impact","date":"2019-05-18T15:15:18.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/transform-element-impact/","link":"","permalink":"https://summxu.github.io/2019/transform-element-impact/","excerpt":"","text":"问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 position:fixed 无效，问题是因为dilog定位时用了transform，深究下问题原因，发现事情并不是这么简单！ 一个普普通通的元素，如果应用了CSS3 transform变换，即便这个transform属性值不会改变其任何表面的变化（如scale(1), translate(0,0)），但是，实际上，对这些元素还是造成了很深远的影响。 transform提升元素的垂直地位当遭遇元素margin负值重叠的时候，如果没有static以外的position属性值的话，后面的元素是会覆盖前面的元素的。img src=&quot;mm1&quot;&gt;&lt;img src=&quot;mm2&quot; style=&quot;margin-left:-60px;&quot;&gt;在transform出现之前，这个规则一直很稳健；但是，自从transform降临，这个规则就变了。元素应用了transform属性之后，就会变得应用了position:relative一个尿性，原本应该被覆盖的元素会雄起，变成覆盖其他元素，修改为如下代码： 12&lt;img src=\"mm1\" style=\"-ms-transform:scale(1);transform:scale(1);\"&gt;&lt;img src=\"mm2\" style=\"margin-left:-60px;\"&gt; 只要是支持transform元素的浏览器，包括IE9(-ms-), 都会提高普通元素的垂直地位，使其覆盖其他元素而不是被覆盖。 这种特性底层原理是层叠上下文，具体可参见“深入理解CSS中的层叠上下文和层叠顺序”一文。 transform限制position:fixed的跟随效果我们应该都知道，position:fixed可以让元素不跟随浏览器的滚动条滚动，而且这种跟随效果连它的兄弟们position:relative/absolute都限制不了。但是，真是一物降一物，position:fixed固定效果却被小小的transform给干掉了，直接降级变成position:absolute的蛋疼表现。 例如下面示意代码： &lt;p style=&quot;transform:scale(1);&quot;&gt;&lt;img src=&quot;mm1.jpg&quot;style=&quot;position:fixed;&quot; /&gt;&lt;/p&gt;结果，本来应该不跟着滚动条滚动的傲娇fixed元素，变成absolute一样的行为表现，归根结底就是父元素加了个小小的transform属性值。 注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有，IE浏览器，包括IE11, fixed还是fixed的表现。 transform改变overflow对absolute元素的限制在以前，overflow与absolute之间的限制规范内容大致是这样的： absolute绝对定位元素，如果含有overflow不为visible的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有position为非static属性的声明，则overflow对该absolute元素不起作用。 比方说如下示意代码： 123&lt;p style=\"width:96px; height:96px; border:2px solid #beceeb; overflow:hidden;\"&gt; &lt;img src=\"mm1.jpg\"style=\"position:absolute;\" /&gt;&lt;/p&gt; 但是，一旦我们给overflow容器或者与图片有嵌套关系的子元素使用transform声明，估计absolute元素就要去领便当了！ 无论是overflow容器还是嵌套子元素，只要有transform属性，就会hidden溢出的absolute元素。 transform限制absolute的100%宽度大小以前，我们设置absolute元素宽度100%, 则都会参照第一个非static值的position祖先元素计算，没有就window. 现在，需要把transform也考虑在内了。 结果，无论是IE9+，还是Chrome还是FireFox浏览器，所有绝对定位图片100%宽度，都是相对设置了transform的容器计算了，于是，上面的图片拉长到了西伯利亚；下面的图片被限制成了小胖墩。 transform对absolute宽度100%限制~","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}]},{"title":"基于 document.execCommand 的富文本","slug":"2019/rich-text-editor-by-execCommand","date":"2019-04-30T13:05:35.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/rich-text-editor-by-execCommand/","link":"","permalink":"https://summxu.github.io/2019/rich-text-editor-by-execCommand/","excerpt":"","text":"前言最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需求，但其提供的诸多功能是用不上的，可以使用更轻量的实现代替。 在寻找新的替代品时，也顺便瞄了下各种编辑器的内部实现。一些体积庞大的编辑器一般都兼容低版本浏览器，不得不写很多兼容性的代码。而一些 MINI、轻量的编辑器是不对低端浏览器作兼容的，使用Selection、Range或者document.execCommand实现。 之前在 JavaScript 获取输入时的光标位置及场景问题 中提到过Selection和Range，这次就说说document.execCommand。 document.execCommand该方法可以对可编辑器区域进行操作，比如加粗文字、改变字号、插入链接等。可编辑区域也就是设置了contentEditable属性的元素。 12// 语法bool = document.execCommand(commandName, showDefaultUI[, arg]) commandName：String，命令的名称 showDefaultUI：Boolean，是否展示用户界面（暂时没有发现“用户界面”指的是什么），一般为false arg：String，要传递的参数，比如插入链接需要传入一个 URL，可选 返回值：Boolean，表示操作是否支持或是否启用假如要把选中的文字加粗，只需要这样： document.execCommand(&#39;bold&#39;, false) 兼容性[http://static.imys.net/execCommand-support-2017113.jpg] 对于现代浏览器的兼容度较好，不过 Android 53 取消兼容的什么鬼？ 除了了解该方法的兼容性外，还需要了解每一种可执行命令的兼容性。比如decreaseFontSize，给选中文字添加small标签，也就是小号字体，谷歌是不支持的。 可以使用以下方法检测命令是否在浏览器中支持： document.queryCommandSupported(commandName) 简陋的实现不到 50 行代码，基于document.execCommand实现富文本编辑器。 有兴趣的同学可以以此为出发点，去开发一个具备完整功能的编辑器。懒得折腾的可以像我一样多搜索几下，找一个合适的轮子。😅 参考MDN: document.execCommand","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"Webpack按需打包Lodash的几种方式","slug":"2019/webpack-use-lodash","date":"2019-04-16T05:23:06.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/webpack-use-lodash/","link":"","permalink":"https://summxu.github.io/2019/webpack-use-lodash/","excerpt":"","text":"在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。 ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 71k 的体积。不能为了吃一口饭而买下一个饭店啊。 针对这个问题，其实已经有很多可选方案了。 函数模块Lodash 中的每个函数在 NPM 都有一个单独的发布模块。NPM: results for ‘lodash’假如你只需要使用_.isEqual，那么你只需要安装lodash.isequal模块，然后按以下方式引用。 1234var isEqual = require('lodash.isequal')// or ES6import isEqual from 'lodash.isequal'isEqual([1, 2, 3], [1, 2, 3]) // true 全路径引用在你完整安装 Lodash 后，可以按lodash/函数名的格式单独引入需要的函数模块。 1234var difference = require('lodash/difference')// or ES6import difference from 'lodash/difference'difference([1, 2], [1, 3]) // [2] 使用插件优化在简单场景下，以上两种方式足以解决问题。而遇到复杂的数据对象时，我们不得不在一个文件中引入多个 Lodash 函数，这样就需要在文件中写多个require或import相关函数。 12345import remove from 'lodash/remove'import uniq from 'lodash/uniq'import invokeMap from 'lodash/invokeMap'import sortBy from 'lodash/sortBy'// more... 正写到关键处却因为引入一个函数要拉到文件头部去定义引用而打乱了思路，很不爽！ 于是我机智的到 Github 去搜索了webpack和lodash两个关键词的组合，排在首位的 lodash-webpack-plugin 就是为了解决这个问题而生。 使用时需要以下模块，其实除了前两个剩下的一般都已安装了： $ npm i -S lodash-webpack-plugin babel-plugin-lodash babel-core babel-loader babel-preset-es2015 webpack配置： 123456789101112131415161718192021webpack.config.jsvar LodashModuleReplacementPlugin = require('lodash-webpack-plugin');var webpack = require('webpack');module.exports = &#123; module: &#123; loaders: [&#123; loader: 'babel', test: /\\.js$/, exclude: /node_modules/, query: &#123; plugins: ['transform-runtime', 'lodash'], presets: ['es2015'] &#125; &#125;] &#125;, plugins: [ new LodashModuleReplacementPlugin, new webpack.optimize.OccurrenceOrderPlugin, new webpack.optimize.UglifyJsPlugin ]&#125; 其中babel-plugin-lodash的配置，也就是plugins: [&#39;lodash&#39;]，并不是一定要在loaders中，也可以单独定义babel。 123456789101112131415161718192021webpack.config.jsvar LodashModuleReplacementPlugin = require('lodash-webpack-plugin');var webpack = require('webpack');module.exports = &#123; module: &#123; loaders: [&#123; loader: 'babel', test: /\\.js$/, exclude: /node_modules/ &#125;] &#125;, babel: &#123; presets: ['es2015'], plugins: ['transform-runtime', 'lodash'] &#125;, plugins: [ new LodashModuleReplacementPlugin, new webpack.optimize.OccurrenceOrderPlugin, new webpack.optimize.UglifyJsPlugin ]&#125; 又或者是.babelrc文件中。 以上工作完成了，在每个你需要使用 lodash 函数的文件中只需要引用一次 lodash，即可调用任意函数而不会造成完全打包。 12import _ from 'lodash'_.add(1, 2) // 打包时只会引入这一个函数模块 注意：必须要使用 ES2015 的模块引用方式才有效。 End以上即是我目前所知道的几种方式，如果哪位朋友有更好的方式（比如只需要全局引入一次），请一定分享与我！😋","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"正确使用Vue指令的钩子函数","slug":"2019/vue-directive-hook","date":"2019-03-24T07:28:24.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/vue-directive-hook/","link":"","permalink":"https://summxu.github.io/2019/vue-directive-hook/","excerpt":"","text":"在 Vue 中可以把一系列复杂的操作包装为一个指令。 什么是复杂的操作？我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段的掩盖等。我们总是期望以操作数据的形式来实现功能逻辑。 钩子函数对于自定义指令的定义，Vue2 有 5 个可选的钩子函数。 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次，指令与元素解绑时调用。接下来，定义一个简单的指令以验证这些钩子函数的触发时机。123456&lt;div id=\"app\"&gt; &lt;my-comp v-if=\"msg\" :msg=\"msg\"&gt;&lt;/my-comp&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt; &lt;button @click=\"uninstall\"&gt;卸载&lt;/button&gt; &lt;button @click=\"install\"&gt;安装&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243Vue.directive('hello', &#123; bind: function (el) &#123; console.log('bind') &#125;, inserted: function (el) &#123; console.log('inserted') &#125;, update: function (el) &#123; console.log('update') &#125;, componentUpdated: function (el) &#123; console.log('componentUpdated') &#125;, unbind: function (el) &#123; console.log('unbind') &#125;&#125;)var myComp = &#123; template: '&lt;h1 v-hello&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;', props: &#123; msg: String &#125;&#125;new Vue(&#123; el: '#app', data: &#123; msg: 'Hello' &#125;, components: &#123; myComp: myComp &#125;, methods: &#123; update: function () &#123; this.msg = 'Hi' &#125;, uninstall: function () &#123; this.msg = '' &#125;, install: function () &#123; this.msg = 'Hello' &#125; &#125;&#125;) 页面加载时12bindinserted 组件更新时点击“更新”按钮，更改数据触发组件更新。 12updatecomponentUpdated 卸载组件时点击“卸载”按钮，数据置空否定判断以触发组件卸载。 unbind 重新安装组件时点击“安装”按钮，数据赋值肯定判断以触发组件重新安装。 12bindinserted 区别从案例的运行中，对 5 个钩子函数的触发时机有了初步的认识。存疑的也就是bind和inserted、update和componentUpdated的区别了。 bind 和 inserted据文档所说，插入父节点时调用 inserted，来个测试。 12345678bind: function (el) &#123; console.log(el.parentNode) // null console.log('bind')&#125;,inserted: function (el) &#123; console.log(el.parentNode) // &lt;div id=\"app\"&gt;...&lt;/div&gt; console.log('inserted')&#125; 分别在两个钩子函数中输出父节点：bind 时父节点为 null，inserted 时父节点存在。 update 和 componentUpdated关于这两个的介绍，从字眼上看感觉是组件更新周期有关，继续验证。 12345678update: function (el) &#123; console.log(el.innerHTML) // Hello console.log('update')&#125;,componentUpdated: function (el) &#123; console.log(el.innerHTML) // Hi console.log('componentUpdated')&#125; 没毛病，update 和 componentUpdated 就是组件更新前和更新后的区别。 结论文档说的没错…😒Demo 最佳实践根据需求的不同，我们要选择恰当的时机去初始化指令、更新指令调用参数以及释放指令存在时的内存占用等。 比较常见的场景是：用指令包装一些无依赖的第三方库以扩展组件功能。而一个健壮的库通常会包含：初始化实例、参数更新和释放实例资源占用等操作。 12345678910111213141516Vue.directive('hello', &#123; bind: function (el, binding) &#123; // 在 bind 钩子中初始化库实例 // 如果需要使用父节点，也可以在 inserted 钩子中执行 el.__library__ = new Library(el, binding.value) &#125;, update: function (el, binding) &#123; // 模版更新意味着指令的参数可能被改变，这里可以对库实例的参数作更新 // 酌情使用 update 或 componentUpdated 钩子 el.__library__.setOptions(Object.assign(binding.oldValue, binding.value)) &#125;, unbind: function (el) &#123; // 释放实例 el.__library__.destory() &#125;&#125;)","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}]},{"title":"使用队列解决插队业务场景","slug":"2019/queue-solve-continuous","date":"2019-03-01T01:02:36.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/queue-solve-continuous/","link":"","permalink":"https://summxu.github.io/2019/queue-solve-continuous/","excerpt":"","text":"为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。 我觉得用“插队”来描述这个场景真是再好不过了。 队列既然有人要“插队”，我们就要定义一个规则：先进先出。也就是数据结构中的“队列”了。 javascript 中队列的实现： 1234567891011121314151617181920// 实现1var queue = []// 进队queue.push(1)queue.push(2)queue.push(3)// 出队queue.shift() // 1queue.shift() // 2queue.shift() // 3// 实现2var queue2 = []// 进队queue2.unshift(1)queue2.unshift(2)queue2.unshift(3)// 出队queue2.pop() // 1queue2.pop() // 2queue2.pop() // 3 实践定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。 12var requestQueue = []var XHR = function(method, url, param) &#123;&#125; 点击操作的入口函数，先创建请求进队。因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。 123456function myClick(method, url, param) &#123; var len = requestQueue.push(XHR(method, url, param)) if(len === 1) &#123; update() &#125;&#125; 执行的永远是队列中的第一个请求。当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。如果存在未完成的请求，继续调用更新操作。 1234567function update() &#123; requestQueue[0].then(function(res)&#123; // request success requestQueue.shift() requestQueue.length &amp;&amp; update() &#125;)&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"如何为Canvas中特定图形绑定事件？","slug":"2019/canvas-event","date":"2019-02-14T10:47:15.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2019/canvas-event/","link":"","permalink":"https://summxu.github.io/2019/canvas-event/","excerpt":"","text":"Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。 我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件时，动态判断当前响应元素为目标子节点时再执行对应的操作。 这个思想同样也可以用在 Canvas 上，只需要为 canvas 元素绑定事件，事件响应时判断当前鼠标位置处于哪个图形之上，执行对应的操作。 isPointInPathcontext.isPointInPath(x, y); 理论上讲，想要知道一个点是否处于一个图形之中，现成的算法应该是有很多了。不过难得 canvas 本身就提供了这样的函数，用来判断一个点是否处于当前路径中。 1234var c = document.getElementById('canvas');var ctx = c.getContext('2d');ctx.rect(0, 0, 200, 200);console.log(ctx.isPointInPath(50, 100)) // true 就像这样，当你创建一个矩形时，就会产生一个路径，此时就可以调用该方法去判断一个点是否存在于该路径。 产生路径的函数还有其他，比如：lineTo()、clip()、arc()、arcTo() 等。 实现图形的事件绑定先来个简单的饼图吧。 1234567891011121314151617181920var canvas = document.getElementById('c');var ctx = canvas.getContext('2d');var r = canvas.width / 2;ctx.beginPath();ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3'; //蓝色ctx.fill();ctx.beginPath();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336'; //红色ctx.fill();function isInPath (x, y)&#123; ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y);&#125;canvas.addEventListener('click', function(e)&#123; if(isInPath(e.offsetX, e.offsetY)) &#123; console.log('hello') &#125;&#125;) 现在创建一个红蓝拼接的饼图，isInPath 方法判断一个点是否处于蓝色区。理想的结果是只有当鼠标点击区域为蓝色区域时才输出hello。 但事实确不是如此，示例Demo。无论点击红色还是蓝色区域均会输出 hello，这是怎么回事呢 路径既然 isPointInPath(x, y) 的基于路径判断的，那我们就从路径入手。 123456ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3';ctx.fill();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336';ctx.fill(); 当我们把画图时的 ctx.beginPath() 去掉后，发现生成的图形变成一个红色的整圆了：示例Demo。 beginPath() 用来重置路径，由于第一个半圆画完路径未重置，第二个半圆就绘制了两条路径。这似乎解释了上个问题的答案。 在 isInPath(x, y)函数中，由于路径没有重置，所以最终最终判断的不止是 ctx.arc(r, r, r, 0, Math.PI * 1) 这个路径，还有方法外的画红色圆的路径。两个路径加一起自然就是个整圆，所以无论蓝色区还是红色区都会输出。 正确结果12345function isInPath (x, y)&#123; ctx.beginPath(); ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y)&#125; 修改 isInPath 函数，加入重置路径，结果正确输出","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}]},{"title":"Vue组件间样式污染大坑","slug":"2018/vue-scoped-keng","date":"2018-12-03T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/vue-scoped-keng/","link":"","permalink":"https://summxu.github.io/2018/vue-scoped-keng/","excerpt":"","text":"我们都知道，Vue 组件内的样式可以写在 Style 标签下，而各组件之间的样式冲突(污染)问题也十分常见，当然我们可以尽量避免起相同的类名，但项目较大的时候，Class类名时而会冲突。 当然 Vue官方也给了我们解决方法，就是定义了 scoped 这个属性的设置： 这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover。 最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在 标签内。 但是问题就在于 虽然加了scoped,但是却仍热无法锁住用@import引入的外部css文件 这里的解决方法也比较神奇，就是把引入的css文件改为使用预处理器处理的 less sass 或者 styl 文件，具体原理暂时还不得而知 使用 /deep/ 来解决更深一级的标签","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"Vue.$emit Promise 回调后的深坑","slug":"2018/vue-emit-keng","date":"2018-09-24T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/vue-emit-keng/","link":"","permalink":"https://summxu.github.io/2018/vue-emit-keng/","excerpt":"","text":"有个登录需求，是 login.vue 属于 App.vue 的子组件，默认路由页面是进入 login.vue 因为你一开始需要验证登录用户，又要通过登录用户来进行","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"Express + 模板引擎 + jQuery load 实现局部页面的异步加载","slug":"2018/express-jqueryload","date":"2018-09-11T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2018/express-jqueryload/","link":"","permalink":"https://summxu.github.io/2018/express-jqueryload/","excerpt":"","text":"项目匿名评论系统的局部异步加载服务的实现 问题需求目前的论坛系统带有聊天室，在浏览帖子的同时可以随时聊天，这就意味着页面不能经常刷新，一是刷新就会重连服务器，导致一直断开重连的状态，二是刷新之后聊天记录消失，还要做数据的持久化，再者就是影响用户体验，所以最好的解决方案就是异步加载局部页面。前后端分离是挺好做，直接load加载本地页面就可以，但一和express结合起来就不知道该怎么办了。 解决方案其实仔细思考这个问题并不复杂，和前后端分离的模式是完全一模一样的，只是把本地要加载的局部页面换成了服务器上渲染出来的局部页面 。 这时就需要重新配置express的路由和 render 的页面分离，路由多了两条： 123456789101112131415161718192021.get('/main',(req,res) =&gt; &#123; mongo.Post.find((err, postdata) =&gt; &#123; if (err) return res.status(500) /* 对象属性抽离，解决template陷入递归 */ /* mogon取出的对象不正常，转换一下 */ var data = JSON.stringify(postdata) data = JSON.parse(data) var images = [] data.forEach((element, a) =&gt; &#123; images.push(element.images) delete element.images &#125;); res.render('./components/main.html', &#123; post: data, images: images &#125;) &#125;)&#125;).get('/sendpost',(req,res) =&gt; &#123; res.render('./components/sendpost.html')&#125;) 渲染出独立页面，这是各个页面的路径分配： 这样两个在服务器路径中真实存在的页面出来了，通过浏览器也能访问，只不过没了样式： 在客户端上写上这么一句，就大功告成了！！ $(&#39;.center .left&#39;).load(&quot;/main&quot;);$(&#39;.center .left&#39;).load(&quot;/sendpost&quot;);","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://summxu.github.io/tags/jQuery/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"MongoDB的查找find方法取出不正经对象","slug":"2018/mongo-object-files","date":"2018-09-09T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/mongo-object-files/","link":"","permalink":"https://summxu.github.io/2018/mongo-object-files/","excerpt":"","text":"项目匿名评论系统的MongoDB操作 起因：用art-template来渲染前端页面的时候，数组里又包含了数组，这是模板引擎报了一个递归错误，貌似 模板引擎不支持递归？ 想到的解决办法是对象的 数组属性 分离渲染，在删除对象属性时遇到了问题。 delete 方法原生 js 中支持 delete 方法，即删除对象里的某个属性，并且带有一个布尔类型的返回值，本事一个很简单的事情，放到普通代码中也很好实现，但是和MongoDB集合起来的时候，就出了问题。 原因就是 mongoDB find 出来的对象 不正经 这里的id没有引号，原本js代码是不能执行，更不能直接删除对象的属性值，但是这里很奇怪的是，js居然不会报错？？而把这个对象格式直接复制到正常程序里却报错。 正确的解决办法就是转换一下 对象的类型： 1234/* 对象属性抽离，解决template陷入递归 *//* mogon取出的对象不正常，转换一下 */var data = JSON.stringify(postdata)data = JSON.parse(data) 循环嵌套的异步还遇到就是循环图片的时候，等循环结束要res。send（）图片数组，但是 fs.rename 是一个异步操作，要等到循环结束，可以这么操作： 12345678910111213141516171819202122if (req.files.pic.length &gt; 1) &#123; var c = req.files.pic.length req.files.pic.forEach(item =&gt; &#123; var target_path = &apos;./upload/&apos; + item.name fs.rename(&apos;./&apos; + item.path, target_path, function (err) &#123; if (err) throw err; postObj.images.push(target_path.replace(&apos;.&apos;,&apos;&apos;)) c--; if (c === 0 )&#123; console.log(postObj.images) postObj.save((err, result) =&gt; &#123; if (err) throw err res.send(&apos;success&apos;) &#125;) &#125; // 删除临时文件夹文件, fs.unlink(&apos;./&apos; + item.path, function () &#123; if (err) throw err; &#125;); &#125;); &#125;); 用计数器判断循环的次数，为 0 时执行代码。 听说用递归也可以","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"Web文件上传实现","slug":"2018/upload-files","date":"2018-09-09T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/upload-files/","link":"","permalink":"https://summxu.github.io/2018/upload-files/","excerpt":"","text":"项目匿名评论系统的文件上传服务的实现 做了个匿名评论论坛的小系统，里面涉及到了图片的上传，期间遇到的问题汇总。 HTML首先上传文件还是要套到form表单里，并且文件上传是 input type = file 的一个标签‘ 12345678&lt;form id=&quot;form1&quot; method=&quot;POST&quot; enctype =&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;color&quot; for=&quot;exampleInputFile&quot;&gt;图片发表&lt;/label&gt; &lt;input class=&quot;color&quot; type=&quot;file&quot; id=&quot;exampleInputFile&quot; multiple=&quot;multiple&quot; onchange=&quot;imagechange(this)&quot; value=&quot;&quot;&gt; &lt;/div&gt; &lt;textarea style=&quot;resize:none;&quot; name=&quot;content&quot; class=&quot;form-control&quot; rows=&quot;9&quot;&gt;&lt;/textarea&gt; &lt;button style=&quot;margin-top:10px;&quot; type=&quot;button&quot; onclick=&quot;upload1()&quot; class=&quot;btn btn-primary btn-lg btn-block&quot;&gt;发表发表发发表发表发表表发发表发表&lt;/button&gt;&lt;/form&gt; 这里上表单上传多了一个 enctype =&quot;multipart/form-data&quot; 属性，这是代表表单可以上传带有数据的文件。input type = file 的控件是文件标签，其中 class=&quot;form-control&quot; 是可以上传多个文件？ （但我实践上这个属性并没有什么用，最后还是在js里push了多文件上传） onchange=&quot;imagechange(this)&quot; 这个是在文件选择被改变的事件，这里把本dom对象传给js就不用麻烦的获取该dom对象了。 其中该dom节点有一个files对象，这是一个数组，里面放了文件的对象，按道理来说 enctype =&quot;multipart/form-data&quot;会在这里生效在多文件的时候往files里添加多个文件，但实际并没有，新的文件还是把旧的文件覆盖了。所以下面我手动push到了一个新的数组里。这地方还有待研究 注意的是这里一个坑，当我把函数名命名为 upload 的时候，居然不会生效？ 难道是函数命名有冲突？ JS12345678910111213141516171819202122232425function imagechange(a) &#123; files.push(a.files);&#125;function upload1() &#123; var fd = new FormData(document.getElementById(&apos;form1&apos;)) files.forEach(item =&gt; &#123; fd.append(&apos;pic&apos;,item[0]) &#125;); fd.append(&apos;postuser&apos;,&apos;小兵旭旭&apos;) $.ajax(&#123; url: &quot;/sendpost&quot;, type: &quot;POST&quot;, data: fd, sync: false, processData: false, // 告诉jQuery不要去处理发送的数据 contentType: false, // 告诉jQuery不要去设置Content-Type请求头 success: function(response,status,xhr)&#123; console.log(xhr); if (response === &apos;success&apos;) &#123; $(&apos;#sendpost&apos;).toggle(); location.reload() &#125; &#125; &#125;);&#125; js里是用了新的 FormData 对象，这个对象可以接收一个form表单的对象，并且 FormData 可以自己添加属性的，他会一并跟随上传到服务器上。这里把文件数组添加了进去，再通过ajax异步发送到服务器，摆脱了页面停止响应的异步表单提交。 不过需要注意的是，直接console.log（FormData）的对象看上去是个空的对象，他传的参数是不直接在对象里的，而在对象的更深处 这种情况可以在 network 里查看到传出的参数 Node…在Node接收文件的时候也有许多坑，其中就是 express 接收post的请求，并且含有文件数据请求的时候，需要一个中间件 1234const multiparty = require(&apos;connect-multiparty&apos;).use(multiparty(&#123;uploadDir:&apos;./linshi&apos;&#125;))var mutipartMiddeware = multiparty();.post(&apos;/sendpost&apos;, mutipartMiddeware, (req, res) =&gt; &#123;&#125;) {uploadDir:’./linshi’} 配置了该中间件接收到的文件存放的临时目录。并且该中间件接收到的res有以下几个有用的参数： 1234req.body: 请求体req.files: 接收到的文件数组req.files.file.path: 临时存放文件的路径req.files.file.name: 接收到的文件名字 上面注意到，该中间件存放的是临时文件，并且文件名是随机命名的（req属性里有真实的文件名字），如果想正常保存上传来的文件，还是需要自己手动去处理： 12345678var target_path = &apos;./upload/&apos; + req.files.pic.namefs.rename(&apos;./&apos; + req.files.pic.path, target_path, function (err) &#123; if (err) throw err; postObj.images.push(target_path.replace(&apos;.&apos;,&apos;&apos;)) // 删除临时文件夹文件, fs.unlink(&apos;./&apos; + req.files.pic.path, function () &#123; if (err) throw err; &#125;); 这样一个基本的文件上传服务就完成了，当然还有很多判断需要自己手动去实现。这里是使用了 FormData 对象，MDN上也给出了不使用该对象的方法。 FromData上传文件的方法 Ajax序列化及文件上传","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"Vue-resouce改为Axios之旅","slug":"2018/vue-axios","date":"2018-08-27T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/vue-axios/","link":"","permalink":"https://summxu.github.io/2018/vue-axios/","excerpt":"","text":"尤雨溪说了，vue2.0 将不再维护自己的原生请求插件 vue-resource 而推荐使用axios，所以以后就用axios来发送vue请求了。 使用 cnpm 安装 axioscnpm install axios --save-dev 安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton。这里只说修改原型链的方式改写原型链 首先在 main.js 中引入 axiosimport axios from &#39;axios&#39; 这时候如果在其它的组件中，是无法使用 axios 命令的。所以我们将 axios 改写为 Vue 的原型属性 Vue.prototype.$http= axios 在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令例如 12345678910methods: &#123; show() &#123; this.$http(&#123; method: &apos;get&apos;, url: &apos;/user&apos;, data: &#123; name: &apos;virus&apos; &#125; &#125;)&#125; 配置 axios实际上只有 url 是必须的，完整的 api 可以参考https://link.jianshu.com/?t=https://www.kancloud.cn/yunye/axios/234845 对于get请求 12345axios.get(&apos;/user&apos;, &#123; params:&#123; name:&quot;virus&quot; &#125;&#125;) 对于POST请求 123axios.post(&apos;/user&apos;,&#123; name:&quot;virus&quot; &#125;) 一次并发多个请求 12345678910function getUserAccount()&#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions()&#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios可以通过配置（config）来发送请求 1234567axios(&#123; method:&quot;POST&quot;, url:&apos;/user/1111&apos;, data:&#123; name:&quot;virus&quot; &#125;&#125;); 完整的请求还应当包括 .then 和 .catch 123456.then(function(res)&#123; console.log(res) &#125;).catch(function(err)&#123; console.log(err) &#125;) 当请求成功时，会执行 .then，否则执行 .catch这两个回调函数都有各自独立的作用域，如果直接在里面访问 this，无法访问到 Vue 实例,这时只要添加一个 .bind(this) 就能解决这个问题 123.then(function(res)&#123; console.log(this.data)&#125;.bind(this)) 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名12345678910111213axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]])","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"Bootstrap响应式轮播图问题","slug":"2018/mobileweb-bootstrap-slide","date":"2018-08-24T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/mobileweb-bootstrap-slide/","link":"","permalink":"https://summxu.github.io/2018/mobileweb-bootstrap-slide/","excerpt":"","text":"bootstrap 原生轮播图，因为轮播图是图片，所以为了做响应式就要麻烦一些，因为要涉及到图片的大小还有小屏幕的显示比例，把这次遇到的问题重新捋一下 。 两站单独设计因为PC端的轮播图是定高的，而且图片尺寸又大，但是移动端是百分比可缩小的，图片是小图，所以只能是两站单独设计，这是两站单独的CSS: 1234567891011121314.pc_img &#123; display: block; height: 400px; background: no-repeat center; background-size: cover;&#125;.m_img &#123; display: block; width: 100%;&#125;.m_img img&#123; display: block; width: 100%;&#125; 这样HTML的结构就可以这么放(用了模板引擎之后)，并且用了响应式工具使两者实现不同屏幕尺寸单独显示，不会同时显示出来。。 1234&lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt; &lt;a class=&quot;m_img hidden-lg hidden-md hidden-sm&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot;&gt;&lt;img src=&quot;&#123; &#123;$value&#125; &#125;&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/a&gt; &lt;a class=&quot;pc_img hidden-xs&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot; style=&quot;background-image: url(&apos;&#123; &#123;$value&#125; &#125;&apos;);&quot;&gt;&lt;/a&gt;&lt;/div&gt; 这样虽说是视觉上看不出来有什么问题，但是在请求中两者都会同时请求，加载的图片太多，而且只是小屏幕的话，会多加载大屏幕中的大图片。。。 为了优化 不得不用js判断访问的屏幕大小。这样一系列的问题就来了。 屏幕大小判断并单独加载因为要单独判断当前屏幕的大小来指定到底要加载哪种图片，什么结构，又要做响应式，就会涉及到以下两点问题： 判断页面大小，请求页面数据，渲染模板引擎 响应式实时判断页面大小，而不重复发送请求 难点在第二点，我们只需要页面在需要请求数据的时候才不得不请求（如果现在是大屏幕，只请求大图片，如果是小屏幕，之请求小图片。如果从大屏幕响应式到了小屏幕，这时不得不再去求情一次） 做响应式，实时判断页面大小，又不用每次改变大小时去实时发送请。这时我们可以在特定的时候来请求数据，并把数据缓存下来，这里用的方法是绑定到 window 上一个全局对象的属性，并且用 回调函数 把全局对象的属性返回，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 判断访问来源 ， 以便使pc和m都加载 */$(document).ready(function () &#123; function getData(callback) &#123; /* 判断 window.data 是不是有缓存数据 */ if (window.data) &#123; callback &amp;&amp; callback(window.data) &#125;else &#123; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;./data.json&quot;, dataType: &quot;json&quot;, // async: false, success: function (response) &#123; window.data = response callback &amp;&amp; callback(window.data) &#125; &#125;); &#125; &#125; function render() &#123; /* 这里通过回调函数获取传递过来的数据，是为了每次调用 render 的时候不ajax */ getData(function (response) &#123; var data = &#123;&#125; var iSMobile = window.innerWidth &lt; 750 ? true : false if (iSMobile) &#123; data.type = &apos;m&apos; data.content = response.m var html = template(&apos;carousel-content&apos;,data) $(&apos;.banner .carousel-inner&apos;).html(html) var html = template(&apos;carousel-indicators&apos;,data) $(&apos;.banner .carousel-indicators&apos;).html(html) &#125;else&#123; data.type = &apos;pc&apos; data.content = response.pc var html = template(&apos;carousel-content&apos;,data) $(&apos;.banner .carousel-inner&apos;).html(html) var html = template(&apos;carousel-indicators&apos;,data) $(&apos;.banner .carousel-indicators&apos;).html(html) &#125; &#125;) &#125; /* 这里要做响应式，所以要把数据渗透成全局对象 window.data */ $(window).on(&apos;resize&apos;,function () &#123; render() /* 通过js主动触发事件 */ &#125;).trigger(&apos;resize&apos;,function ()&#123; render() &#125;) 这里要注意一点，就是当数据请求和没请求的两种状态下，都要进行回调函数 1234success: function (response) &#123; window.data = response callback &amp;&amp; callback(window.data)&#125; 最后用 jQuery 的 trigger 方法来主动调用一次 window.onresize 就不用手动调用 render() 了。 实现移动端滑动功能123456789101112131415161718192021222324/* 加载轮播图滑动 控制 prev 和 next */ var startX = 0 var endX = 0 isMove = false $(&apos;#carousel-id&apos;).on(&apos;touchstart&apos;, function (e) &#123; startX = e.originalEvent.touches[0].clientX; &#125;).on(&apos;touchmove&apos;,function(e)&#123; isMove = true /* originalEvent 是原生事件的属性。 */ endX = e.originalEvent.touches[0].clientX; &#125;).on(&apos;touchend&apos;,function(e)&#123; lr = endX - startX tmp = Math.abs( endX - startX) if (isMove &amp;&amp; tmp &gt; 50) &#123; if (lr &lt; 0) &#123; $(&apos;.carousel&apos;).carousel(&apos;next&apos;) console.log(&apos;next&apos;); &#125;else &#123; $(&apos;.carousel&apos;).carousel(&apos;prev&apos;) console.log(&apos;prev&apos;) &#125; &#125; &#125;);&#125;); 关于模板引擎模板引擎是个好东西，在获取到数据绑定到HTML页面上的时候，用DOM方式来操作确实有点难受，而且还弄的十分混乱，特别是当数据比较多的时候。这时候模板引擎能更友好的将数据渲染到页面上，甚至模板引擎本身提供了简单好用的一些方法 这里使用的模板引擎是 Arttemplate其他的模板引擎的使用方法都大同小异，基本的使用方法大概是这样：js: 1234&lt;!-- 渲染html结构 ，放到 script 标签中--&gt;var html = template(&apos;arttemplate&apos;,&#123;value:data&#125;)&lt;!-- 把渲染好的HTML放到指定的容器中 --&gt;document.getEmementById(&apos;content&apos;).innerHTML(html) 因为script 的 type 只要是不为 text/javascript 就不会别解析成js语法 所以很多时候方便存一些有结构型的数据到script标签中，模板引擎也是基于这个。 但是模板引擎 使用 { { } } 里面的内容是 可以直接写 js 代码的html: 1234567891011121314151617181920&lt;script id=&quot;carousel-content&quot; type=&quot;text/x-arttemplate&quot;&gt; &#123; &#123; if $data.type == &apos;m&apos; &#125; &#125; &#123; &#123; each $data.content &#125; &#125; &lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt; &lt;a class=&quot;m_img hidden-lg hidden-md hidden-sm&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot;&gt;&lt;img src=&quot;&#123; &#123;$value&#125; &#125;&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &#123; &#123; /each &#125; &#125; &#123; &#123; else &#125; &#125; &#123; &#123; each $data.content &#125; &#125; &lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt; &lt;a class=&quot;pc_img hidden-xs&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot; style=&quot;background-image: url(&apos;&#123; &#123;$value&#125; &#125;&apos;);&quot;&gt;&lt;/a&gt; &lt;/div&gt; &#123; &#123; /each &#125; &#125; &#123; &#123; /if &#125; &#125;&lt;/script&gt;&lt;script id=&quot;carousel-indicators&quot; type=&quot;text/x-arttemplate&quot;&gt; &#123; &#123; each $data.content &#125; &#125; &lt;li data-target=&quot;#carousel-id&quot; data-slide-to=&quot;&#123; &#123;$index&#125; &#125;&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &#123; &#123; /each &#125; &#125;&lt;/script&gt; 这样页面就能方便的处理数据了。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://summxu.github.io/tags/Bootstrap/"}],"author":"BoomXu"},{"title":"Overflow实现圣杯布局","slug":"2018/grail-layout","date":"2018-08-23T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/grail-layout/","link":"","permalink":"https://summxu.github.io/2018/grail-layout/","excerpt":"","text":"工作过程中遇到了很多问题，也学到了很多知识，这次用Overflow来触发BFC以实现双飞翼布局，很简单的一件事。但中间却有点学问。 实现原理所谓原理就是用Overflow来触发BFC（块级格式化范围）。 1.这是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。 2.另一个通俗点的解释是：在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 inline formatting context(行内格式化上下文) 里格式化。任何被渲染的元素都属于一个 box ，并且不是 block ，就是 inline 。即使是未被任何元素包裹的文本，根据不同的情况，也会属于匿名的 block boxes 或者 inline boxes。所以上面的描述，即是把所有的元素划分到对应的 formatting context 里。 总的来说BFC是和浮动划分开来，两者互不干扰，所以在center 中间的元素 宽度 100 % 不会铺满整个窗口 实现代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;overflow&lt;/title&gt; &lt;style&gt; .left &#123; float: left; width: 100px; height: 100px; background-color: skyblue; &#125; .right &#123; float: right; width: 100px; height: 100px; background-color: skyblue; &#125; .center &#123; overflow: hidden; height: 100px; background-color: pink; line-height: 100px; &#125; .search &#123; height: 50%; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;input class=\"search\" type=\"text\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 但是要注意，left center 和 right 标签的位置顺序不能放错。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}],"author":"BoomXu"},{"title":"Webpack CSS分类打包和html img不打包配置","slug":"2018/webpack-html-withimg","date":"2018-08-23T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/webpack-html-withimg/","link":"","permalink":"https://summxu.github.io/2018/webpack-html-withimg/","excerpt":"","text":"介绍两个webpack插件的使用 问题还原 在webpack打包之后的文件，往往都会打包到bundle.js中。但是为了目录的维护性，通常要把CSS单独分离出来这时需要 extract-text-webpack-pluginnpm install extract-text-webpack-plugin --save-dev 配置上首先引入插件，然后再创建多个新的 extract 对象，并且在 plugins 引用他们 123456789101112var Extract = require('extract-text-webpack-plugin')var extractCss = new Extract('css/base.css')var extractLess = new Extract('css/[name].css')var extractScss = new Extract('css/[name].css')var extractStyl = new Extract('css/[name].css')plugins: [ extractCss, extractLess, extractScss, extractStyl], 下一步就是修改原本的 rules loader规则 12345&#123; test: /\\.css$/, use: extractCss.extract( ['css-loader']) &#125;, // 处理 CSS 文件的 loader&#123; test: /\\.less$/, use: extractLess.extract(['css-loader', 'less-loader']) &#125;, // 处理 less 文件的 loader&#123; test: /\\.scss$/, use: extractScss.extract(['css-loader', 'sass-loader']) &#125;, // 处理 scss 文件的 loader&#123; test: /\\.styl$/, use: extractStyl.extract(['css-loader', 'stylus-loader']) &#125;, // 处理 stylus 文件的 loader&#123; test: /\\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&amp;name=[name].[ext]&amp;outputPath=./images&amp;publicPath=../images'&#125;, // 处理 图片路径的 loader https://www.npmjs.com/package/extract-text-webpack-plugin 虽然上面引入了 url-loader 来解析图片文件，但是html内的img：src图片并不能通过此方式正常解析，原因是因为，webpack不能正确找到引入的图片，解决方式有两种。、 让webpack知道引入的图片路径&lt;img src=&quot;${ require(&#39;..assets/logo.png&#39;) }&quot;&gt; 借助loader html-withimg-loadernpm install html-withimg-loader --save 在rule 中加入 { test: /\\.(htm|html)$/i, loader: &#39;html-withimg-loader&#39;} //处理html img 中的图片 完事！ https://github.com/wzsxyz/html-withimg-loader","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"Vue-loader版本遇到的坑","slug":"2018/vue-loader-version","date":"2018-07-21T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/vue-loader-version/","link":"","permalink":"https://summxu.github.io/2018/vue-loader-version/","excerpt":"","text":"在学习Vue.js和Webpack的路上遇到了不少问题,也找到了相对的解决办法, 这次记录下在vue-loader版本遇到的问题. vue-loader简介在webpack中加载第三方的文件支持,就要有第三方的文件解析工具,在vue的组件模板文件中,要有vue-loader的支持才可以.他可以将vue文件转换为JS模块； vue-loader特性（1）ES2015默认支持（2）允许对VUE组件的组成部分使用其他webpack loader;比如对&lt; style &gt;使用SASS（编译CSS语言），对&lt; template &gt;使用JADE（jade是一个高性能的模板引擎，用JS实现，也有其他语言的实现—php,scala,yuby,python,java，可以供给node使用）（3）.vue文件中允许自定义节点，然后使用自定义的loader处理他们（4）对&lt; style &gt;&lt; template &gt;中的静态资源当做模块来对待，并且使用webpack loaders进行处理（5）对每个组件模拟出CSS作用域（6）支持开发期组件的热重载在编写vue应用程序时，组合使用webpack跟vue-loader能带来一个现代。灵活并且非常强大的前端工作流程； vue-loader@14 Version特性上面说了,允许对VUE组件的组成部分使用其他webpack loader;比如对&lt; style &gt;使用SASS（编译CSS语言），对&lt; template &gt;使用JADE，但是我在运行的过程中在vue组件模板文件下写stylus的样式一直报错 总是提示说需要装一个loader支持，但是我已经装了 而且语法也有写错 这是我看到报错里提到了vue-loader，果然是vue-loader 的版本问题 vue-loader@15 Version在最新的npm上装的是vue-loader 15.x 版本，但是现在直接npm装的最新版本的vue-loader 15 把这个功能给去除了,同时在vue-loader 15配置的时候还要引入一个插件 1234567815版本以上的vue-loader 需要插件支持 , 插件是个对象,这里引入的时候要转换成对象才行const &#123;VueLoaderPlugin&#125; = require(&apos;vue-loader&apos;)plugins: [ //15版本以上的vue-loader 需要插件支持 new VueLoaderPlugin()], 不仅如此，15版本的vue-loader还 去除了 对&lt; style &gt; 编译CSS预处理的支持 现在暂时使用14版本的vue-loader，15版本的新特性和使用方法还需要进一步的学习。。。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"DIV的Height为什么不能100%","slug":"2018/div-height100","date":"2018-05-29T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2018/div-height100/","link":"","permalink":"https://summxu.github.io/2018/div-height100/","excerpt":"","text":"跟着百度IFE的基础做做，确实是遇到不少问题，在《三种简历》这一章，侧边导航就遇到了高度无法铺满的问题。 那为什么 height:100%; 不起作用 在html布局中body内第一个div盒子对象设置100%高度height样式，是无法成功显示100%高度的。这个是因为body高度默认值为自适应的，所以及时设置body第一个布局div高度为百分比也是无效的，因为div解析上级高度为0，自然div height 100%实际高度也为0。 浏览器根本就不计算内容的高度，除非内容超出了视窗范围(导致滚动条出现)。或者你给整个页面设置一个绝对高度。否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑。 因为页面并没有缺省的高度值，所以，当你让一个元素的高度设定为百分比高度时，无法根据获取父元素的高度，也就无法计算自己的高度。换句话说，父元素的高度只是一个缺省值：height: auto;。当你要求浏览器根据这样一个缺省值来计算百分比高度时，只能得到undefined的结果。也就是一个null值，浏览器不会对这个值有任何的反应。 如果想让一个元素的百分比css高度height: 100%;起作用，你需要给这个元素的 所有父元素 的高度设定一个有效值。 这里的 所有父元素 我发现其实是错误的，只要根元素 &lt; html &gt; 的高度设置好，其他子元素都是自动继承的。。而父元素块HTML本身是没有高度的 以上当我没说，还是必须要所有的父元素都要设置。 123html,body&#123; height:100%;&#125; 解决方法方法一为 根元素 &lt; html &gt; 设置高度 123html&#123; height:100%;&#125; 方法二方法二就是使用绝对定位，使div脱离标准流，也就是脱离了他的根元素 html 123456789.title&#123; float: left; position:absolute; width: 20%; height: 100%; background-color: dodgerblue; font-size: 28px; font-weight: bold;&#125; 结果Height:100%的方法，缺点缺非常显著，你在div内定义 padding 或者是 margin 就会把页面撑开，也就是说超过了 100%，就会出现一个非常不完美的滚动条。。 当然你可以用 overflow: hidden; 溢出隐藏，但是这样只是掩耳盗铃，滚动条是没了，页面的滚动却不受控制了。 神奇的CSS 。。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}],"author":"BoomXu"},{"title":"Python网页自动化操作","slug":"2018/python-selenium","date":"2018-05-29T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/python-selenium/","link":"","permalink":"https://summxu.github.io/2018/python-selenium/","excerpt":"","text":"最近几天忙忙碌碌却感到忙出来什么好结果，不过最近几天要抓紧时间学学英语。因为最近有一个表需要一直重复向网页添加信息，于是就借此机会研究了Python的网页自动化，在此是用了Selenium框架。。 什么是Seleniumselenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。 selenium可以模拟真实浏览器，自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染问题。 selenium基本使用在此之前先上段代码： 1234567891011121314browser = webdriver.Chrome()browser.get(&apos;http://sdxy.gov.cn:8888/auth/pub/loginerror&apos;)wait = WebDriverWait(browser, 10, 1.0)browser.set_page_load_timeout(8)browser.set_script_timeout(8)``` ## 声明浏览器对象首先selenium支持绝大多数主流浏览器，但是中间要有浏览器的驱动程序 在此我是调用的 **[chromedriver](http://npm.taobao.org/mirrors/chromedriver/)** 放到相同目录下就可以运行。`browser = webdriver.Firefox()`这是火狐的调用方式。## 访问页面 browser.get(“http://www.baidu.com&quot;)print(browser.page_source)browser.close() 12345用**rowser.get**方法可以打开网页**page_source**是提取网页源代码## 查找元素### 单个元素查找 from selenium import webdriver browser = webdriver.Chrome() browser.get(“http://www.taobao.com&quot;)input_first = browser.find_element_by_id(“q”)input_second = browser.find_element_by_css_selector(“#q”)input_third = browser.find_element_by_xpath(‘//*[@id=”q”]’)print(input_first)print(input_second)print(input_third)browser.close() 12345678910111213141516这里列举一下常用的查找元素方法：find_element_by_namefind_element_by_idfind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector下面这种方式是比较通用的一种方式：这里需要记住By模块所以需要导入from selenium.webdriver.common.by import By### 多个元素查找 from selenium import webdriver browser = webdriver.Chrome()browser.get(“http://www.taobao.com&quot;)lis = browser.find_elements_by_css_selector(‘.service-bd li’)print(lis)browser.close() 123456这样获得就是一个列表:![from zhaof](https://images2015.cnblogs.com/blog/997599/201706/997599-20170606193737497-369795287.png)## 元素交互操作 from selenium import webdriver import time browser = webdriver.Chrome()browser.get(“http://www.taobao.com&quot;)input_str = browser.find_element_by_id(‘q’)input_str.send_keys(“ipad”)time.sleep(1)input_str.clear()input_str.send_keys(“MakBook pro”)button = browser.find_element_by_class_name(‘btn-search’)button.click() 123456789101112131415161718192021222324运行的结果可以看出程序会自动打开Chrome浏览器并打开淘宝输入ipad,然后删除，重新输入MakBook pro，并点击搜索Selenium所有的api文档：&lt;http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains&gt;### 交互动作将动作附加到动作链中串行执行from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = &quot;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;browser.get(url)browser.switch_to.frame(&apos;iframeResult&apos;)source = browser.find_element_by_css_selector(&apos;#draggable&apos;)target = browser.find_element_by_css_selector(&apos;#droppable&apos;)actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform()## 执行JavaScript这是一个非常有用的方法，这里就可以直接调用js方法来实现一些操作，下面的例子是通过登录知乎然后通过js翻到页面底部，并弹框提示 from selenium import webdriverbrowser = webdriver.Chrome()browser.get(“http://www.zhihu.com/explore&quot;)browser.execute_script(‘window.scrollTo(0, document.body.scrollHeight)’)browser.execute_script(‘alert(“To Bottom”)’) 12345678910111213141516## 元素操作 元素操作 | 方法---------|---------- 获取元素属性 | get_attribute(&apos;class&apos;) 获取文本值 | text 获取ID | id 位置 | location 标签名 | tag_name ## 等待当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0### 显式等待指定一个等待条件，并且指定一个最长等待时间，会在这个时间内进行判断是否满足等待条件，如果成立就会立即返回，如果不成立，就会一直等待，直到等待你指定的最长等待时间，如果还是不满足，就会抛出异常，如果满足了就会正常返回 from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC browser = webdriver.Chrome()browser.get(‘https://www.taobao.com/&#39;)wait = WebDriverWait(browser, 10)input = wait.until(EC.presence_of_element_located((By.ID, ‘q’)))button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, ‘.btn-search’)))print(input, button) 123### 隐式等待到了一定的时间发现元素还没有加载，则继续等待我们指定的时间，如果超过了我们指定的时间还没有加载就会抛出异常，如果没有需要等待的时候就已经加载完毕就会立即执行 from selenium import webdriver browser = webdriver.Chrome()browser.implicitly_wait(10)browser.get(‘https://www.zhihu.com/explore&#39;)input = browser.find_element_by_class_name(‘zu-top-add-question’)print(input) 12345678910111213141516171819202122232425## 条件判断1. title_is 标题是某内容2. title_contains 标题包含某内容3. presence_of_element_located 元素加载出，传入定位元组，如(By.ID, &apos;p&apos;)4. visibility_of_element_located 元素可见，传入定位元组5. visibility_of 可见，传入元素对象6. presence_of_all_elements_located 所有元素加载出7. text_to_be_present_in_element 某个元素文本包含某文字8. text_to_be_present_in_element_value 某个元素值包含某文字9. frame_to_be_available_and_switch_to_it frame加载并切换10. invisibility_of_element_located 元素不可见11. element_to_be_clickable 元素可点击12. staleness_of 判断一个元素是否仍在DOM，可判断页面是否已经刷新13. element_to_be_selected 元素可选择，传元素对象14. element_located_to_be_selected 元素可选择，传入定位元组15. element_selection_state_to_be 传入元素对象以及状态，相等返回True，否则返回False16. element_located_selection_state_to_be 传入定位元组以及状态，相等返回True，否则返回False17. alert_is_present 是否出现Alert## cookie操作get_cookies()delete_all_cookes()add_cookie() from selenium import webdriver browser = webdriver.Chrome()browser.get(‘https://www.zhihu.com/explore&#39;)print(browser.get_cookies())browser.add_cookie({‘name’: ‘name’, ‘domain’: ‘www.zhihu.com&#39;, ‘value’: ‘zhaofan’})print(browser.get_cookies())browser.delete_all_cookies()print(browser.get_cookies()) 12345## 选项卡管理通过执行js命令实现新开选项卡window.open()不同的选项卡是存在列表里browser.window_handles通过browser.window_handles[0]就可以操作第一个选项卡 import timefrom selenium import webdriver browser = webdriver.Chrome()browser.get(‘https://www.baidu.com&#39;)browser.execute_script(‘window.open()’)print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get(‘https://www.taobao.com&#39;)time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get(‘https://python.org&#39;)``` 还有很多强大的功能有待研究","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://summxu.github.io/tags/Python/"}],"author":"BoomXu"},{"title":"初次尝试Vue Jsx","slug":"2018/vue-jsx","date":"2018-04-23T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/vue-jsx/","link":"","permalink":"https://summxu.github.io/2018/vue-jsx/","excerpt":"","text":"Vue声明加载1234567891011&lt;script&gt;import Header from &apos;./todo/header.vue&apos;import Footer from &apos;./todo/footer.jsx&apos;export default &#123; components:&#123; Header, Footer, &#125;&#125;&lt;/script&gt; 这里用 components 方法来声明加载过来的外部文件。。 Jsx React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。我们不需要一定使用 JSX，但它有以下优点：JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。它是类型安全的，在编译过程中就能发现错误。使用 JSX 编写模板更加简单快速。 jsx更好的把js和html结合起来，可以很简单的做到原生js很复杂的操作，下面是一段代码： 12345678910111213141516import '../assets/styles/footer.styl'export default&#123; data() &#123; return &#123; author: 'BoomXu' &#125; &#125;, render() &#123; return( &lt;div id=\"footer\"&gt; &lt;span&gt;Written by &#123;this.author&#125;&lt;/span&gt; //这里用了this对像调用 &lt;/div&gt; ) &#125;&#125; jsx在生成html的时候用了 render()方法，其实vue和这个一样，vue里的 &lt;template&gt;标签其实就是用了render()方法来生成的html结构。 但是jsx不好的一点在于他不能直接写 style 需要引入外部文件才可以。 methods{} 声明方法","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"初次尝试Vue","slug":"2018/first-vue","date":"2018-04-22T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/first-vue/","link":"","permalink":"https://summxu.github.io/2018/first-vue/","excerpt":"","text":"我换了个Jekyll 随机自动换图的接口，以后不用每次都上传图片了 。。 https://img.xjh.me/random_img.php?type=bg&amp;ctype=nature&amp;return=302 速度还很快 天天好心情 VUE2简介数据绑定省去js操作dom，动态的把js的数据绑定到html，数据一旦改变，html数据跟着改变 vue文件开发方式1234567891011&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 组件化开发，可以自定义标签，包含html、js、css 。。 在一个文件里面直接写各种组建。 render方法组件数据变化时vue会自动用render方法去遍历构建&lt;template&gt;标签内的标签节点。 API重点生命周期方法组件什么时候编译，什么时候生html元素，都是有规定的生命周期方法。控制生命周期方法可以方便的在某个地方调用某种功能 computed数据改变的时候调用的方法，方便的控制数据的变化 Vue之前装的packautoprefixer这个包是省去了写css的时候对特定的浏览器的写法，它可以自动填补上。 Postcss一个css插件系统,后期用插件处理的css处理器 具体可以看这个 https://segmentfault.com/a/1190000011595620 babel用来演示 vue-jsx 的操作","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://summxu.github.io/tags/Vue/"}],"author":"BoomXu"},{"title":"初次尝试Webpack构建前端","slug":"2018/first-webpack","date":"2018-04-20T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/first-webpack/","link":"","permalink":"https://summxu.github.io/2018/first-webpack/","excerpt":"","text":"最近一直研究前端工程化和更高效的构建工具，网上很多人都说Node.js能帮助前端开发，今天终于了解了一下，原有的js,jquery,css,html都是基础，想要做出完整的前端页面还是很复杂，而且文件也比较多。初次接触了下Webpack，这真的是前端离不开的工程构建工具. 首先在用这些东西之前最好是了解以下: css基础 JavaScript基础 ES6 css预处理器(less,sass,stulus) 对象编程逻辑 什么是Webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack就是把网页资源文件打包成一个js,在此之前你编程上可以用多种语言和多种工具,高效开发.在运行上网页速度加载也很快,减少了大量的http请求. webpack有极高的配置度和丰富的插件,loader以及webhttp调试. Webpack 安装环境 在这之前要说下 Node.js 和 NPM Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 NPM npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。 NPM包管理工具异常强大,他可以把很多个包的东西都关联起来.我们搭建本次webpack使用了以下的各种包: “cross-env”: “^5.1.4”, “css-loader”: “^0.28.11”, “file-loader”: “^1.1.11”, “html-webpack-plugin”: “^3.2.0”, “style-loader”: “^0.21.0”, “stylus”: “^0.54.5”, “stylus-loader”: “^3.0.2”, “url-loader”: “^1.0.1”, “vue”: “^2.5.16”, “vue-loader”: “^14.2.2”, “vue-template-compiler”: “^2.5.16”, “webpack”: “^4.6.0”, “webpack-dev-server”: “^3.1.3” Webpack 在我们这里也是一种包 其安装方法如下: npm install webpack NPM package.json文件 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 其实就是一个json格式的包管理文件,以及这种命令操作配置,这个文件配置很灵活,我们也要经常添加各种配置. 以下是我的文件配置 : 12345678910111213141516171819202122232425262728293031&#123; \"name\": \"vuewebpacke\", \"version\": \"1.0.0\", \"description\": \"test\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"cross-env\": \"^5.1.4\", \"css-loader\": \"^0.28.11\", \"file-loader\": \"^1.1.11\", \"html-webpack-plugin\": \"^3.2.0\", \"style-loader\": \"^0.21.0\", \"stylus\": \"^0.54.5\", \"stylus-loader\": \"^3.0.2\", \"url-loader\": \"^1.0.1\", \"vue\": \"^2.5.16\", \"vue-loader\": \"^14.2.2\", \"vue-template-compiler\": \"^2.5.16\", \"webpack\": \"^4.6.0\", \"webpack-dev-server\": \"^3.1.3\" &#125;, \"devDependencies\": &#123; \"webpack-cli\": \"^2.0.14\" &#125;&#125; 这就是没有配置loader造成的对.vue文件不识别 Webpack 目录结构Webpack.config.js package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 这是默认文件,我们不必动这个 webpack.config.js这是webpack的配置文件,他是在运行的时候加载的一种文件格式,属于node.js的模块我们用了es6来编辑和配置这个文件里的各个参数和值,下面是文件内容,我们一一来解释: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//首先载入用的到的node.js库文件 const path = require(&apos;path&apos;) //path node.js 自带的模块用来生成出口文件const HTMLPlugin = require(&apos;html-webpack-plugin&apos;) //html-webpack-plugin 是生成html入口页面的插件const webpack = require(&apos;webpack&apos;)const isDev = process.env.NODE_ENV === &apos;development&apos;const config = &#123; target: &apos;web&apos;, entry: path.join(__dirname,&apos;src/index.js&apos;), //入口文件 output:&#123; filename: &apos;bundle.js&apos;, path: path.join(__dirname,&apos;dist&apos;) //__dirname是node.js全局变量,是文件目录 &#125;, //生成出口文件 module: &#123; rules: [ &#123; test: /\\.vue$/, //正则表达式 loader: &apos;vue-loader&apos; &#125;, &#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;, &#123; test: /\\.styl/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;stylus-loader&apos; ] &#125;, &#123; test: /\\.(gif|png|jpeg|jpg|svg)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 1024, //url-loader配置,图片小于1024使用base64编码 name: &apos;[name]-xu.[ext]&apos; //输出图片名字格式 &#125; &#125; ] &#125; ] &#125;, //各种loader声明方式 plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; NODE_ENV: isDev ? &apos;&quot;development&quot;&apos; : &apos;&quot;production&quot;&apos; &#125; &#125;), //动态指定打包模式development or production new HTMLPlugin() ] //插件数组,用到的插件都需要用new声明&#125;if (isDev) &#123; config.devtool = &apos;#cheap-module-eval-source-map&apos; config.devServer = &#123; port: 8000, host: &apos;0.0.0.0&apos;, overlay: &#123; errors: true, &#125;, hot: true &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125;module.exports = config //配置加载对象化 在此贴上webpack更具体的用法 www.webpackjs.com/concepts 运行webpacknpm run build or dev 12&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;,&quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js&quot; 之后还要在继续看看 stylus,es6,vue","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"三天教你Apache CGI从入门到放弃","slug":"2018/apache-cgi-abandon","date":"2018-04-15T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2018/apache-cgi-abandon/","link":"","permalink":"https://summxu.github.io/2018/apache-cgi-abandon/","excerpt":"","text":"千万不要用被淘汰的技术产品！！千万不要用被淘汰的技术产品！！千万不要用被淘汰的技术产品！！ 为什么要抛弃麻烦！ 为什么CGI麻烦1.配置上CGI的apache配置倒是不太繁琐，但是绝对没有PHP来的更快，更兼容 2.格式上CGI的变成格式看上去就不太高效，不仅要让程序输出html格式的网页头还要在文件头部准确的定义CGI程序的打开位置，不过这都不是重点 3.重点是调试上CGI准确的来说，是用Apache为环境来输出出来，这样在调试的时候相当复杂，在本地环境调试好的程序放上去并不能直接运行， 还要调试各种各样的问题。加上Python的两个版本的不兼容，整个项目的编写会用80%的时间来进行调试。所以果断弃之。 下面http的接口调用部分还是用先进的PHP来完成把，Python只在固定时间内在后台抓抓数据就完事了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"https://summxu.github.io/tags/Python/"}],"author":"BoomXu"},{"title":"Apahce的CGI操作 - Python","slug":"2018/apache-cgi","date":"2018-04-12T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2018/apache-cgi/","link":"","permalink":"https://summxu.github.io/2018/apache-cgi/","excerpt":"","text":"最近在研究Podcast泛博客的订阅地址，在国内的几大Podcast平台基本都提供RSS订阅源地址，但还是有很多专辑没有被分享订阅地址出来，碰巧最近在研究Python，打算用Python做爬虫，分析出来各大节目的广播地址并生成订阅源头。如果用前台去调用后台接口大部分的方式都是用PHP和Apache的方法，为了不想再涉及到PHP，下面就用这种古老的CGI的方式来解决。 什么是 CGICGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI,可用任何语言编写CGI,包括流行的C、C ++、VB 和Delphi 等。CGI 分为标准CGI 和间接CGI两种。标准CGI 使用命令行参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI 又称缓冲CGI,在CGI 程序和CGI 接口之间插入一个缓冲程序，缓冲程序与CGI 接口间用标准输入输出进行通信。 怎么用Apache来调用指定CGI其实调用原理很简单,无非就是配置apache的cgi支持、设置cgi的运行目录和运行cgi的后缀 配置对CGI的支持LoadModule cgi_module modules/mod_cgi.so 定义CGI的目录12345678910111213ScriptAlias /cgi-bin/ &quot;/var/www/cgi-bin/&quot;## &quot;/var/www/cgi-bin&quot; should be changed to whatever your ScriptAliased# CGI directory exists, if you have that configured.#&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; Options Indexes FollowSymLinks MultiViews +ExecCGI AllowOverride None Options None Order allow,deny Allow from all&lt;/Directory&gt; 定义CGI支持的文件后缀AddHandler cgi-script .cgi .py .sh 编写Python脚本的CGI1234567891011#!/usr/bin/env python# -*- coding: UTF-8 -*-import cgiimport cgitbprint &quot;Content-type:text/html&quot;printform = cgi.FieldStorage()name = form.getvalue(&apos;name&apos;)print name 这里要注意的是 apache 调用cgi的时候必须要输出的这一句 ： 12print &quot;Content-type:text/html&quot;print 这个应该是固定格式，具体的原因的话没再深入研究","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"https://summxu.github.io/tags/Python/"}],"author":"BoomXu"},{"title":"博客大改之Ajax、Cookie、PHP","slug":"2018/ajax-cookie-php","date":"2018-03-24T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2018/ajax-cookie-php/","link":"","permalink":"https://summxu.github.io/2018/ajax-cookie-php/","excerpt":"","text":"最近一个星期内，我一直在修改我的博客，直到今天，才算是基本完型。中间修改了很多地方，也学到了很多东西，在这篇博客里就一起回顾下这次博客修改遇到的各种问题吧！ 因为中间隔得天数实在是太多，我也没有时间当时就去整理一番，现在再总结的话，中间肯定会有很多遗漏的地方， 所以说以后每天遇到的新的技术问题一定要及时记录下来。 Jekyll在一开始我先根据Jekyll的内部功能来添加日记，其中主要运用了Jekyll的文章分类功能 categories 我一直以为Jekyll 没有这种功能， 而且在网上查找资料都说得要这么实现很复杂，还有说要修改Jekyll的gem文章遍历的插件，其实并没有这么复杂，只需在文章头部添加文章标签就行了，关于Jekyll 的更多用法，以下这篇博客已经说得很完美了。 http://ju.outofmemory.cn/entry/149459 Cookie我使用了Jquery的cookie插件，其使用方法很简单，试用cookie的原因主要是不用每篇日记或者说是每次打开的时候都会进行密码验证。一开始想的是直接把密码从服务端取出来然后在本地判断，这样还省去了每次都向服务器端发送局的麻烦。但是这样行不通，因为密码一旦做本地判断，就不安全。 1.写入Cookie1234567891011$.cookie(&quot;写入的cookie名&quot;,&quot;写入的cookie值&quot;,&#123;expires:7, //含义：有效期，单位：天，可写值：数字、日期对象，默认：如果不写或写null则浏览器关闭后cookie删除path:&quot;/&quot;, //路径，默认是创建该cookie的页面路径domain:&quot;地址&quot;, //域名属性，默认是创建该cookie的页面域名secure:true //如果为true，那么此cookie的传输会要求一个安全协议，例如https&#125;); 2.读取cookiejQuery的读取cookie很简单： $.cookie(&quot;读取的cookie名&quot;) 3.删除cookie写法：$.cookie(&quot;删除的cookie名&quot;,null) //参数null：代表删除此cookie cookie一开始一直有一个问题，就是每一页的验证好像都是一个cookie，找到资料发现是因为没有配置 path 如果要想全站cookie，只要加上 path:”/“ 就好了。下面再继续说下Ajax。 Ajax其实在开始研究学习ajax之前，我感觉这是一种很麻烦动东西，但是仔细研究发现ajax并不是这么难，只是有时候会出现莫名其妙的问题。看看代码和写法： 1234567891011121314151617$.ajax(&#123; type: \"GET\", url: \"http://192.168.1.112/check.php\", data: &#123;pass : $(\"#pass\").val()&#125;, //发送出去的数据 dataType : \"json\", //返回的数据格式 async : false, //同步请求 success: function (data) &#123; if(data.status == 1)&#123; alert(data.status); &#125;else&#123; alert(data.status); &#125; &#125;, // 成功后之执行 error: function()&#123; alert('产生了莫名其妙的错误！'); &#125; // 失败后执行 &#125;); ajax普通的传递,这几个参数还是很 简单的。第一个遇到的问题就是： 2018.8.28 回来看到之前的这个博客那时候的技术还是太浅了， 当时只涉及到jQuery的ajax封装函数，还不知道JavaScript的ajax的请求过程。现在想想，ajax就是创建一个xmlhttprequest对象，再使用open建立连接，然后发送请求直至接受请求。这时可能涉及到请求过程中的4种状态码： 0：初始化，XMLHttpRequest对象还没有完成初始化1：载入，XMLHttpRequest对象开始发送请求2：载入完成，XMLHttpRequest对象的请求发送完成3：解析，XMLHttpRequest对象开始读取服务器的响应4：完成，XMLHttpRequest对象读取服务器响应结束 1234var xhr = new XMLHtttpRequest ()xhr.open(&apos;GET&apos;,&apos;./data.json&apos;,true)xhr.send()xhr.load()&#123;&#125; 跨域请求问题 本地测试是可以正常传输，但是Github上是不支持任何服务器可执行的脚本的，所以我必须用另一个可执行后台的服务器来进行密码验证，这样就要涉及到跨域请求。我在网络上收集了各种解决方法，其中有用 jasonp、加header头 还有各种很复杂的方法，但是在这其中header头是最简单的。只需要在后台PHP里加上这么一句：header(&#39;Access-Control-Allow-Origin:*&#39;); 异步请求问题 ajax中有一个参数就是 async : false 就是是否异步请求，默认是异步的，这个意思就是 ajax运行的时候能同时运行其他的东西 就像是多线程一样 但是在实际用的时候，我发现跨域用异步请求的话会很大几率出现请求不成功的情况，我不知道是为什么。 PHP后台接口PHP我之前尝试着做过，但是一直没有怎么学，也没有实际的项目能用上php，现在可以了，我完全可以用PHP做一个后端判断的接口。PHP代码很简单，但是有这么两点注意的地方： 1.做接口一定要加上 `error_reporting(E_ERROR);`我之前见过别人的接口就是加上了这个，这句话的意思是不让PHP输出错误提示，有时候输出来错误提示返回出来的数据就不是标准的格式了。 2.就是跨域请求的header头。123456789101112131415161718&lt;?php // /*验密码码是否正确*/ error_reporting(E_ERROR); header(&apos;Access-Control-Allow-Origin:*&apos;); $code = trim($_GET[&apos;pass&apos;]);//接收前端传来的数据 $raw_success = array(&apos;status&apos; =&gt; 1 , &apos;word&apos; =&gt; $code); $res_success = json_encode($raw_success); $raw_fail = array(&apos;status&apos; =&gt; 0); $res_fail = json_encode($raw_fail); if ($code == &quot;想什么呢&quot;) &#123; echo $res_success; &#125; else &#123; echo $res_fail; &#125;?&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"初入股市新体验-开户和第一股","slug":"2018/stock-first","date":"2018-03-14T16:00:00.000Z","updated":"2023-12-12T04:51:40.867Z","comments":true,"path":"2018/stock-first/","link":"","permalink":"https://summxu.github.io/2018/stock-first/","excerpt":"","text":"时隔一段时间，遇到了很多事没记录，中间沉迷游戏 。现在转眼到了大三下学期，却还没有拿到证书什么的。我打算开始学习，但是在此期间，我想去学习金融，也就是从股市开始。。 2018年3月12日 成功在《中泰证券》开户2018年3月13日 存入5700元 并购买了以下两股 002012 凯恩股份 7.98 买入 400股 000806 银河生物 8.20 买入 300股 2018年3月14日 7.69 卖出银河生物 亏损1552018年3月15日 1.89 卖出凯恩股份 亏损50 随即买入 601996 丰林集团目前亏损23 其中 银河生物 丰林集团 都是高价卖了然后跌，凯恩股份是平价买的，然后跌了就卖了，然后又涨上来了。 我认为在我操作中还存在许多问题： 1、分时买的时候找不到最低点 2、分时卖的时候找不到最高点，不知道是否还会反弹。 3、没有良好的心里准备，盲目购买不过最近我也在看视频或者知乎大神的方法的时候了解了些知识： 看分时最高点： 在走势第一波冲高的时候不要着急，等回落后看第二波冲高，如果第一波冲高的量和第二波的量差距不大，那么很有可能会有第三波冲高。如果说第一波冲高的量明显大于第二波的量，那么则很有可能高点诞生。 下跌反弹： 看了吴浅的股票乐园，他说下跌分为急跌和缓跌两种，缓跌一定要出局，急跌瞬间拉起来就可以再等等看。 总的来说最为一个新手我还什么都不知道 但是下一个要学习的技术是要设置止损位 。 2018年3月15日17点00分","categories":[],"tags":[{"name":"生活分享","slug":"生活分享","permalink":"https://summxu.github.io/tags/生活分享/"}],"author":"BoomXu"},{"title":"西游记中有什么可悲的细节？","slug":"2017/xiyouji-kebei","date":"2017-06-30T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/xiyouji-kebei/","link":"","permalink":"https://summxu.github.io/2017/xiyouji-kebei/","excerpt":"","text":"最可悲，最让人心酸的莫过于黄狮精。 要说西游记里最善良最老实的妖怪是谁，莫过于黄狮精和他手下的小妖。 孙悟空去追查兵器时遇到黄狮精手下的两个狼头怪，他们在说什么呢？ “我们也有些侥幸。拿这二十两银子买猪羊去，如今到了前方集上，先吃几壶酒儿，把东 西开个花帐儿，落他二三两银子，买件绵衣过寒，却不是好？”两个怪说说笑笑的，上大路急走如飞。 能吃上几壶，还能买上件棉衣以后冬天不用挨冻就能让他们欣喜的有说有笑，高兴的都快飞起来。这样老实本分的苦逼日子，是那些动不动捉个人来吃的妖怪能想象的吗？ 孙悟空定住了两个小妖，取走了带给他俩无限欣喜的二十两银子，跟猪八戒变作小妖模样，让沙僧化妆成卖猪羊的，跟他们回去给黄狮精说，还欠他五两银子。 妖王听说，即唤：“小的们，取五两银子，打发他去。” 换成别的妖精，早就一口把他吞了，还想要银子？但黄狮精立马就给，连个价都不还，老实巴交到这种程度。 然后孙悟空说猪羊贩子要看那几件兵器，黄狮精做贼心虚，怕玉华州王子”一时来访求”，自己说不过去，不敢让看。但经不住孙悟空劝，他还是答应让看了。 看到这里，86 版西游记编剧都看不下去了。要是按原著中拍出来，这妖怪也太本分好说话了吧，这样一个妖怪被孙悟空打死并分尸，也太损孙悟空除暴安良的形象了。于是改成了，以白送鸭子作为交换条件来看兵器。 可实际上不仅银子照给，还白管一顿酒饭。 说不了，有一小妖，取了五两银子，递与行 者。行者将银子递与沙僧道：“客人，收了银子，我与你进后面去吃些饭来。” 黄狮精只是嘱咐 那怪王随后跟着道：“客人，那中间放光亮的就是钉钯。你看便看，只是出 去，千万莫与人说。” 换了别的妖怪早杀了灭口了吧。 偷了三件兵器是犯了盗窃罪，关上三五年也就差不多了，十年也就顶天了吧。可是终身监禁孙悟空都不愿意，杀了黄狮精，还灭了他满门，并且把黄狮精分尸吃了。 辛辛苦苦赚来的家当，就这样被孙悟空烧了，全家的老小被灭了。吴承恩对黄狮精的悲痛毫不吝啬笔墨。 那妖精闻言，止不住泪如泉涌，双脚齐跌，喊声振天，恨道：“那秃厮！十分作恶！怎 么干出这般毒事，把我洞府烧尽，美人烧死，家当老小一空！气杀我也，气杀我也！” 1 在灭顶的打击之下，黄狮精崩溃了，甚至都不想去报仇，只想撞墙自杀。 “老爷！我那们个山场，非一日治的，今被这秃厮尽毁，我却要此命做甚的！”挣起来，往石崖上撞头磕脑，被雪狮、猱 狮等苦劝方止。 一个不肯伤天害理，老实本分，买卖公平，与人为善的黄狮精老小被灭了，自己被杀，然后尸体被分吃了。 那个吃了一城人的大鹏，作了如来的护法。 金鱼精每年吃一对童男童女，村民们还大拜金鱼精的主人。 黄袍怪吃人随便，只被罚俸几天。 蜈蚣精毒翻多少路人，作了护法大神。 这就是名著，不像三流小说一样，主角不是高大上做什么都是正义的，主角的对手也不一定是该死的坏人，最后恶人也不一定得恶报，真实地描绘了这个复杂的世界。 转自知乎 待我施为地煞变的回答：https://www.zhihu.com/question/51682490","categories":[],"tags":[{"name":"文学分享","slug":"文学分享","permalink":"https://summxu.github.io/tags/文学分享/"}],"author":"BoomXu"},{"title":"优雅的使用Email和Rss以便让生活井井有序","slug":"2017/email-rss-xiantan","date":"2017-06-27T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/email-rss-xiantan/","link":"","permalink":"https://summxu.github.io/2017/email-rss-xiantan/","excerpt":"","text":"高逼格的生活方式依然不能离开Email. 有质量的内容依然会用Rss订阅. Email邮件几户贯穿整个互联网史的发展，直到现在一些很正式的场合依然用Email来通信，各种企业之间的商务交流等等。 但是随着互联网的发展很快就有了各种产品来替代Email,比如IM即时通信的流行各种各样的聊天软件。 Email在中国可以说不太流行，唯一能让所有人都拥有一个邮箱的估计还是QQ邮箱，要不是腾讯，或许大部分的人都不会去注册一个邮箱。不过如果你要是觉得Email只能和朋友和一些陌生的人发些邮件来通信，那你就OUT了。Email的功能远不止如此。 这里我说说Email的各种用法或许会让我们方便不少。 客户端和服务商Email是要有客户端的支持(现在的邮件服务商都提供了网页版)，无论你用的哪家的Email服务，都可以用各种客户端去同步你的邮件。现在基本的的邮件服务有很多家，其中比较常见的： QQ邮箱 QQ邮箱是腾讯公司在2002年推出的邮箱服务。2005年3月，腾讯收购Foxmail，张小龙及研发团队20余人不久后进入腾讯。 虽然QQ的邮箱域显得不太正式，但是不的不说QQ邮箱是让我们大部分人拥有的第一个邮箱。 网易邮箱 网易的邮箱有：163、126和yeah.net 目前是国内的主流邮箱服务之一。在国内非常流行也是国内邮箱的首选品牌。目前官方宣称用户总数突破5亿。 我没用过网易的邮箱，感觉广告太多了。 雅虎邮箱 雅虎邮箱是世界邮箱服务商之一，规模非常大，于1997年10月8日激活。不过好像是不对国内用户开放，或者之前开放过后来停了。 Outlook Outlook是非常老牌的邮箱服务商了，他有自己的邮件客户端，界面也比较简洁功能也很多。国内也可以用。 Gmail 自我感觉是最好用的邮箱，但是因为谷歌推出了中国市场导致其所有服务全部不能用。所以，没有什么办法。无奈之下只好暂时放弃 无论是在Android、IOS、windows上都支持邮件也有自带的邮件客户端。 介绍了几大服务商，下面说说功能。 邮件服务电子邮件是整个网络间以至所有其他网络系统中直接面向人与人之间信息交流的系统，它的数据发送方和接收方都是人，所以极大地满足了大量存在的人与人之间的通信需求。 电子邮件指用电子手段传送信件、单据、资料等信息的通信方法。电子邮件综合了电话通信和邮政信件的特点，它传送信息的速度和电话一样快，又能像信件一样使收信者在接收端收到文字记录。电子邮件系统又称基于计算机的邮件报文系统。它参与了从邮件进入系统到邮件到达目的地为止的全部处理过程。电子邮件不仅可利用电话网络，而且可利用其它任何通信网传送。在利用电话网络时,还可在其非高峰期间传送信息，这对于商业邮件具有特殊价值。由中央计算机和小型计算机控制的面向有限用户的电子系统可以看作是一种计算机会议系统。电子邮件采用储存-转发方式在网络上逐步传递信息，不像电话那样直接、及时，但费用低廉。 联系人同步这是我认为除了发邮件最重要的一个功能了，也特别好用。 这可以解决你的很多问题： 换手机了联系人还要导入到SIM卡里在导出来？ 在电脑上不能查看自己的联系人？ 有了未接来电信息不能多端同步？ 邮箱可以给你解决这些问题。 你只需要在手机上登录上邮箱账户，添加联系人时选择添加到邮箱账户即可，也可以把联系人导出成CVS格式的信息导入到邮箱里，以上介绍的各大邮箱服务商都支持联系人导入。 手机上： 图片1 电脑上： img2 日历同步邮箱可以同步你的日历，无论是在电脑上还是手机上，你的日程安排都可以实时的同步起来，并且还能很多设备都同步提醒。 手机上： IMG6 电脑上： img8 除此之外，你还能去订阅一些天气日历节假日，在OUTLOOK上还能看到一些有趣的日历订阅。 img3 img4 更多功能可以看到，以OUTLOOK为例还有很多可以同步的功能： img9 邮箱的便捷性不止于发邮件，希望这些能让我们的生活习惯更好。 Rss什么是Rss RSS是在线共享内容的一种简易方式（也叫聚合内容，全称Really Simple Syndication）。使用RSS订阅能更快地速获取信息和获取网站内容的最新更新。更直白的说，你可以不用再一一打开各个网站页面，而是通过阅读器一次一起阅读所有你订阅了的网站的最新内容。 订阅RSS有什么优点？ 加载速度快，一次阅读所有订阅的网站； 阅读器阅读通常都非常简洁，网站上的广告等都不会有； 不受功夫网的影响，能够继续通过RSS订阅阅读最新文章； 及时更新，若源网站有发表新文章，马上就可以阅读到； 全部信息都能在RSS阅读器内读完，不再需要一个一个地刷新各个网站页面。 如何订阅RSS？ 使用RSS阅读器 主要有在线阅读器和离线阅读器两种。弥缝没用过离线阅读器，所以这儿就不做推荐，而且弥缝推荐使用更加方便的在线阅读器，比如说Google Reader、抓虾、鲜果、QQ阅读、有道阅读、豆瓣九点和一些个性化主页（Netvibes）等等。 在线阅读的好处在于你可以在任何地方（使用手机/电脑等）通过登录帐号来阅读你订阅的信息，而离线阅读器是不行的。 如果你比较偏好Google可以使用Google Reader，只需使用你的Gmail帐号登录即可。 使用Email 可以通过Email服务商来在线订阅Rss，如果有更新会通过邮件的方式发给你。现在基本的邮件服务商都支持填写Rss订阅地址。 订阅BoomXu本博客的订阅地址 https://www.BoomXu.com/feed.xml 或者可以点击网站下下方的订阅按钮来获取Rss地址： 推荐的订阅源知乎每日精选（强烈推荐） 知乎日报（非常宝贵的源） nhzy资讯（健康生活） 果壳网（科普生活） 科学松鼠会（科普） 科学公园（分析各种误区） 泛科学（台湾的科普资讯） Matrix67（数学爱好者） 战隼的学习探索（效率生活） 更多的源可以去仔细看这篇回答：你必读的 RSS 订阅源有哪些？ END老套的东西并不是没有用的，需要你用一双发现美的眼睛去欣赏它，或许他会使你的生活更加美好。科技如此，其他更是如此。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"Linux下Shell学习 --基础1","slug":"2017/linux-shell-1","date":"2017-06-26T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/linux-shell-1/","link":"","permalink":"https://summxu.github.io/2017/linux-shell-1/","excerpt":"","text":"今天学习下Shell,发现非常简单，语法也很是随意，在此记录下学习过程。 Shell介绍Shell和Shell脚本Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。 Shell 环境Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） …… 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。 #! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 Hello world12#!/bin/bashecho &quot;Hello world&quot; 变量及数组12345678910111213141516171819202122#!/bin/bashonly=&quot;我是只读变量&quot;readonly only#only=&quot;我不是只读变量&quot;del=&quot;我被删除了&quot;unset dela=&apos;陈旭&apos;str=&quot;hello,$&#123;a&#125;&quot;array=(陈旭 神还套 梁航宇)echo &quot;ni hao a wo shi $a heihei &quot;echo $onlyecho $delecho $strecho &quot;字符串长度为：$&#123;#str&#125;&quot;echo &quot;提取字符串陈旭：$&#123;str:6:4&#125;&quot;echo $array $&#123;array[1]&#125; $&#123;array[2]&#125;echo &quot;数组长度是：$&#123;#array[*]&#125;&quot;echo &quot;数组所有元素：$&#123;array[*]&#125;&quot; 参数传递123456789101112#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;echo &quot;参数个数 $#&quot;echo &quot;参数字符串 $*&quot;echo &quot;运行ID号 $$&quot; 运算符表达式12345678910111213141516#!/bin/basha=10b=22add=`expr $a + $b`quyu=`expr $b % $a`cheng=`expr $a \\* $b`echo &quot;A+B=：$add&quot;echo &quot;取余：$quyu&quot;echo &quot;A乘B：$cheng&quot;if [ $a == $b ]thenecho &quot;A大于B&quot;fiecho &quot;B大于A&quot; 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://summxu.github.io/tags/Shell/"}],"author":"BoomXu"},{"title":"Linux下Shell学习 --基础2","slug":"2017/linux-shell-2","date":"2017-06-26T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/linux-shell-2/","link":"","permalink":"https://summxu.github.io/2017/linux-shell-2/","excerpt":"","text":"今天学习下Shell,发现非常简单，语法也很是随意，在此记录下学习过程。 echoecho 命令也很简单，在这里记下几个不常用到的。 显示命令执行结果1echo `date` 显示不换行123#!/bin/shecho -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行echo &quot;It is a test&quot; 显示换行12echo -e &quot;OK! \\n&quot; # -e 开启转义echo &quot;It it a test&quot; test文件测试 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 分支语法12345678910#!/bin/bashnum1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;两个数字相等!&apos;else echo &apos;两个数字不相等!&apos;fi 循环语法Shell的循环方式比较多，一开始不太好用， 我选择了基本和C语言方法相同的语法，现在理解是基本用法都差不多。 C语言方式123456789101112131415161718192021#!/bin/bashnum1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;两个数字相等!&apos;else echo &apos;两个数字不相等!&apos;fiecho `expr 100 % 3`#100以内可以被3整除for ((i=1;i&lt;100;i++))doif [ `expr $i % 3` == 0 ]thenecho $ifidone for in1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 例子： 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done while 语句1234while conditiondo commanddone case123456789101112131415echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in 1) echo &apos;你选择了 1&apos; ;; 2) echo &apos;你选择了 2&apos; ;; 3) echo &apos;你选择了 3&apos; ;; 4) echo &apos;你选择了 4&apos; ;; *) echo &apos;你没有输入 1 到 4 之间的数字&apos; ;;esac 跳出循环break命令break命令允许跳出所有循环（终止执行后面的所有循环）。下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。 12345678910111213#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone continuecontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。对上面的例子进行修改： 1234567891011121314#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; ;; esacdone 函数12345678910111213#!/bin/bashfunWithReturn()&#123; echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 函数参数123456789101112#!/bin/bashfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 求素数DEMO12345678910111213141516171819#!/bin/bash#求100以内的所有素数for((i=2;i&lt;100;i++))do k=1 for((j=2;j&lt;i;j++)) do if((`expr $i % $j` == 0)) then k=0 break fi done if [ $k == 1 ] then echo $i fidone","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://summxu.github.io/tags/Shell/"}],"author":"BoomXu"},{"title":"Linxu下安装Node.js","slug":"2017/nodejs-install-linux","date":"2017-06-25T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/nodejs-install-linux/","link":"","permalink":"https://summxu.github.io/2017/nodejs-install-linux/","excerpt":"","text":"系统环境：Ubuntu 32位 下载Node.js首先去官网复制下Node.js的Source Code包地址 1 然后用 weget 来下载编译包。 2 安装Node.js先解压包 12tar -xf node-v6.11.0.tar.gzcd node-v6.11.0 配置并编译 12./configuremake 5 安装 1sudo make install 检查安装12node -vnpm -v 7 创建nodejs项目目录 mkdir -p /usr/local/nodejs/ 创建hello.js文件 vi /usr/local/nodejs/hello.js 内容如下： 123456789var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123; \"Content-Type\" : \"text/plain\" // 输出类型 &#125;); response.write(\"Hello BoomXu\");// 页面输出 response.end();&#125;).listen(8100); // 监听端口号console.log(\"nodejs start listen 8100 port!\"); 开启nodejs服务 node hello.js 8 浏览器访问 http://127.0.0.1:8100/ 6","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"Node.js","slug":"Node-js","permalink":"https://summxu.github.io/tags/Node-js/"}],"author":"BoomXu"},{"title":"Linux下C语言实现Socket通信","slug":"2017/linux-socket-c","date":"2017-06-24T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/linux-socket-c/","link":"","permalink":"https://summxu.github.io/2017/linux-socket-c/","excerpt":"","text":"网络协议与分析让做一个利用Socket(套接字)来实现双方的即时通信功能，参考网络的源代码和介绍并实现Linux下的C语言编程。 1、网络中进程之间如何通信？ 2、Socket是什么？ 3、socket的基本操作 3.1、socket()函数 3.2、bind()函数 3.3、listen()、connect()函数 3.4、accept()函数 3.5、read()、write()函数等 3.6、close()函数 4、socket中TCP的三次握手建立连接详解 5、socket中TCP的四次握手释放连接详解 6、代码实现 7、运行结果 1、网络中进程之间如何通信？本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类： 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris门和Sun RPC） 但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。 2、Socket是什么？上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。 在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。” 3、socket的基本操作既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。 3.1、socket()函数 int socket(int domain, int type, int protocol);socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。 正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为： domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。 protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。 3.2、bind()函数正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 函数的三个参数分别为： sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。 addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。 addrlen：对应的是地址的长度。 通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。 主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下： a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。 所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。 3.3、listen()、connect()函数如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。 int listen(int sockfd, int backlog); int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。 connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。 3.4、accept()函数TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。 注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。 3.5、read()、write()函数等万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组： read()/write() recv()/send() readv()/writev() recvmsg()/sendmsg() recvfrom()/sendto() read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。 write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。 其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。 3.6、close()函数在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。 #include &lt;unistd.h&gt; int close(int fd); close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。 注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 4、socket中TCP的三次握手建立连接详解我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下： 客户端向服务器发送一个SYN J 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1 客户端再想服务器发一个确认ACK K+1 只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图： 1 从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。 总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。 5、socket中TCP的四次握手释放连接详解上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图： 图示过程如下： 2 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M； 另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N； 接收到这个FIN的源发送端TCP对它进行确认。 这样每个方向上都有一个FIN和ACK。 6、代码实现服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;strings.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;memory.h&gt;#include &lt;unistd.h&gt;//#include &lt;linux/in.h&gt;#include &lt;netinet/in.h&gt;//#include &lt;linux/inet_diag.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#define PORT 11910 //定义通信端口#define BACKLOG 5 //定义侦听队列长度#define buflen 1024void process_conn_server(int s);void sig_pipe(int signo);int ss,sc; //ss为服务器socket描述符，sc为某一客户端通信socket描述符int main(int argc,char *argv[])&#123; struct sockaddr_in server_addr; //存储服务器端socket地址结构 struct sockaddr_in client_addr; //存储客户端 socket地址结构 int err; //返回值 pid_t pid; //分叉进行的ID /*****************socket()***************/ ss = socket(AF_INET,SOCK_STREAM,0); //建立一个序列化的，可靠的，双向连接的的字节流 if(ss&lt;0) &#123; printf(&quot;server : server socket create error\\n&quot;); return -1; &#125; //注册信号 sighandler_t ret; ret = signal(SIGTSTP,sig_pipe); if(SIG_ERR == ret) &#123; printf(&quot;信号挂接失败\\n&quot;); return -1; &#125; else printf(&quot;信号挂接成功\\n&quot;); /******************bind()****************/ //初始化地址结构 memset(&amp;server_addr,0,sizeof(server_addr)); server_addr.sin_family = AF_INET; //协议族 server_addr.sin_addr.s_addr = htonl(INADDR_ANY); //本地地址 server_addr.sin_port = htons(PORT); err = bind(ss,(struct sockaddr *)&amp;server_addr,sizeof(sockaddr)); if(err&lt;0) &#123; printf(&quot;server : bind error\\n&quot;); return -1; &#125; /*****************listen()***************/ err = listen(ss,BACKLOG); //设置监听的队列大小 if(err &lt; 0) &#123; printf(&quot;server : listen error\\n&quot;); return -1; &#125; /****************accept()***************/ /** 为类方便处理，我们使用两个进程分别管理两个处理： 1，服务器监听新的连接请求;2,以建立连接的C/S实现通信 这两个任务分别放在两个进程中处理，为了防止失误操作 在一个进程中关闭 侦听套接字描述符 另一进程中关闭 客户端连接套接字描述符。注只有当所有套接字全都关闭时 当前连接才能关闭，fork调用的时候父进程与子进程有相同的 套接字，总共两套，两套都关闭掉才能关闭这个套接字 */ for(;;) &#123; socklen_t addrlen = sizeof(client_addr); //accept返回客户端套接字描述符 sc = accept(ss,(struct sockaddr *)&amp;client_addr,&amp;addrlen); //注，此处为了获取返回值使用 指针做参数 if(sc &lt; 0) //出错 &#123; continue; //结束此次循环 &#125; else &#123; printf(&quot;server : connected\\n&quot;); &#125; //创建一个子线程，用于与客户端通信 pid = fork(); //fork 调用说明：子进程返回 0 ；父进程返回子进程 ID if(pid == 0) //子进程，与客户端通信 &#123; close(ss); process_conn_server(sc); &#125; else &#123; close(sc); &#125; &#125;&#125;/** 服务器对客户端连接处理过程；先读取从客户端发送来的数据， 然后将接收到的数据的字节的个数发送到客户端 *///通过套接字 s 与客户端进行通信void process_conn_server(int s)&#123; ssize_t size = 0; char buffer[buflen]; //定义数据缓冲区 for(;;) &#123; //等待读 for(size = 0;size == 0 ;size = read(s,buffer,buflen)); //输出从客户端接收到的数据 printf(&quot;%s&quot;,buffer); //结束处理 if(strcmp(buffer,&quot;quit&quot;) == 0) &#123; close(s); //成功返回0，失败返回-1 return ; &#125; sprintf(buffer,&quot;%d bytes altogether\\n&quot;,size); write(s,buffer,strlen(buffer)+1); &#125;&#125;void sig_pipe(int signo)&#123; printf(&quot;catch a signal\\n&quot;); if(signo == SIGTSTP) &#123; printf(&quot;接收到 SIGTSTP 信号\\n&quot;); int ret1 = close(ss); int ret2 = close(sc); int ret = ret1&gt;ret2?ret1:ret2; if(ret == 0) printf(&quot;成功 : 关闭套接字\\n&quot;); else if(ret ==-1 ) printf(&quot;失败 : 未关闭套接字\\n&quot;); exit(1); &#125;&#125; 客户端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;stdio.h&gt;#include &lt;strings.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;//#include &lt;linux/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;signal.h&gt; //添加信号处理 防止向已断开的连接通信/** 信号处理顺序说明：在Linux操作系统中某些状况发生时，系统会向相关进程发送信号， 信号处理方式是：1，系统首先调用用户在进程中注册的函数，2，然后调用系统的默认 响应方式,此处我们可以注册自己的信号处理函数，在连接断开时执行 */#define PORT 11910#define Buflen 1024void process_conn_client(int s);void sig_pipe(int signo); //用户注册的信号函数,接收的是信号值int s; //全局变量 ， 存储套接字描述符int main(int argc,char *argv[])&#123; sockaddr_in server_addr; int err; sighandler_t ret; char server_ip[50] = &quot;&quot;; /********************socket()*********************/ s= socket(AF_INET,SOCK_STREAM,0); if(s&lt;0) &#123; printf(&quot;client : create socket error\\n&quot;); return 1; &#125; //信号处理函数 SIGINT 是当用户按一个 Ctrl-C 建时发送的信号 ret = signal(SIGTSTP,sig_pipe); if(SIG_ERR == ret) &#123; printf(&quot;信号挂接失败\\n&quot;); return -1; &#125; else printf(&quot;信号挂接成功\\n&quot;) ; /*******************connect()*********************/ //设置服务器地址结构，准备连接到服务器 memset(&amp;server_addr,0,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); server_addr.sin_addr.s_addr = htonl(INADDR_ANY); /*将用户数入对额字符串类型的IP格式转化为整型数据*/ //inet_pton(AF_INET,argv[1],&amp;server_addr.sin_addr.s_addr); printf(&quot;please input server ip address : \\n&quot;); read(0,server_ip,50); //err = inet_pton(AF_INET,server_ip,&amp;server_addr.sin_addr.s_addr); server_addr.sin_addr.s_addr = inet_addr(server_ip); err = connect(s,(struct sockaddr *)&amp;server_addr,sizeof(sockaddr)); if(err == 0) &#123; printf(&quot;client : connect to server\\n&quot;); &#125; else &#123; printf(&quot;client : connect error\\n&quot;); return -1; &#125; //与服务器端进行通信 process_conn_client(s); close(s);&#125;void process_conn_client(int s)&#123; ssize_t size = 0; char buffer[Buflen]; for(;;) &#123; memset(buffer,&apos;\\0&apos;,Buflen); /*从标准输入中读取数据放到缓冲区buffer中*/ size = read(0,buffer,Buflen); // 0，被默认的分配到标准输入 1，标准输出 2，error if(size &gt; 0) &#123; //当向服务器发送 “quit” 命令时，服务器首先断开连接 write(s,buffer,strlen(buffer)+1); //向服务器端写 //等待读取到数据 for(size = 0 ; size == 0 ; size = read(s,buffer,Buflen) ); write(1,buffer,strlen(buffer)+1); //向标准输出写 &#125; &#125;&#125;void sig_pipe(int signo) //传入套接字描述符&#123; printf(&quot;Catch a signal\\n&quot;); if(signo == SIGTSTP) &#123; printf(&quot;接收到 SIGTSTP 信号\\n&quot;); int ret = close(s); if(ret == 0) printf(&quot;成功 : 关闭套接字\\n&quot;); else if(ret ==-1 ) printf(&quot;失败 : 未关闭套接字\\n&quot;); exit(1); &#125;&#125; 运行结果 21 22","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"C语言","slug":"C语言","permalink":"https://summxu.github.io/tags/C语言/"}],"author":"BoomXu"},{"title":"通过CSS添加网页的动画效果","slug":"2017/add-css-effect","date":"2017-06-16T06:03:56.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/add-css-effect/","link":"","permalink":"https://summxu.github.io/2017/add-css-effect/","excerpt":"","text":"昨天写了通过jQuery添加网页的动画效果来美化了一下博客，发现jQuery的动画效果卡出翔，别说美观了，用户体验都没保证，今天更新下用CSS添加网页特效，顺便记录下自己的CSS的学习；。 在网上查阅相关CSS动画特效的资料，发现了一个CSS样式库：Aninmate.css这次主要是对这个样式库进行介绍，里面有很多好看的动画样式。 Aninmate.css这里有个Aninmate样式的各个效果预览：点我查看 我打包了Aninmate.css的引入文件几Demo：在此下载 简介animate.css 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果 ，几乎包含了所有常见的动画效果。 虽然借助 animate.css 能够很方便、快速的制作 CSS3 动画效果，但还是 建议看看 animate.css 的代码，也许你能从中学到一些东西。 兼容浏览器兼容：当然是只兼容支持 CSS3 animate 属性的浏览器，他们分别是：IE10+、Firefox、Chrome、Opera、Safari。 使用方法 当然首先要引入样式文件 1&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.min.css&quot;&gt; HTML 及使用 1&lt;div class=&quot;animated bounce&quot; id=&quot;dowebok&quot;&gt;&lt;/div&gt; 给元素加上 class 后，刷新页面，就能看到动画效果了。animated 类似于全局变量，它定义了动画的持续时间；bounce 是动画具体的动画效果的名称，你可以选择任意的效果。 如果动画是无限播放的，可以添加 class infinite。 你也可以通过 JavaScript 或 jQuery 给元素添加这些 class，比如： 123$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;);&#125;); 有些动画效果最后会让元素不可见，比如淡出、向左滑动等等，可能你又需要将 class 删除，比如： 123456$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;); setTimeout(function()&#123; $(&apos;#dowebok&apos;).removeClass(&apos;bounce&apos;); &#125;, 1000);&#125;); animate.css 的默认设置也许有些时候并不是我们想要的，所以你可以重新设置，比如： 12345#dowebok &#123; animate-duration: 2s; //动画持续时间 animate-delay: 1s; //动画延迟时间 animate-iteration-count: 2; //动画执行次数&#125; Github地址 https://github.com/daneden/animate.css 我的引用代码本次引用了两个页面，一个文章Post页，一个是博客首页： post页： 123&lt;a class=&quot;tag animated bounceInDown&quot; href=&quot;&#123; &#123; site.baseurl &#125; &#125;/tags/#&#123; &#123; tag &#125; &#125;&quot; title=&quot;&#123; &#123; tag &#125; &#125;&quot;&gt;&#123; &#123; tag &#125; &#125;&lt;/a&gt;&lt;h1 class=&quot;animated rotateInDownLeft&quot;&gt;&#123; &#123; page.title &#125; &#125;&lt;/h1&gt;&lt;h2 class=&quot;subheading animated rotateInUpRight&quot;&gt;&#123; &#123; page.subtitle &#125; &#125;&lt;/h2&gt; 首页： 12&lt;h1 class=&quot;animated flipInX&quot;&gt;&#123;% if page.title %&#125;&#123; &#123; page.title &#125; &#125;&#123;% else %&#125;&#123; &#123; site.title &#125; &#125;&#123;% endif %&#125;&lt;/h1&gt;&lt;span class=&quot;subheading animated flipInY&quot;&gt;&#123; &#123; page.description &#125; &#125;&lt;/span&gt; 为什么jQuery会卡顿?让我们从基本开始说起： Javascript 和 jQuery 两者不能混为一谈。Javascript 动画很快，而 jQuery 动画很慢。为什么呢？因为尽管 jQuery 异常强大，但是它的设计目标并不是一个高效的动画引擎： jQuery 不能避免 layout thrashing （有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。 jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易让动画卡住。 jQuery使用了setInterval而不是 reqeustAnimationFrame(RAF)，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF） 注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。 总结CSS3也是个很强大的东西，前端的资源真的是很多很多。没想到还有专门的动画效果CSS库，在以后还会更加灵活的去运用其他第三方的库。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"}],"author":"BoomXu"},{"title":"Git的常用操作","slug":"2017/git-usually-opera","date":"2017-06-15T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/git-usually-opera/","link":"","permalink":"https://summxu.github.io/2017/git-usually-opera/","excerpt":"","text":"Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。 *Git 是 Linus Torvalds *为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 常用操作查看、添加、提交、删除、找回，重置修改文件git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异 git diff git diff # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支git br -r # 查看远程分支 git br # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b # 创建新的分支，并且切换过去 git co -b # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b origin/ # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin # 创建远程分支， origin是远程仓库名 git push origin : # 创建远程分支 git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理GitHub git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库 git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://summxu.github.io/tags/Git/"}],"author":"BoomXu"},{"title":"通过jQuery添加网页的动画效果","slug":"2017/add-jquery-effect","date":"2017-06-14T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/add-jquery-effect/","link":"","permalink":"https://summxu.github.io/2017/add-jquery-effect/","excerpt":"","text":"看了下同学的Hexo博客，Next的动态主题简直帅炸，不服气，我的Jekyll也可以做到。刚会点jQuery正好顺便研究一下动画效果。随便弄弄也花费了2个小时，不过学到了很多。 jQuery 效果函数由于新手所以只弄了jQuery提供的默认动画（感觉已经很好看了）。查阅相关资料： 方法 描述 animate() 对被选元素应用“自定义”的动画 clearQueue() 对被选元素移除所有排队的函数（仍未运行的） delay() 对被选元素的所有排队函数（仍未运行）设置延迟 dequeue() 运行被选元素的下一个排队函数 fadeIn() 逐渐改变被选元素的不透明度，从隐藏到可见 fadeOut() 逐渐改变被选元素的不透明度，从可见到隐藏 fadeTo() 把被选元素逐渐改变至给定的不透明度 hide() 隐藏被选的元素 queue() 显示被选元素的排队函数 show() 显示被选的元素 slideDown() 通过调整高度来滑动显示被选元素 slideToggle() 对被选元素进行滑动隐藏和滑动显示的切换 slideUp() 通过调整高度来滑动隐藏被选元素 stop() 停止在被选元素上运行动画 toggle() 对被选元素进行隐藏和显示的切换 这是jQuery提供的效果函数，发现可以用到的默认的其实只有两个：fadeIn() 、 slideToggle() 代码因为fadeIn() 、 slideToggle() 函数都是在元素为隐藏的情况下才能显示效果，所以要先在样式里把div给隐藏掉，为了不出错，我先写了一个小例子： 可以点击此处预览下效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .demo&#123; display:none; &#125; .demo1&#123; display:none; &#125; &lt;/style&gt; &lt;script&gt; $(document).ready(function () &#123; $(\".demo1\").slideToggle(1500); $(\"#effect1\").slideToggle(1500); $(\"#effect2\").fadeIn(\"slow\"); $(\"#effect3\").slideDown(1500); &#125;); $(function()&#123; $(\"#ok\").click(function()&#123; $(\"#effect4\").animate(&#123;left: \"500px\"&#125;,3000) .animate(&#123;height:\"200px\"&#125;,1000); &#125;);&#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"effect1\" class=\"demo\"&gt; &lt;p&gt;我是逐渐下拉的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div id=\"effect2\" class=\"demo\"&gt; &lt;p&gt;我是淡入淡出的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div id=\"effect3\" class=\"demo\"&gt; &lt;p&gt;我是向下滑动的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div id=\"effect4\"&gt; &lt;p&gt;我是向上滑动的效果&lt;/p&gt; &lt;p&gt;或许两行才能更好的体现&lt;/p&gt; &lt;/div&gt; &lt;div class=\"demo1\"&gt; &lt;p&gt;我没有id&lt;/p&gt; &lt;/div&gt; &lt;input id=\"ok\" type=\"button\" value=\"点我试试\"&gt;&lt;/body&gt; 然后写到了Jekyll _post里: 1234567891011121314151617181920212223242526&lt;style type=&quot;text/css&quot;&gt; .tags&#123; display: none; &#125; .title&#123; display: none; &#125; .effect&#123; display: none; &#125;&lt;/style&gt;&lt;div class=&quot;tags&quot;&gt; &#123;% for tag in page.tags %&#125; &lt;a class=&quot;tag&quot; href=&quot;&#123; &#123; site.baseurl &#125; &#125;/tags/#&#123; &#123; tag &#125; &#125;&quot; title=&quot;&#123; &#123; tag &#125; &#125;&quot;&gt;&#123; &#123; tag &#125; &#125;&lt;/a&gt; &#123;% endfor %&#125;&lt;/div&gt; &lt;h1 class=&quot;title&quot;&gt;&#123; &#123; page.title &#125; &#125;&lt;/h1&gt; &lt;div class=&quot;effect&quot;&gt; &#123;% comment %&#125; &#123;% endcomment %&#125; &#123;% comment %&#125; if page.subtitle &#123;% endcomment %&#125; &lt;h2 class=&quot;subheading&quot;&gt;&#123; &#123; page.subtitle &#125; &#125;&lt;/h2&gt; &#123;% comment %&#125; endif &#123;% endcomment %&#125; &lt;span class=&quot;meta&quot;&gt;Posted by &#123;% if page.author %&#125;&#123; &#123; page.author &#125; &#125;&#123;% else %&#125;&#123; &#123; site.title &#125; &#125;&#123;% endif %&#125; on &#123; &#123; page.date | date: &quot;%B %-d, %Y&quot; &#125; &#125;&lt;/span&gt;&lt;/div&gt; 遇到的问题其实代码很简单，但是我缺花了近一小时的时间去寻找错误（一开始代码写上不能正常显示）。先是更换本地jQuery然后有换远程jQuery引用 ，却一直没有成功。 最后发现，jQuery要放到页面的头部？？？？ 为什么和我学的不太一样？？？不是引用文件放到哪都可以吗？ nm","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://summxu.github.io/tags/jQuery/"}],"author":"BoomXu"},{"title":"CSS控制背景图片亮度","slug":"2017/css-image-lightness","date":"2017-06-14T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/css-image-lightness/","link":"","permalink":"https://summxu.github.io/2017/css-image-lightness/","excerpt":"","text":"不美观引发的技术思考即实现。。 前言打开博客，细细的看了看自己写的小东西，虽说不好但却是自己一点一点的小经验。但是，种感觉有什么怪怪的。。 1 仔细看看： 2 卧槽。。发现文字颜色为什么和图片融为一体了？？？？我是瞎了吗这么久都没看出来！！！！得赶紧想想办法 想法：opacity首先想到的就是，调暗图片颜色 记得可以使用：css3的opacity:x调整图片透明度，上面弄上全黑背景，因为用的jekyll，所以直接改代码。。。 找到post.html 看了看头部发现代码如下： 123header.intro-header&#123; background-image: url(&apos;&#123;% if page.header-img %&#125;&#123; &#123; page.header-img &#125; &#125;&#123;% else %&#125;&#123; &#123; site.header-img &#125; &#125;&#123;% endif %&#125;&apos;);&#125; 很简单，直接就一个 background-image 然后直接加上覆盖上一个css试试。 1234header.intro-header&#123; background-image: url(&apos;&#123;% if page.header-img %&#125;&#123; &#123; page.header-img &#125; &#125;&#123;% else %&#125;&#123; &#123; site.header-img &#125; &#125;&#123;% endif %&#125;&apos;); opacity: 1;&#125; 3 发现可以透明了，但是整个文字也透明了，这不符合要求啊。。。百度了下，原来用 opacity 是不符合要求的。 实现透明的css方法通常有以下3种方式，以下是不透明度都为80%的写法 css3的opacity:x，x 的取值从 0 到 1，如opacity: 0.8 css3的rgba(red, green, blue, alpha)，alpha的取值从 0 到 1，如rgba(255,255,255,0.8) IE专属滤镜 filter:Alpha(opacity=x)，x 的取值从 0 到 100，如filter:Alpha(opacity=80) 使用说明：设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度..那么使用opacity实现《背景透明，文字不透明》是不可取的。 *opacity *代码示例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;css3的rgba&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background-color:#000000;/* IE6和部分IE7内核的浏览器(如QQ浏览器)下颜色被覆盖 */ background-color:rgba(0,0,0,0.2); /* IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂，但解析为透明 */&#125;.demo p&#123; color: #FFFFFF;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;p&gt;背景透明，文字也透明&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; rgba 很奇葩的是，IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂rgba，解析后颜色为透明，其实应该是null. 管不了这么多了，IE这种被时代抛弃的东西，我才不考虑。. 看了下示例代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;css3的rgba&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background-color:#000000;/* IE6和部分IE7内核的浏览器(如QQ浏览器)下颜色被覆盖 */ background-color:rgba(0,0,0,0.2); /* IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂，但解析为透明 */&#125;.demo p&#123; color: #FFFFFF;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;p&gt;背景透明，文字也透明&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; 加到我的Jekyll post 里看看效果： 4 12345678910&lt;style type=&quot;text/css&quot;&gt; .mengban&#123; background-color:#000000; background-color:rgba(0,0,0,0.2); &#125; header.intro-header&#123; background-image: url(&apos;&#123;% if page.header-img %&#125;&#123; &#123; page.header-img &#125; &#125;&#123;% else %&#125;&#123; &#123; site.header-img &#125; &#125;&#123;% endif %&#125;&apos;); opacity: 1; &#125;&lt;/style&gt; 可以了，但是还是有点白 ， 调整下参数。。完美解决。。 5 不过既然写到这了，在说下IE的: IE专属滤镜 filter:Alpha使用说明：IE浏览器专属，问题多多，本文以设置背景透明为例子，如下： 仅支持IE6、7、8、9，在IE10版本被废除 在IE6、7中，需要激活IE的haslayout属性(如：zoom:1或者overflow:hidden)，让它读懂filter:Alpha 在IE6、7、8中，设置了filter:Alpha的元素，父元素设置position:static(默认属性)，其子元素为相对定位，可让子元素不透明 示例代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;opacity&lt;/title&gt;&lt;style&gt;*&#123; padding: 0; margin: 0;&#125;body&#123; padding: 50px; background: url(img/bg.png) 0 0 repeat;&#125;.demo&#123; padding: 25px; background: #000000; filter:Alpha(opacity=50);/* 只支持IE6、7、8、9 */ position:static; /* IE6、7、8只能设置position:static(默认属性) ，否则会导致子元素继承Alpha值 */ *zoom:1; /* 激活IE6、7的haslayout属性，让它读懂Alpha */&#125;.demo p&#123; color: #FFFFFF; position: relative;/* 设置子元素为相对定位，可让子元素不继承Alpha值，保证字体颜色不透明 */&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;p&gt;背景透明，文字不透明&lt;/p&gt;&lt;/div&gt; 本文部分文章出处：http://peunzhang.cnblogs.com/","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://summxu.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://summxu.github.io/tags/HTML/"}],"author":"BoomXu"},{"title":"如何在Windows下安装Jekyll","slug":"2017/windows-install-jekyll","date":"2017-06-13T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/windows-install-jekyll/","link":"","permalink":"https://summxu.github.io/2017/windows-install-jekyll/","excerpt":"","text":"windows环境下安装1. 安装 Ruby官网：http://rubyinstaller.org/downloads/ 测试： Ruby是否安装成功，执行命令ruby -v 注意：勾选 “Add Ruby executables to your PATH”，安装路径不能包含空格 2. 安装 DevKit官网：http://rubyinstaller.org/downloads/ 步骤： 在命令窗口下切换到安装目录，并执行以下命令 12ruby dk.rb initruby dk.rb install 测试： gem是否安装成功，执行命令gem -v 注意：Ruby与DevKit版本要对应 3. 安装 Jekyll步骤： 在命令窗口下执行以下命令 123456789101112//更换gem源gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org///查看gem源gem sources -l//更新gemgem update --system//安装jekyllgem install jekyll 4. 安装 Python 相关环境a. 安装 Python官网：http://www.python.org/download/ 测试： python是否安装成功，执行命令python -V 注意：下载Python 2安装，如果安装Python 3 可能不会正常工作。安装后添加环境变量。 b. 安装 Easy Install 提示：*需要下载ez_setup.py) 步骤： 执行cmd命令 python “D:\\software\\Jekyll\\ez_setup.py”(这里要改为你自己的目录） 测试： Easy Install 是否安装成功，执行命令easy_install –version 注意：添加 Python Scripts 路径到环境变量 c. 安装 Pygments步骤： 执行命令easy_install Pygments 5. Jekyll启动与调试步骤： 打开命令行窗口，执行以下命令 123456//创建jekyll工程目录jekyll new myblog//切换到工程目录，并开启服务cd myblogjekyll serve 测试： Jekyll是否正常开启，访问localhost:4000 最后：附件附件个自动安装脚本，双击install.bat即可：点此下载","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"初学BootStrap --Form Demo","slug":"2017/bootsrp-form-demo","date":"2017-06-11T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/bootsrp-form-demo/","link":"","permalink":"https://summxu.github.io/2017/bootsrp-form-demo/","excerpt":"","text":"根据MOOC上的教程做了一个小小的demo。也从现在开始创建一个可以直接预览的效果。 点此预览123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;表单和viewport例子&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"bootstrap.min.css\"&gt; &lt;script src=\"jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"text-center\"&gt;请注册您的账号：&lt;/p&gt; &lt;form&gt; &lt;div class=\"form-group has-error\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"请输入您的手机号码\"&gt; &lt;/div&gt; &lt;div class=\"form-group has-success\"&gt; &lt;label for=\"\"&gt;请选择您的城市：&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option value=\"\"&gt;北京&lt;/option&gt; &lt;option value=\"\"&gt;上海&lt;/option&gt; &lt;option value=\"\"&gt;济南&lt;/option&gt; &lt;option value=\"\"&gt;成都&lt;/option&gt; &lt;option value=\"\"&gt;重庆&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"button\" class=\"\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn btn-block\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-success active\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-primary\" disabled=\"disabled\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-info\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-warning\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-danger btn-sm\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-default btn-lg\" value=\"确定注册\"&gt; &lt;input type=\"button\" class=\"btn-link\" value=\"确定注册\"&gt; &lt;/div&gt; &lt;a href=\"\" class=\"btn btn-default btn-lg\"&gt;这是用a标签的按钮效果&lt;/a&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://summxu.github.io/tags/jQuery/"},{"name":"BootStrap","slug":"BootStrap","permalink":"https://summxu.github.io/tags/BootStrap/"}],"author":"BoomXu"},{"title":"通过JS代码提交连接到百度","slug":"2017/atao-up-link-baidu","date":"2017-06-10T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/atao-up-link-baidu/","link":"","permalink":"https://summxu.github.io/2017/atao-up-link-baidu/","excerpt":"","text":"为了加快百度对博客文章的收录，站长们最好提交网站文章的连接到百度，百度提供了四种方式： 主动推送(实时)百度官方说这是最好的推送方式，但是这种静态博客不支持，像PHP的博客wordprass可以只用这种方式，百度也给出了几个提交例子： initiative sitemap以站点地图的形式来提交网站，站点地图中可以填入你网站所有的连接，我认为这适用与一些比较大的网站且是第一次提交连接。 sitmao 手动提交把连接逐条填写到网站中提交，如果连接过多的情况下挺麻烦的。 manual 自动推送自动推送是百度站长平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。 aoto 其代码如下： 12345678910111213141516&lt;!-- 百度实时网页推送 --&gt; &lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https')&#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else&#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&lt;!-- 百度实时网页推送 END--&gt; 本站是采用自动提交的JavaScript代码来提交网站连接。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"HTTPS自动跳转JS代码","slug":"2017/coding-301-baidu-spider","date":"2017-06-10T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/coding-301-baidu-spider/","link":"","permalink":"https://summxu.github.io/2017/coding-301-baidu-spider/","excerpt":"","text":"前言 因为某种原因，本站的博客部署在了 Coding Pages 。其很大原因主要是为了兼顾百度的收录问题（GitHub停止了百度收录），但是却遇到了重重困难。 Coding pages开启了https https enble 如果启用了强制HTTPS访问，百度抓取就会 出现一下错误： error 上面提示异常信息：连接重定向次数超过5次的上限。这里就有两个疑问： 我是hrtps的站点，抓取的时候确实http？ 我确实做了强行301到https（刚才coding上那个选项），但是为什么说重定向超过5次？ 我感觉这次抓取的结果可以重三个方面分析： 我是hrtps的站点，抓取的时候确实http？ 首先这个原因，暂且认为百度抓取只会抓HTTP的页面并不会抓HTTPS，这个原因直接导致了抓取http出现有跳转的情况。(但是想了想可能又不是这样，百度搜索引擎是不可能连一个HTTPS都不抓的。不过从抓取结果上来看，它确实只是抓取的http) 为什么说重定向超过5次？ 有可能是因为Coding.Coding的强制跳转到HTTPS是不是就跳转了一次，还中间做了其他的页面？ 百度抓取问题。 所以说这个问题至今都很奇怪，除了百度，其他所有的搜索引擎都可以成功去抓取。 索性关掉CodingPages的301功能来用JavaScript代码试下。 代码实现检测来自百度蜘蛛并跳转12345678910111213&lt;!-- 判断百度爬虫 --&gt;&lt;script&gt; $(function()&#123; var s=document.referrer; //获取来源地址 var targetProtocol = \"https:\"; if(s.indexOf(\"baidu\")&gt;0)&#123; if (window.location.protocol != targetProtocol)&#123; window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); //跳转到HTTPs &#125; &#125; &#125;);&lt;/script&gt;&lt;!-- 判断百度爬虫END --&gt; 这段代码其实是检测百度抓取而不是其他引擎或者用户正常访问来做的跳转，其中： document.referrer //获取来源地址window.location.href //只身跳转，可传递搜索引擎权重并不会引起各种浏览器屏蔽indexOf() // 方法可返回某个指定的字符串值在字符串中首次出现的位置。 直接HTTP到https跳转123456&lt;script&gt; var targetProtocol = \"https:\"; if (window.location.protocol != targetProtocol)&#123; window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); //跳转到HTTPs &#125; &lt;/script&gt; window.location.protocol //检测当前访问是不是HTTP 结果 rithg 百度能正常抓取了，看样子是http的页面，不知道为什么，真的是好乱，而且JS跳转真的是不入直接301.唉，为了百度的索引。 更新下，已经有页面抓取到了。 end 先这么滴把。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"巧用VScode“用户代码片段”来提高效率","slug":"2017/vscode-snippet","date":"2017-06-09T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/vscode-snippet/","link":"","permalink":"https://summxu.github.io/2017/vscode-snippet/","excerpt":"","text":"前言刚学前端，用VS code写代码很爽，而且还支持git、markdown可以直接上传刚写完的博客。而用来写HTML、JavaScript也是相当方便。最近在学习bootstrap，总感觉每次引入js或者样式文件非常麻烦，但发现VS code有代码片段功能，在此记录下。 使用找到入口这里提供了两种方法： 按「Alt」键切换菜单栏，通过文件 &gt; 首选项 &gt; 用户代码片段，选择进入目的语言的代码段设置文件； 通过快捷键「Ctrl + Shift + P」打开命令窗口（all command window），输入「snippet」，通过候选栏中的选项进入目的语言的代码段设置文件。 VSCode 中 snippet 的文法12345678910111213// Place your snippets for C here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: &quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;log&quot;,, &quot;body&quot;: [ &quot;console.log(&apos;$1&apos;);&quot;, &quot;$2&quot; ], &quot;description&quot;: &quot;Log output to console&quot;&#125; snippet 各参数介绍snippet 由三部分组成： prefix：前缀，定义了 snippets 从 IntelliSense 中呼出的关键字; body： 主体，即模板的主体内容，其中每个字符串表示一行; description：说明，会在 IntelliSense 候选栏中出现。未定义的情况下直接显示对象名，上例中将会显示 Print to console。 其中 body 部分可以使用特殊结构来控制光标和要插入的文本。 支持的功能及其文法如下： Tabstops：制表符用「Tabstops」可以让编辑器的指针在 snippet 内跳转。使用 $1，$2 etc. 指定光标位置。这些数字指定了Tabstops将被访问的顺序，特别地，$0表示最终光标位置。相同序号的「Tabstops」被链接在一起，将会同步更新，比如下列用于生成头文件封装的 snippet 被替换到编辑器上时，光标就将同时出现在所有$1位置。 123&quot;#ifndef $1&quot;&quot;#define $1&quot;&quot;#end // $1&quot; Placeholders：占位符「placeholder」是带有默认值的「Tabstops」，如 ${1：foo}。「placeholder」文本将被插入「Tabstops」位置，并在跳转时被全选，以方便修改。占位符还可以嵌套，例如 : struct ${1:name_t} {\\n\\t$2\\n}; Variables：变量使用$name或${name:default}可以插入变量的值。 当未设置变量时，将插入其缺省值或空字符串。 当varibale未知（即，其名称未定义）时，将插入变量的名称，并将其转换为「placeholder」。 可以使用以下「Variable」： TM_SELECTED_TEXT：当前选定的文本或空字符串 TM_CURRENT_LINE：当前行的内容 TM_CURRENT_WORD：光标下的单词的内容或空字符串 TM_LINE_INDEX：基于零索引的行号 TM_LINE_NUMBER：基于一索引的行号 TM_FILENAME：当前文档的文件名 TM_DIRECTORY：当前文档的目录 TM_FILEPATH：当前文档的完整文件路径 引入文件的写入知道了如上支持，我就开始着手写bootstrap的引入文件了： 123456789\"Print to console\": &#123; \"prefix\": \"bootstrap\", \"body\": [ \"&lt;link rel=\\\"stylesheet\\\" href=\\\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\\\"&gt;\", \"&lt;script src=\\\"http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js\\\"&gt;&lt;/script&gt;\", \"&lt;script src=\\\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js\\\"&gt;&lt;/script&gt;\" ], \"description\": \"This Jquery &amp; BootStrap quate\" &#125; 值得注意的是：文件是以json的书写格式来的，而引号在其中要用转义字符，直接输入引号的话，是会产生错误的。 json字符转义官网也给出了 snippet 的 EBNF 范式的正则文法，注意，使用\\（反斜杠）转义$, ,, }和\\。 1234567any ::= tabstop | placeholder | variable | text tabstop ::= &apos;$&apos; int | &apos;$&#123;&apos; int &apos;&#125;&apos; placeholder ::= &apos;$&#123;&apos; int &apos;:&apos; any &apos;&#125;&apos; variable ::= &apos;$&apos; var | &apos;$&#123;&apos; var &#125;&apos; | &apos;$&#123;&apos; var &apos;:&apos; any &apos;&#125;&apos; var ::= [_a-zA-Z] [_a-zA-Z0-9]* int ::= [0-9]+ text ::= .* 而在代码里我们的引号换成了： &quot; 结果 jg1 jg2","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"},{"name":"BootStrap","slug":"BootStrap","permalink":"https://summxu.github.io/tags/BootStrap/"},{"name":"HTML","slug":"HTML","permalink":"https://summxu.github.io/tags/HTML/"}],"author":"BoomXu"},{"title":"初学BootStrap --引入模板","slug":"2017/html-jquery-bootstrap-temp","date":"2017-06-08T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/html-jquery-bootstrap-temp/","link":"","permalink":"https://summxu.github.io/2017/html-jquery-bootstrap-temp/","excerpt":"","text":"在此记录下自己一步步学习前端的过程！ 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\"&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 以上是引用JQery和BootStrap的html模板。","categories":[],"tags":[{"name":"BootStrap","slug":"BootStrap","permalink":"https://summxu.github.io/tags/BootStrap/"}],"author":"BoomXu"},{"title":"关闭Linux强行杀掉进程服务","slug":"2017/linux-oom-kill","date":"2017-06-07T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/linux-oom-kill/","link":"","permalink":"https://summxu.github.io/2017/linux-oom-kill/","excerpt":"","text":"本人搭建了个Minecraft的服务器运行在了Centos上，本身机器内存为1G，我设置的Java *Xms700m -Xmx700m *. 那么问题来了，我的世界玩着的时候经常断开，而且服务器也连接不上了？ Minecraft 仔细查看系统日志发现： kill java 竟然因为内存占用过多被系统直接Kill掉了。我们都知道，Linux系统为了保护系统运行，会把内存占用过高的程序杀掉，那么这个进程就是 OOM_killer OOM_killerOOM_killer是Linux自我保护的方式，当内存不足时不至于出现太严重问题，有点壮士断腕的意味在kernel 2.6，内存不足将唤醒oom_killer，挑出/proc//oom_score最大者并将之kill掉 为了保护重要进程不被oom-killer掉，我们可以： 1echo -17 &gt; /proc/&lt;pid&gt;/oom_adj,-17表示禁用OOM 我们也可以对把整个系统的OOM给禁用掉： 12sysctl -w vm.panic_on_oom=1 （默认为0，表示开启）sysctl -p 值得注意的是，有些时候 free -m 时还有剩余内存，但还是会触发OOM-killer，可能是因为进程占用了特殊内存地址 平时我们应该留意下新进来的进程内存使用量，免得系统重要的业务进程被无辜牵连可用 top M 查看最消耗内存的进程，但也不是进程一超过就会触发oom_killer参数/proc/sys/vm/overcommit_memory可以控制进程对内存过量使用的应对策略 123当overcommit_memory=0 允许进程轻微过量使用内存，但对于大量过载请求则不允许(默认）当overcommit_memory=1 永远允许进程overcommit当overcommit_memory=2 永远禁止overcommit OK 了，果然没在出现掉线的情况了，不过这个方式还是会存在问题，就是当内存实在是过大的时候，会破坏系统的整体稳定性，极大可能会宕机！ 22：54更新 宕机了！！！重启后发现： error 这就悲剧了！！！ 看来还是老老实实的 Java *Xms256m -Xmx256m * 这样确实不出现连接问题，但是这样会损失一点游戏的流畅性(比如在铁路上做很长距离的矿车，会卡成狗。。) 什么？？？想完美解决？ 还是 ： 给服务器加大内存把@！！@！","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://summxu.github.io/tags/Linux/"},{"name":"游戏","slug":"游戏","permalink":"https://summxu.github.io/tags/游戏/"}],"author":"BoomXu"},{"title":"精简实用的VScode前端扩展","slug":"2017/vscode-extended-html","date":"2017-06-07T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/vscode-extended-html/","link":"","permalink":"https://summxu.github.io/2017/vscode-extended-html/","excerpt":"","text":"前言vscode是一款跨平台的代码编辑器，她轻量、美观、一致、功能完整，自带完美git支持，非常适合前端同学使用。下面总结下我对于这个软件的使用技巧，希望对大家有帮助。 快捷键注意：当下列快捷键不起作用时，请考虑是否是其他软件已经占用了快捷键，如输入法、聊天软件等 vscode内置了emmet，使用tab键可快速编写html/css等，具体请查询emmet语法说明 快捷键 备注 Ctrl + N 新建文件 Ctrl + S 保存文件 Ctrl + F 在当前文件内查找 Ctrl + H 在当前文件内替换 Ctrl + Shift + F 在文件内查找 Ctrl + Shift + H 在文件内替换 Ctrl + Tab 切换文档 Ctrl + PgUp/PgDn 向前/向后切换文档 Ctrl + 1/2/3 切换分栏 Ctrl + P 转到文件 Ctrl + P 转到文件 Ctrl + G 转到行，输入行号，转到该行号处 Ctrl + 鼠标滚轮 缩放编辑器显示比例 Ctrl + F1 在浏览器中打开当前正在编辑的html文件，这个功能需要插件支持，安装插件：View In Browser F12 转到定义，可跳转到变量定义处，定义较为复杂时，会找不到 F1 打开命令输入框 Shift + Alt + F 格式化代码 Ctrl + Alt + Up/Down/Left/Right 按区域选中代码，并编辑 Alt + Up/Down 移动光标所在行或者光标选中代码的位置 Alt + Left/Right 前进或后退操作历史，这个历史不是编辑历史（Ctrl + Z/Y操作的是编辑历史），它包含如：第一步，光标在12行6列处；第二步，光标在20行10列处；第三步，打开另外一个文件。 Shift + Alt + Up/Down 复制光标所在行至上一行或下一行 Alt + 光标选中 光标多选，同时编辑 扩展/插件vscode支持扩展，官方商店里有很多扩展，网址：https://marketplace.visualstu…安装方式：点击编辑器左侧的【扩展】按钮，在搜索框中输入你想要安装的插件，点击安装即可。 推荐插件 链接 名称 备注 查看 Path Intellisense 在编辑器中输入路径时，自动补全 查看 Auto Close Tag 自动补全html标签，如输入将自动补全 查看 Auto Rename Tag 自动重命名html标签，如修改为，将自动修改结尾标签为 查看 REST Client 在编辑器中发送http请求，可直接得到结果，测试接口时很有用处，用法请看插件详情 查看 Easy LESS 自动编译less文件（文件保存后自动变为为同名.css文件），如果你只是想用less，而又不想配置grunt等工具来使用它时，请使用这个插件，他绝对是更效率的 查看 View In Browser 按Ctrl + F1在浏览器中打开正在编辑的html文件 查看 vscode-icons 为文件添加炫酷的图标，图标种类很全，包括各种配置文件、常见语言、常见js框架等，你值得拥有；安装后，需要使用管理员权限启动vscode，并打开命令输入框(F1或者Ctrl+Shift+P)执行Icons Enable 如有任何问题可以在下方留言或者给我邮件。","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"无需后台的集成式评论系统","slug":"2017/choose-Comments","date":"2017-06-01T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/choose-Comments/","link":"","permalink":"https://summxu.github.io/2017/choose-Comments/","excerpt":"","text":"然而图片和此文章没有一点毛关系，只是为了好看。 前言：作为一个博客系统，评论系统几乎是必备的。而很多静态博客像Jekyll几乎没有自己开发评论系统的可能性，所以我们就介绍下比较常用的几家评论系统，和自己去搭建评论系统。 国内评论系统 多说——-(已关闭)多说算是国内最好用的评论系统了，但是多说宣布与2017年6月1日关闭。 友言不支持HTTPS，友言在评论管理方面比较全面，允许管理员自主灵活设置匿名评论功能，并且还支持数量最多的11种建站平台安装方式，但是友言在评论方式上表现较为不足。 网易云跟帖总体而言，网易云跟贴在用户评价方面表现也较为全面，但是账号登录方式也较少，在评论管理方面最为不足。 畅言总体而言，畅言表现最为全面，且唯一支持管理员分权管理，但是畅言账号的登录方式较少，支持PC端安装的建站平台数量也较少。本站也是正在使用畅言。 国外评论系统 Disqus Disqus是国外的评论插件，自从多说关闭后也是现在很多站长都在使用的评论系统，其界面美观简单。但是，被墙了。。。 搭建自己的评论系统issoIsso是一个轻量级的类似Disqus第三方评论系统，它允许匿名评论、注册评论、回复邮件通知以及自定义外观等功能。它的接口设计和Disqus高度相似，所以要集成这个评论系统只需要在Disqus接口上改几个单词，非常简单。 Isso是基于Python写的开源软件，你可以随意修改评论框外观。 isso 我在这里说下我看到的Docker容器的ISSO的安装方法，比较简单，不用去配置复杂的python环境。 用docker你首先要安装docker环境 和 Compose 。两个工具的安装在此不多赘述。。 下载Docker镜像 在docker上有人做出来了一个docker包，直接pull下来就可以，地址在这：https://hub.docker.com/r/wonderfall/isso/ 配置ISSO 新建一个文件夹名为config，在里面新建一个配置文件isso.conf： 12345[general]dbpath = /db/comments.dbhost = https://www.BoomXu.com[server]listen = http://0.0.0.0:8080/ 下面是一个Compose配置文件：123456789101112version: &apos;2&apos;services: isso: image: wonderfall/isso environment: - GID=1000 - UID=1000 volumes: - ./config:/config - ./db:/db ports: - &quot;8080:8080&quot; 保存为docker-compose.yml然后执行：1dokcer-compose up -d 搞定之后就可以通过8080端口的接口使用Isso评论系统了。 启动后目录应该是这样的：12345678.├── config│ └── isso.conf├── db│ └── comments.db└── docker-compose.yml2 directories, 3 files 设置 Isso服务已经运行了，当然直接访问8080端口是没有什么界面的，只有一个API接口。接下来我们要在静态博客中集成这个评论系统。 如果你使用的主题是纯HTML，那么嵌入下面两句即可： 1234&lt;script data-isso=&quot;//comments.example.tld/&quot; src=&quot;//comments.example.tld/js/embed.min.js&quot;&gt;&lt;/script&gt;&lt;section id=&quot;isso-thread&quot;&gt;&lt;/section&gt; 如果你是Jade或者Ejs等模板引擎，那么复制一下Disqus的代码，替换为Isso即可，例如Jade格式。 下面是Disqus的Jade模板：1234567891011121314if theme.disqus a#comments #disqus_thread script. var disqus_shortname = &apos;#&#123;theme.disqus&#125;&apos;; var disqus_identifier = &apos;#&#123;page.path&#125;&apos;; var disqus_title = &apos;#&#123;page.title&#125;&apos;; var disqus_url = &apos;#&#123;config.url&#125;/#&#123;page.path&#125;&apos;; (function() &#123; var dsq = document.createElement(&apos;script&apos;); dsq.type = &apos;text/javascript&apos;; dsq.async = true; dsq.src = &apos;//&apos; + disqus_shortname + &apos;.disqus.com/embed.js&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(dsq); &#125;)(); script(id=&apos;dsq-count-scr&apos; src=&apos;//#&#123;theme.disqus&#125;.disqus.com/count.js&apos; async) 现在改写为Isso评论系统（类似）：12345678910111213if theme.isso a#comments .isso-thread script. var isso-path = &#123;short_name:\"#&#123;theme.isso&#125;\"&#125;; (function() &#123; var isso = document.createElement('script'); isso.type = 'text/javascript';ds.async = true; isso.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//example.com/isso/js/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); 评论计数 如何在首页中显示文章计数？ 加入下面一句到页面中： 1&lt;a href=&quot;/my-uri.html#isso-thread&quot;&gt;Comments&lt;/a&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"}],"author":"BoomXu"},{"title":"免费搭建博客Github+Jekyll","slug":"2017/how-free-blog-pages","date":"2017-05-26T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/how-free-blog-pages/","link":"","permalink":"https://summxu.github.io/2017/how-free-blog-pages/","excerpt":"","text":"这篇博客将会为大家从0开始详细的讲解下怎么利用Github Pages来免费的搭建自己的博客，如果你自己有空间或者服务器，也可以换成自己的。如果你能看下去就一定可以搭建的出来。这篇文章虽说是教程向，但是对我自己来说更是一个自己研究搭建博客的过程记录，我希望这个教程能帮助到大家更能帮助到我自己。本人是第一次写博客， 难免有些激动。如果我有什么不对的地方和一些疏忽掉的地方，还请大家到博客下面浏览，或者可以在右边的小About里点击邮件图标给我发邮件。 废话少说，就是干！不过在这之前先介绍下咱们的Leading roles: Github Git Jekyll Freenom Markdown 就是这么简单，就可以轻而易举的去完成我们的工作，下面进入正文！ 注册并使用Github对于Github这个社区我想作为一个代码交流者或许无人不知，即使现在没有加入Github，但是如果你想继续你的代码事业，注册个Github是早完的事，而且这是必须的。在这里我不不谈论这个社区的历史、作用，如果你想了解，我推荐你看本PDF，内容不多，但是很有用。（从0开始学Github）我们只说怎么使用他的Pages功能，这里是Github的注册地址。Github 注册 创建repository 进入Github后直接点开始一个项目 项目名字这么输入，前面一定是你在Github的名字（不要输入成我的啊。），Description可以输入成自己喜欢的，如：我的个人博客 😆?? 出现这个页面代表你的Github仓库已经创建成功了，这也代表这，你在Github上的工作就先告一段落了。 **这个仓库也可以当作是一个虚拟空间，你可以在创建的时候勾选上创建README就能以网页上的形式去上传、修改、下载代码。但是这不是Github的正确用法,下面才是我们的正确的用法GIT! 现在这个仓库是空的，下面我们要用GIT 的方法去里面添加文件：** 使用GitGit是个复杂的东西，他可以理解成一种多人共享去管理仓库的方法。如果你没有基础的Git知识，跟着我做也可以达到目标，但是你如果想理解什么是Git，里面的语句怎么用，可以看看我的这篇博客。 git常用操作 如果你想使用GithubPages，就必须要了解相关的Git知识.正如上面所说的，你可以看看 这本PDF","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"},{"name":"Git","slug":"Git","permalink":"https://summxu.github.io/tags/Git/"}],"author":"BoomXu"},{"title":"Jekyll文章的格式和写法","slug":"2017/Jekyll-word-wirtd","date":"2017-05-23T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/Jekyll-word-wirtd/","link":"","permalink":"https://summxu.github.io/2017/Jekyll-word-wirtd/","excerpt":"","text":"Jekyll文章Markdown语法 Jekyll文章完全使用Markdown的语法规则。Markdown 是一种「电子邮件」风格的「标记语言」。 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 Jekyll文章格式123456789101112---layout: posttitle: &quot;Jekyll文章的格式和写法&quot;subtitle: &quot;初入Jekyll,基于Markdown语法的个人博客.&quot;date: 2017-5-24author: &quot;BoomXu&quot;header-img: &quot;123123.jpg&quot;tags: - Jekyll - Markdown - 博客--- 以下是Note配置介绍 123456789101112---layout: keynotetitle: &quot;Example Post using Keynote Layout&quot;subtitle: &quot;Keynote: JavaScript Modularization Journey&quot;iframe: &quot;http://huangxuan.me/js-module-7day/&quot;date: 2015-07-09author: &quot;Hux&quot;header-img: &quot;img/post-bg-js-version.jpg&quot;tags: - 前端开发 - JavaScript--- Jekyll和Markdown的相关链接Github LessOrMore 模板 献给写作者的 Markdown 新手指南 –简书","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"为自定义的域名添加免费SSL","slug":"2017/free-cloudflare-ssl-for-github-pages","date":"2017-05-23T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/free-cloudflare-ssl-for-github-pages/","link":"","permalink":"https://summxu.github.io/2017/free-cloudflare-ssl-for-github-pages/","excerpt":"","text":"原文连接 为自定义域名的GitHub Pages添加SSL 完整方案 简单总结一下这个过程： 在 github page 的设置中填入 custom domain 去你的域名注册商更改 dns server 成 cloudflare 所提供的 在 cloudflare 设置 A record ，参照 在 cloudflare 配置 crypto ，选择 flexiable （这一步要一段时间才能起效） 在 cloudflare 配置 page rule ，一个是 always use https ，一个是 redirect http 到 https 每一步的操作可能需要 5-30 分钟才能起效 为什么使用Cloudflare提供的免费SSL收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，这是一笔不必要的开销。我只是需要看到网站地址栏有绿色的锁头，那就证明我们的网站相对安全了。 此外，使用https之后，谷歌、百度等搜索排名权值（PR等）也会有相对提升。还有其他的一些，例如Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验~~ 好了，说了那么多，直接看教程~~ 创建CloudFlare帐户，并添加网站首先你已经有自己的自定义域名的GitHub Pages ，我的 GitHub Pages cname文件写的是 yicodes.com 实现目标： 当访客输入 yicodes.com 强制跳转使用https，访问wwww 也会跳转到https://www.yicodes.com 如果你还没有Cloudflare账号，点击注册 登陆后，点击这里 增加你的域名，如下图，输入你的域名，例如 yicodes.com *并点击 *Begin Scan 注意不要写WWW前缀，大约60秒即可完成域名解析扫描。完成后点击 Continue Setup 继续下一步 你看到DNS记录（包括子域）列表之后，按照下图提示设置后，其中cname是为了重定向www准备的，点击 Continue 下一步 选择免费计划，然后下一步~ 到你域名控制面板修改cloudflare给出的域名服务器，我这里以 Godaddy 为例 注：官方说明，域名服务器修改最长需要72小时生效 ，用了两个域名测试，大约需要 5~30 分钟，看到 Status: Active 即可 设置SSL 点击 crypto 菜单 , 然后设置 Flexible SSL ，如下图 添加www重定向到https://www.yicodes.com 添加自动重定向到 SSL页面 添加SSL的教程就此完成，一般需要5~30分钟生效！！！ 如果你有疑问，欢迎到我博客留言","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://summxu.github.io/tags/技术分享/"}],"author":"BoomXu"},{"title":"如何在网页里插入全局新窗口打开超链接","slug":"2017/how-links-blank","date":"2017-05-23T16:00:00.000Z","updated":"2023-12-12T04:51:40.863Z","comments":true,"path":"2017/how-links-blank/","link":"","permalink":"https://summxu.github.io/2017/how-links-blank/","excerpt":"","text":"很多站长朋友都遇到了自己写的文章或者网站里的一些页面打开的时候都是以_myself的方式打开的，这样很多阅读者就会遇到想看着自己写的教程而又点开操链接都是直接在本页面上打开，这样我们就直接用一点小技术可以解决 JavaScript代码实现所有超链接以_blank方式打开12345678910&lt;!--把一下js代码放到页面的尾部，也就是&lt;/body&gt;标签的上面--&gt;&lt;script language=\"JavaScript\" type=\"text/javascript\"&gt; &lt;!-- var a = document.getElementsByTagName(\"A\"); for(var i = 0;i &lt; a.length;i++)&#123; a[i].target = \"_blank\"; &#125; //--&gt;&lt;/script&gt; 完全可以把以上代码粘贴到HTML的body内就可以实现全局超链接了！！😀是不是很开心！！！！Jekyll博客模板可以以下： 全局包括在首页上的所有连接，把代码复制到“_inclouds/footer.html”的末尾 文章内上的所有连接，，把代码复制到“_layouts/post.html”（根据自己的模板来，默认是post）的末尾 以上就是现所有超链接以_blank方式打开的方法，希望小伙伴们能成功 如果各位喜欢我的博客内容或者有什疑问可以在我的博客下方留言，或者给我发邮件！！ enjoy！ ###后记： 刚刚发现了点问题，我想把我的文章页面弄成_blank方式打开，但是不包括下面这个“上一篇博文”和“下一篇博文”这样，但是一但加入到最底部整个文章页面的超链接都是会以_blank的方式打开网页，这怎么办呢，其实只需仔细分析下这个JS的运行原理： 12345678&lt;script language=\"JavaScript\" type=\"text/javascript\"&gt; &lt;!-- var a = document.getElementsByTagName(\"A\"); //重要的是这一步 for(var i = 0;i &lt; a.length;i++)&#123; a[i].target = \"_blank\"; &#125; //--&gt;&lt;/script&gt; 这个 “getElementsByTagName()” 到底是什么作用呢： 如果把特殊字符串 “*” 传递给 getElementsByTagName() 方法，它将返回文档中所有元素的列表，元素排列的顺序就是它们在文档中的顺序。 也就是说这段JS是以代码以上的超链接数来计算的。这样就好办了，把程序代码段放到按钮前面，搞定！ 2017.06.02更新 几天时间内一直在弄只修改{ {–content–} }变量内的a标签的target值，后来还是通过jQuery寻找div的a标签来实现了，在这里谢谢KeJun大神 下面看看代码： 1234567&lt;script&gt;$(function()&#123; $('article').find(\"#content\").find('a').on('click',function()&#123; $(this).attr(\"target\",\"_blank\") &#125;)&#125;)&lt;/script&gt; 其中需要注意的是 jQuery的选择器，“#” 是选择ID “.”是选择class 总算是弄完了，下面开始弄自己搭建isso评论系统，还有好多事情做，这里end！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summxu.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://summxu.github.io/tags/HTML/"}],"author":"BoomXu"}]}