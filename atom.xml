<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小兵旭旭的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://summxu.github.io/"/>
  <updated>2023-08-25T10:01:39.586Z</updated>
  <id>https://summxu.github.io/</id>
  
  <author>
    <name>summxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>现代CSS解决方案：原生支持的三角函数</title>
    <link href="https://summxu.github.io/2023/%E7%8E%B0%E4%BB%A3CSS%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
    <id>https://summxu.github.io/2023/现代CSS解决方案：原生支持的三角函数/</id>
    <published>2023-08-25T06:11:48.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-三角函数语法介绍"><a href="#CSS-三角函数语法介绍" class="headerlink" title="CSS 三角函数语法介绍"></a>CSS 三角函数语法介绍</h2><p>首先看看 CSS 三角函数的使用方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置元素的宽度为 sin(30deg) 的值 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(sin(30deg) * <span class="number">100px</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 反正弦 根据弧度值返回对应的角度值 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(asin(-0.2));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置元素的高度为 cos(45deg) 的值 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>(cos(45deg) * <span class="number">100%</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置元素的透明度为 tan(60deg) 的值 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="built_in">calc</span>(tan(60deg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，使用了 calc() 函数进行了计算，然后通过 sin()、cos() 和 tan() 函数对计算结果进行了进一步的处理，从而实现了不同的效果。</p><p>三角函数在 CSS3 中仅对弧度（radian）单位进行支持。如果想要在开发中使用三角函数，可以借助转换函数 deg() 和 rad() 将角度（degree）和弧度进行转换。</p><p>CSS3 的这些函数使得开发者可以更加方便处理一些复杂的数学问题，增强了 CSS 的表现力。</p><h2 id="三角函数的运动轨迹"><a href="#三角函数的运动轨迹" class="headerlink" title="三角函数的运动轨迹"></a>三角函数的运动轨迹</h2><p>三角函数的运用，可以体现在动画当中。以正弦、余弦函数为例，代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span> --angle &#123;</span><br><span class="line">  syntax: '&lt;angle&gt;';</span><br><span class="line">  <span class="selector-tag">inherits</span>: <span class="selector-tag">false</span>;</span><br><span class="line">  <span class="selector-tag">initial-value</span>: 0<span class="selector-tag">deg</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">property</span> --dis &#123;</span><br><span class="line">  syntax: '&lt;length&gt;';</span><br><span class="line">  <span class="selector-tag">inherits</span>: <span class="selector-tag">false</span>;</span><br><span class="line">  <span class="selector-tag">initial-value</span>: 0<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-single</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation</span>: move <span class="number">5s</span> infinite ease-in-out;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(calc(var(--dis) - <span class="number">40vw</span>),</span><br><span class="line">      <span class="built_in">calc</span>(5 * sin(var(--angle)) * <span class="number">1em</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> move &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">--dis</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">--angle</span>: <span class="number">0deg</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">--dis</span>: <span class="number">80vw</span>;</span><br><span class="line">    <span class="attribute">--angle</span>: <span class="number">1080deg</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的核心在于这一段代码 <code>-- transform: translate(calc(var(--dis) - 40vw), calc(5 * sin(var(--angle)) * 1em))</code><br>内部使用了两个 CSS @property 变量：</p><ol><li>x 轴方向是 <code>0px</code> 到 <code>80vw</code> 的水平位移动画</li><li>y 轴方向是 <code>5 * sin(0deg) * 1em</code> 到 <code>5 * sin(1080deg) * 1em</code> 的竖直动画</li></ol><p>通过动画，动态的修改这两个变量的值，就可以得到一个三角函数曲线动画图形：</p><iframe src="../../html/sinAnimation.html" scrolling="no" width="100%" height="200px" frameborder="0"></iframe><h2 id="CSS-钟表"><a href="#CSS-钟表" class="headerlink" title="CSS 钟表"></a>CSS 钟表</h2><p>钟表上1-12折12个数字按照圆形等间距排布，也是CSS三角函数的典型应用。</p><p>排版定位的相关代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span> &#123;</span><br><span class="line">  <span class="attribute">--x</span>: <span class="built_in">calc</span>(var(--radius) + (<span class="built_in">var</span>(--radius) * <span class="built_in">cos</span>(var(--index) * <span class="number">30deg</span>)));</span><br><span class="line">  <span class="attribute">--y</span>: <span class="built_in">calc</span>(var(--radius) + (<span class="built_in">var</span>(--radius) * <span class="built_in">sin</span>(var(--index) * <span class="number">30deg</span>)));</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">place-content</span>: center;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>; <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">var</span>(--x);</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">var</span>(--y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(1)</span> &#123; <span class="attribute">--index</span>: <span class="number">9</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(2)</span> &#123; <span class="attribute">--index</span>: <span class="number">10</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(3)</span> &#123; <span class="attribute">--index</span>: <span class="number">11</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(4)</span> &#123; <span class="attribute">--index</span>: <span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(5)</span> &#123; <span class="attribute">--index</span>: <span class="number">1</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(6)</span> &#123; <span class="attribute">--index</span>: <span class="number">2</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(7)</span> &#123; <span class="attribute">--index</span>: <span class="number">3</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(8)</span> &#123; <span class="attribute">--index</span>: <span class="number">4</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(9)</span> &#123; <span class="attribute">--index</span>: <span class="number">5</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(10)</span> &#123; <span class="attribute">--index</span>: <span class="number">6</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(11)</span> &#123; <span class="attribute">--index</span>: <span class="number">7</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(12)</span> &#123; <span class="attribute">--index</span>: <span class="number">8</span>; &#125;</span><br></pre></td></tr></table></figure><p>实现的效果（完整的代码可以查看一下iframe的源代码信息）：</p><iframe src="../../html/cssClock.html" width="100%" height="340px" scrolling="no" frameborder="0"></iframe><h2 id="CSS-数学函数"><a href="#CSS-数学函数" class="headerlink" title="CSS 数学函数"></a>CSS 数学函数</h2><ul><li>sqrt() 求平方根</li><li>pow() 幂指数</li><li>exp() 自然常数e为底的指数函数</li><li>log() 对数函数</li><li>abs() 绝对值</li><li>round() 四舍五入</li><li>sign() 正负零判断</li><li>….</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSS 原生支持的三角函数，给 CSS 打开了更多的可能性，这也导致 CSS 的复杂度也是愈来愈高，CSS 已经不再是非常纯粹的负责样式了，很多时候，很多计算也可以直接在 CSS 当中完成。至于好坏，或许已经成了一个哲学问题。</p><p>记录两个css项目，最后一个相当炸裂：</p><p><a href="https://css-doodle.com/" target="_blank" rel="noopener">css-doodle</a></p><p><a href="https://keithclark.co.uk/labs/css-fps/" target="_blank" rel="noopener">css-fps-demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS-三角函数语法介绍&quot;&gt;&lt;a href=&quot;#CSS-三角函数语法介绍&quot; class=&quot;headerlink&quot; title=&quot;CSS 三角函数语法介绍&quot;&gt;&lt;/a&gt;CSS 三角函数语法介绍&lt;/h2&gt;&lt;p&gt;首先看看 CSS 三角函数的使用方式：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Pinia使用和源码解析</title>
    <link href="https://summxu.github.io/2023/Pinia%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://summxu.github.io/2023/Pinia使用和源码解析/</id>
    <published>2023-06-26T01:36:37.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建pinia"><a href="#创建pinia" class="headerlink" title="创建pinia"></a>创建pinia</h2><p>基本使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pinia = createPinia()</span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">app.use(pinia)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">//vue2 使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia, PiniaVuePlugin &#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line">Vue.use(PiniaVuePlugin)</span><br><span class="line"><span class="keyword">const</span> pinia = createPinia()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>, </span><br><span class="line">  pinia,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="createPinia"><a href="#createPinia" class="headerlink" title="createPinia"></a>createPinia</h2><ul><li>将pinia绑定到实例上</li><li>创建一个scope用来保存之后创建的每一个store的state，也可以直接通过pinia.state.value[storeId]直接设置state</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ceatePinia.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPinia</span>(<span class="params"></span>): <span class="title">Pinia</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建个scope effct来单独管理state</span></span><br><span class="line">  <span class="keyword">const</span> scope = effectScope(<span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 通过pinia.state.value[storeId]会保存之后创建的store的state</span></span><br><span class="line">  <span class="keyword">const</span> state = scope.run&lt;Ref&lt;Record&lt;<span class="built_in">string</span>, StateTree&gt;&gt;&gt;<span class="function">(<span class="params">(<span class="params"></span>) =&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    ref&lt;Record&lt;<span class="built_in">string</span>, StateTree&gt;&gt;(<span class="params">&#123;&#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)!</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  // 插件相关</span></span><br><span class="line"><span class="function">  <span class="params">let</span> _<span class="params">p</span>: <span class="params">Pinia</span>['_<span class="params">p</span>'] = []</span></span><br><span class="line"><span class="function">  // <span class="params">plugins</span> <span class="params">added</span> <span class="params">before</span> <span class="params">calling</span> <span class="params">app</span>.<span class="params">use</span>(<span class="params">pinia</span>)</span></span><br><span class="line"><span class="function">  <span class="params">let</span> <span class="params">toBeInstalled</span>: <span class="params">PiniaPlugin</span>[] = []</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  // <span class="params">markRaw</span>标记<span class="params">pinia</span>不可被代理,避免存在用户将其响应式化影响性能的情况</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">pinia</span>: <span class="params">Pinia</span> = <span class="params">markRaw</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    install(<span class="params">app: App</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 设置当前活跃的pinia，方便其他地方获取</span></span></span></span><br><span class="line"><span class="function"><span class="params">      setActivePinia(<span class="params">pinia</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span> (<span class="params">!isVue2</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        pinia._a = app</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 内部通过inject获取pinia,因为piniaSymbol没有导出，所以开发者无法通过inject获取pinia</span></span></span></span><br><span class="line"><span class="function"><span class="params">        app.provide(<span class="params">piniaSymbol, pinia</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 通过app.config.globalProperties将pinia挂载到组件实例上</span></span></span></span><br><span class="line"><span class="function"><span class="params">        app.config.globalProperties.$pinia = pinia</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (<span class="params">USE_DEVTOOLS</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">          registerPiniaDevtools(<span class="params">app, pinia</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        toBeInstalled.forEach(<span class="params">(<span class="params">plugin</span>) =&gt; _p.push(<span class="params">plugin</span>)</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">        toBeInstalled = []</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// pinia插件相关，暂不分析</span></span></span></span><br><span class="line"><span class="function"><span class="params">    use(<span class="params">plugin</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span> (<span class="params">!<span class="keyword">this</span>._a &amp;&amp; !isVue2</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        toBeInstalled.push(<span class="params">plugin</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        _p.push(<span class="params">plugin</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">return</span> <span class="keyword">this</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    _p,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// it's actually undefined here</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// @ts-expect-error</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _a: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    _e: scope,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 每个创建的store都会放在这个Map里</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _s: <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, StoreGeneric&gt;(<span class="params"></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    state,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  //...</span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">pinia</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="设置、获取pinia"><a href="#设置、获取pinia" class="headerlink" title="设置、获取pinia"></a>设置、获取pinia</h2><ul><li>pinia会被保存到一个全局变量上，内部可以通过setActivePinia、getActivePinia快速获取到pinia，然后使用上一步挂在pinia上的属性或方法</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rootStore.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> activePinia: Pinia | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setActivePinia = <span class="function">(<span class="params">pinia: Pinia | <span class="literal">undefined</span></span>) =&gt;</span></span><br><span class="line">  (activePinia = pinia)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果在vue组件中，通过inject获取（在createPinia中导出）、否则直接取全局变量 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getActivePinia = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  (getCurrentInstance() &amp;&amp; inject(piniaSymbol)) || activePinia</span><br></pre></td></tr></table></figure><h2 id="兼容vue2"><a href="#兼容vue2" class="headerlink" title="兼容vue2"></a>兼容vue2</h2><ul><li>看过vuex的这段应该很熟悉</li><li>通过Object.defineProperty仿造了个Provide功能</li><li>通过mixins将pinia注入到每一个组件中</li></ul><p>PiniaVuePlugin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue2-plugin.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PiniaVuePlugin: Plugin = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  _Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="keyword">if</span> (options.pinia) &#123;</span><br><span class="line">      <span class="comment">// 获取注册到根组件上的pinia</span></span><br><span class="line">        <span class="keyword">const</span> pinia = options.pinia <span class="keyword">as</span> Pinia</span><br><span class="line">        <span class="comment">// 通过Object.defineProperty实现的hack版provid、inject...</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)._provided) &#123;</span><br><span class="line">          <span class="keyword">const</span> provideCache = &#123;&#125;</span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'_provided'</span>, &#123;</span><br><span class="line">            <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> provideCache,</span><br><span class="line">            <span class="keyword">set</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">Object</span>.assign(provideCache, v),</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        ;(<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)._provided[piniaSymbol <span class="keyword">as</span> <span class="built_in">any</span>] = pinia</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.$pinia) &#123;</span><br><span class="line">          <span class="keyword">this</span>.$pinia = pinia</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinia._a = <span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">        <span class="keyword">if</span> (IS_CLIENT) &#123;</span><br><span class="line">          <span class="comment">// this allows calling useStore() outside of a component setup after</span></span><br><span class="line">          <span class="comment">// installing pinia's plugin</span></span><br><span class="line">          setActivePinia(pinia)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (USE_DEVTOOLS) &#123;</span><br><span class="line">          registerPiniaDevtools(pinia._a, pinia)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.$pinia &amp;&amp; options.parent &amp;&amp; options.parent.$pinia) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$pinia = options.parent.$pinia</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._pStores</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h2><p>创建store的三种方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUserStore = defineStore(<span class="string">'counter'</span>, &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> useUserStore = defineStore(&#123;</span><br><span class="line">  id: <span class="string">'counter'</span>,</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> useUserStore = defineStore(<span class="string">'counter'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count.value++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="defineStore"><a href="#defineStore" class="headerlink" title="defineStore"></a>defineStore</h2><ul><li>主要根据defineStore的不同方式选择调用函数式createSetupStore还是选项式createOptionsStore</li><li>创建好的store会根据defineStore时传入的id，挂载到pinia._s这个map上</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// <span class="doctag">TODO:</span> add proper types from above</span></span></span></span><br><span class="line"><span class="function"><span class="params">  idOrOptions: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup?: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  setupOptions?: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">StoreDefinition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">let</span> options</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> isSetupStore = <span class="keyword">typeof</span> setup === <span class="string">'function'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 抹平不同格式参数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> idOrOptions === <span class="string">'string'</span>) &#123;</span><br><span class="line">    id = idOrOptions</span><br><span class="line">    options = isSetupStore ? setupOptions : setup</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    options = idOrOptions</span><br><span class="line">    id = idOrOptions.id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终交给开发者获取store的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">useStore</span>(<span class="params">pinia?: Pinia | <span class="literal">null</span>, hot?: StoreGeneric</span>): <span class="title">StoreGeneric</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> currentInstance = getCurrentInstance()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果存在currentInstance说明在vue组件中，通过inject获取到pinia</span></span><br><span class="line">    pinia =</span><br><span class="line">      (__TEST__ &amp;&amp; activePinia &amp;&amp; activePinia._testing ? <span class="literal">null</span> : pinia) ||</span><br><span class="line">      (currentInstance &amp;&amp; inject(piniaSymbol, <span class="literal">null</span>))</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//设置当前活跃的pinia对象，如果存在多个pinia对象，方便快速获取当前pinia对象</span></span><br><span class="line">    <span class="keyword">if</span> (pinia) setActivePinia(pinia)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !activePinia) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\n`</span> +</span><br><span class="line">          <span class="string">`\tconst pinia = createPinia()\n`</span> +</span><br><span class="line">          <span class="string">`\tapp.use(pinia)\n`</span> +</span><br><span class="line">          <span class="string">`This will fail in production.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从rootStore文件中取的全局变量</span></span><br><span class="line">    pinia = activePinia!</span><br><span class="line">    <span class="comment">// 如果没有创建过id对应的store,则会调用createSetupStore或createOptionsStore进行创建</span></span><br><span class="line">    <span class="keyword">if</span> (!pinia._s.has(id)) &#123;</span><br><span class="line">      <span class="comment">// 区分第二个参数是函数还是options对象</span></span><br><span class="line">      <span class="keyword">if</span> (isSetupStore) &#123;</span><br><span class="line">        createSetupStore(id, setup, options, pinia)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createOptionsStore(id, options <span class="keyword">as</span> <span class="built_in">any</span>, pinia)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error: not the right inferred type</span></span><br><span class="line">        useStore._pinia = pinia</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取上面创建好的store，pinia._s是一个Map结构</span></span><br><span class="line">    <span class="keyword">const</span> store: StoreGeneric = pinia._s.get(id)!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 热更新相关,重新创建更新store</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; hot) &#123;</span><br><span class="line">      <span class="keyword">const</span> hotId = <span class="string">'__hot:'</span> + id</span><br><span class="line">      <span class="keyword">const</span> newStore = isSetupStore</span><br><span class="line">        ? createSetupStore(hotId, setup, options, pinia, <span class="literal">true</span>)</span><br><span class="line">        : createOptionsStore(hotId, assign(&#123;&#125;, options) <span class="keyword">as</span> <span class="built_in">any</span>, pinia, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">      hot._hotUpdate(newStore)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// cleanup the state properties and the store from the cache</span></span><br><span class="line">      <span class="keyword">delete</span> pinia.state.value[hotId]</span><br><span class="line">      pinia._s.delete(hotId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往当前组件实例上缓存store，主要是给devtools使用</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      IS_CLIENT &amp;&amp;</span><br><span class="line">      currentInstance &amp;&amp;</span><br><span class="line">      currentInstance.proxy &amp;&amp;</span><br><span class="line">      <span class="comment">// avoid adding stores that are just built for hot module replacement</span></span><br><span class="line">      !hot</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> vm = currentInstance.proxy</span><br><span class="line">      <span class="keyword">const</span> cache = <span class="string">'_pStores'</span> <span class="keyword">in</span> vm ? vm._pStores! : (vm._pStores = &#123;&#125;)</span><br><span class="line">      cache[id] = store</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StoreGeneric cannot be casted towards Store</span></span><br><span class="line">    <span class="keyword">return</span> store <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useStore.$id = id</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createSetupStore"><a href="#createSetupStore" class="headerlink" title="createSetupStore"></a>createSetupStore</h2><p>如果defineStore传入的是一个setup函数，则会调用此方法创建store</p><ul><li><h3 id="响应式处理store"><a href="#响应式处理store" class="headerlink" title="响应式处理store"></a>响应式处理store</h3><ul><li>store -&gt; reactive(store)</li><li>pinia.state.value[storeId]初始化，state会往pinia上存一份和在store上存一份</li><li>将store注册到pinia._s这个Map上</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> scope!: EffectScope  <span class="comment">//为setup函数返回的内容单独建立一个scope</span></span><br><span class="line"><span class="keyword">if</span> (__DEV__ &amp;&amp; !pinia._e.active) &#123; <span class="comment">//pinia._e为创建pinia时建立的scope</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Pinia destroyed'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt; | <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 如果pinia.state.value[storeId]未初始化，进行初始化</span></span><br><span class="line"><span class="keyword">if</span> (!isOptionsStore &amp;&amp; !initialState &amp;&amp; (!__DEV__ || !hot)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">    <span class="keyword">set</span>(pinia.state.value, $id, &#123;&#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pinia.state.value[$id] = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露的store内容</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"> _p: pinia,</span><br><span class="line"> <span class="comment">// _s: scope,</span></span><br><span class="line"> $id,</span><br><span class="line"> <span class="comment">// 调用$onAction会将回调加入到actionSubscriptions中,wrapAction内会触发回调</span></span><br><span class="line"> $onAction: addSubscription.bind(<span class="literal">null</span>, actionSubscriptions),</span><br><span class="line"> $patch,</span><br><span class="line"> $reset,</span><br><span class="line"> $subscribe(callback, options = &#123;&#125;) &#123;</span><br><span class="line">   <span class="keyword">const</span> removeSubscription = addSubscription(</span><br><span class="line">     subscriptions,</span><br><span class="line">     callback,</span><br><span class="line">     options.detached,</span><br><span class="line">     () =&gt; stopWatcher()</span><br><span class="line">   )</span><br><span class="line">   <span class="comment">// 监听state直接修改</span></span><br><span class="line">   <span class="keyword">const</span> stopWatcher = scope.run(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">     watch(</span><br><span class="line">       () =&gt; pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;,</span><br><span class="line">       (state) =&gt; &#123;</span><br><span class="line">         <span class="comment">// flush默认为'pre',而在调用$patch时isListening会被设置为false,所以不会触发$patch修改state的监听回调</span></span><br><span class="line">         <span class="keyword">if</span> (options.flush === <span class="string">'sync'</span> ? isSyncListening : isListening) &#123;</span><br><span class="line">           callback(</span><br><span class="line">             &#123;</span><br><span class="line">               storeId: $id,</span><br><span class="line">               <span class="keyword">type</span>: MutationType.direct,</span><br><span class="line">               events: debuggerEvents <span class="keyword">as</span> DebuggerEvent,</span><br><span class="line">             &#125;,</span><br><span class="line">             state</span><br><span class="line">           )</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       assign(&#123;&#125;, $subscribeOptions, options)</span><br><span class="line">     )</span><br><span class="line">   )!</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> removeSubscription</span><br><span class="line"> &#125;,</span><br><span class="line"> $dispose,</span><br><span class="line">&#125; <span class="keyword">as</span> _StoreWithState&lt;Id, S, G, A&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的store是个reactive对象</span></span><br><span class="line"><span class="keyword">const</span> store: Store&lt;Id, S, G, A&gt; = reactive(</span><br><span class="line">  __DEV__ || USE_DEVTOOLS</span><br><span class="line">    ? assign(</span><br><span class="line">        &#123;</span><br><span class="line">          _hmrPayload,</span><br><span class="line">          _customProperties: markRaw(<span class="keyword">new</span> Set&lt;<span class="built_in">string</span>&gt;()), <span class="comment">// devtools custom properties</span></span><br><span class="line">        &#125;,</span><br><span class="line">        partialStore</span><br><span class="line">        <span class="comment">// must be added later</span></span><br><span class="line">        <span class="comment">// setupStore</span></span><br><span class="line">      )</span><br><span class="line">    : partialStore</span><br><span class="line">) <span class="keyword">as</span> unknown <span class="keyword">as</span> Store&lt;Id, S, G, A&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将store注册到pinia上</span></span><br><span class="line">pinia._s.set($id, store)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="处理setup返回的内容"><a href="#处理setup返回的内容" class="headerlink" title="处理setup返回的内容"></a>处理setup返回的内容</h3></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"> <span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   scope = effectScope()</span><br><span class="line">   <span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line"> &#125;)!</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="同步setup返回内容和pinia-state"><a href="#同步setup返回内容和pinia-state" class="headerlink" title="同步setup返回内容和pinia.state"></a>同步setup返回内容和pinia.state</h3><ul><li>因为state会在store上存一份，也会在pinia.state.value[storeId]上存一份，所以为了保证两边都是同一个代理对象，需要进行同步</li><li>使用者可以直接通过pinia.state.value设置store内容，所以直接设置的内容也需要同步</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"><span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  scope = effectScope()</span><br><span class="line">  <span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line">&#125;)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> setupStore) &#123;</span><br><span class="line"> <span class="keyword">const</span> prop = setupStore[key]</span><br><span class="line"> <span class="comment">// 只处理ref、reactive对象，computed等不处理</span></span><br><span class="line"> <span class="keyword">if</span> ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123;</span><br><span class="line">   <span class="comment">// mark it as a piece of state to be serialized</span></span><br><span class="line">   <span class="keyword">if</span> (__DEV__ &amp;&amp; hot) &#123;</span><br><span class="line">     <span class="comment">// 热更新相关，忽略</span></span><br><span class="line">     <span class="keyword">set</span>(hotState.value, key, toRef(setupStore <span class="keyword">as</span> <span class="built_in">any</span>, key))</span><br><span class="line">     <span class="comment">// option结构已经在createOptionsStore将其加入pinia</span></span><br><span class="line">     </span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isOptionsStore) &#123;<span class="comment">// 同步pinia.state -&gt; store</span></span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 将用户可能直接调用pinia.state.value[$id]设置的ref、reactive对象设置到setup返回的结果上,让二者的响应式都代理一个对象</span></span><br><span class="line">     <span class="comment">// 使得store、pinia能同步更改</span></span><br><span class="line">     <span class="keyword">if</span> (initialState &amp;&amp; shouldHydrate(prop)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (isRef(prop)) &#123;</span><br><span class="line">         prop.value = initialState[key]</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// probably a reactive object, lets recursively assign</span></span><br><span class="line">         <span class="comment">// 同步其他类型</span></span><br><span class="line">         mergeReactiveObjects(prop, initialState[key])</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// transfer the ref to the pinia state to keep everything in sync</span></span><br><span class="line">     <span class="comment">// 将setup返回的ref、reactive对象同步到pinia.state上，使得store、pinia能同步更改</span></span><br><span class="line">     <span class="keyword">if</span> (isVue2) &#123; <span class="comment">//同步 store -&gt; pinia.state</span></span><br><span class="line">       <span class="keyword">set</span>(pinia.state.value[$id], key, prop)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       pinia.state.value[$id][key] = prop</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeReactiveObjects</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">T</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt; | <span class="title">Map</span>&lt;<span class="title">unknown</span>, <span class="title">unknown</span>&gt; | <span class="title">Set</span>&lt;<span class="title">unknown</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params">target: T, patchToApply: _DeepPartial&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 合并Map类型</span></span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Map &amp;&amp; patchToApply <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    patchToApply.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> target.set(key, value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并Set类型</span></span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Set &amp;&amp; patchToApply <span class="keyword">instanceof</span> Set) &#123;</span><br><span class="line">    patchToApply.forEach(target.add, target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> patchToApply) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!patchToApply.hasOwnProperty(key)) <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">const</span> subPatch = patchToApply[key]</span><br><span class="line">    <span class="keyword">const</span> targetValue = target[key]</span><br><span class="line">    <span class="comment">// 只有普通对象才会进入递归</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isPlainObject(targetValue) &amp;&amp;</span><br><span class="line">      isPlainObject(subPatch) &amp;&amp;</span><br><span class="line">      target.hasOwnProperty(key) &amp;&amp;</span><br><span class="line">      !isRef(subPatch) &amp;&amp;</span><br><span class="line">      !isReactive(subPatch)</span><br><span class="line">    ) &#123;</span><br><span class="line">      target[key] = mergeReactiveObjects(targetValue, subPatch)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = subPatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="处理action"><a href="#处理action" class="headerlink" title="处理action"></a>处理action</h3><ul><li>将action替换成wrapAction，wrapAction添加了订阅发布相关的功能</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"><span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  scope = effectScope()</span><br><span class="line">  <span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line">&#125;)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> setupStore) &#123;</span><br><span class="line"> <span class="keyword">const</span> prop = setupStore[key]</span><br><span class="line"> <span class="comment">// 只处理ref、reactive对象，computed等不处理</span></span><br><span class="line"> <span class="keyword">if</span> ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> prop === <span class="string">'function'</span>) &#123; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 将setup中的方法替换成wrapAction包装的方法，wrapAction在订阅发布章节解析</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">const</span> actionValue = __DEV__ &amp;&amp; hot ? prop : wrapAction(key, prop)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">        <span class="keyword">set</span>(setupStore, key, actionValue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error</span></span><br><span class="line">        setupStore[key] = actionValue</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        _hmrPayload.actions[key] = prop</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// list actions so they can be used in plugins</span></span><br><span class="line">      <span class="comment">// @ts-expect-error</span></span><br><span class="line">      optionsForPlugin.actions[key] = prop</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="处理store合并setup"><a href="#处理store合并setup" class="headerlink" title="处理store合并setup"></a>处理store合并setup</h3></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 对外暴露的store API</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store: Store&lt;Id, S, G, A&gt; = reactive(</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">partialStore</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"><span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">scope = effectScope()</span><br><span class="line"><span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line">&#125;)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> setupStore) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将最同步后的结果，合并进store上</span></span><br><span class="line"> <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">   <span class="built_in">Object</span>.keys(setupStore).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">set</span>(store, key, setupStore[key])</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 将store的reactive对象、原始对象都进行合并</span></span><br><span class="line">   assign(store, setupStore)</span><br><span class="line">   assign(toRaw(store), setupStore)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createOptionsStore"><a href="#createOptionsStore" class="headerlink" title="createOptionsStore"></a>createOptionsStore</h2><p>当传入的是option配置时，则会调用此方法创建store</p><ul><li>createSetupStore内部会将option转换成setup方法，然后实际调用createSetupStore进行创建</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createOptionsStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">_GettersTree</span>&lt;<span class="title">S</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: DefineStoreOptions&lt;Id, S, G, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; state, actions, getters &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> initialState: StateTree | <span class="literal">undefined</span> = pinia.state.value[id]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> store: Store&lt;Id, S, G, A&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将options转化成setup函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化pinia.state</span></span><br><span class="line">    <span class="keyword">if</span> (!initialState &amp;&amp; (!__DEV__ || !hot)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">        <span class="keyword">set</span>(pinia.state.value, id, state ? state() : &#123;&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pinia.state.value[id] = state ? state() : &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将pinia.state全部转换成ref，和setup中返回ref效果一致</span></span><br><span class="line">    <span class="keyword">const</span> localState =</span><br><span class="line">      __DEV__ &amp;&amp; hot</span><br><span class="line">        ? <span class="comment">// use ref() to unwrap refs inside state <span class="doctag">TODO:</span> check if this is still necessary</span></span><br><span class="line">          toRefs(ref(state ? state() : &#123;&#125;).value)</span><br><span class="line">        : toRefs(pinia.state.value[id])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终options store返回的内容格式和setup store返回的内容格式一致</span></span><br><span class="line">    <span class="keyword">return</span> assign(</span><br><span class="line">      localState,</span><br><span class="line">      actions,</span><br><span class="line">      <span class="comment">// 将 getter 转换成 computed</span></span><br><span class="line">      <span class="built_in">Object</span>.keys(getters || &#123;&#125;).reduce(<span class="function">(<span class="params">computedGetters, name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; name <span class="keyword">in</span> localState) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(</span><br><span class="line">            <span class="string">`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "<span class="subst">$&#123;name&#125;</span>" in store "<span class="subst">$&#123;id&#125;</span>".`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// getter函数不可代理，及不对computed做额外处理，和setup中一致</span></span><br><span class="line">        computedGetters[name] = markRaw(</span><br><span class="line">          computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setActivePinia(pinia)</span><br><span class="line">            <span class="comment">// it was created just before</span></span><br><span class="line">            <span class="keyword">const</span> store = pinia._s.get(id)!</span><br><span class="line"></span><br><span class="line">            <span class="comment">// allow cross using stores</span></span><br><span class="line">            <span class="keyword">if</span> (isVue2 &amp;&amp; !store._r) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// @ts-expect-error</span></span><br><span class="line">            <span class="comment">// return getters![name].call(context, context)</span></span><br><span class="line">            <span class="keyword">return</span> getters![name].call(store, store)</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> computedGetters</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> Record&lt;<span class="built_in">string</span>, ComputedRef&gt;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// option选项注册的pinia会被转换成setup函数形式</span></span><br><span class="line">  store = createSetupStore(id, setup, options, pinia, hot, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  store.$reset = <span class="function"><span class="keyword">function</span> <span class="title">$reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newState = state ? state() : &#123;&#125;</span><br><span class="line">    <span class="comment">// we use a patch to group all changes into one single subscription</span></span><br><span class="line">    <span class="keyword">this</span>.$patch(<span class="function">(<span class="params">$state</span>) =&gt;</span> &#123;</span><br><span class="line">      assign($state, newState)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> store <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h2><p>pinia能够对修改state、action进行监听，内部通过发布订阅模式、watch API实现</p><ul><li><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><ul><li>将存储订阅器的功能和整个设计解藕，交给外部来传入，好处是能够处理不同类型的发布订阅</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscriptions.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addSubscription</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">_Method</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subscriptions: T[], <span class="comment">//外部传入存储器</span></span></span></span><br><span class="line"><span class="function"><span class="params">  callback: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  detached?: <span class="built_in">boolean</span>, <span class="comment">// 是否在组件卸载时清除订阅</span></span></span></span><br><span class="line"><span class="function"><span class="params">  onCleanup: () =&gt; <span class="built_in">void</span> = noop</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  subscriptions.push(callback)</span><br><span class="line">  <span class="comment">// 清除订阅</span></span><br><span class="line">  <span class="keyword">const</span> removeSubscription = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> idx = subscriptions.indexOf(callback)</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      subscriptions.splice(idx, <span class="number">1</span>)</span><br><span class="line">      onCleanup()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没传detached,则会自动在组件卸载时清除订阅</span></span><br><span class="line">  <span class="keyword">if</span> (!detached &amp;&amp; getCurrentScope()) &#123;</span><br><span class="line">    onScopeDispose(removeSubscription)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> removeSubscription</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">triggerSubscriptions</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">_Method</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subscriptions: T[],</span></span></span><br><span class="line"><span class="function"><span class="params">  ...args: Parameters&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  subscriptions.slice().forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    callback(...args)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="监听action"><a href="#监听action" class="headerlink" title="监听action"></a>监听action</h2></li></ul><p>基本使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unsubscribe = someStore.$onAction(</span><br><span class="line">  (&#123;</span><br><span class="line">    name, <span class="comment">// action 名称</span></span><br><span class="line">    store, <span class="comment">// store 实例，类似 `someStore`</span></span><br><span class="line">    args, <span class="comment">// 传递给 action 的参数数组</span></span><br><span class="line">    after, <span class="comment">// 在 action 返回或解决后的钩子</span></span><br><span class="line">    onError, <span class="comment">// action 抛出或拒绝的钩子</span></span><br><span class="line">  &#125;) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这将在执行 "store "的 action 之前触发。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`xx`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这将在 action 成功并完全运行后触发。它等待着任何返回的 promise</span></span><br><span class="line">    after(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Finished "<span class="subst">$&#123;name&#125;</span>" after <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="built_in">Date</span>.now() - startTime</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>ms.\nResult: <span class="subst">$&#123;result&#125;</span>.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 action 抛出或返回一个拒绝的 promise，这将触发</span></span><br><span class="line">    onError(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(</span><br><span class="line">        <span class="string">`Failed "<span class="subst">$&#123;name&#125;</span>" after <span class="subst">$&#123;<span class="built_in">Date</span>.now() - startTime&#125;</span>ms.\nError: <span class="subst">$&#123;error&#125;</span>.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动删除监听器</span></span><br><span class="line">unsubscribe()</span><br></pre></td></tr></table></figure><h3 id="通过-onAction添加订阅"><a href="#通过-onAction添加订阅" class="headerlink" title="通过$onAction添加订阅"></a>通过$onAction添加订阅</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 对外暴露的store内容</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"> _p: pinia,</span><br><span class="line"> <span class="comment">// _s: scope,</span></span><br><span class="line"> $id,</span><br><span class="line"> <span class="comment">// 调用$onAction会将回调加入到actionSubscriptions中,调用wrapAction内会触发回调</span></span><br><span class="line"> $onAction: addSubscription.bind(<span class="literal">null</span>, actionSubscriptions),</span><br><span class="line"> $patch,</span><br><span class="line"> $reset,</span><br><span class="line"> $subscribe(callback, options = &#123;&#125;) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;,</span><br><span class="line"> $dispose,</span><br><span class="line">&#125; <span class="keyword">as</span> _StoreWithState&lt;Id, S, G, A&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过wrapAction进行发布"><a href="#通过wrapAction进行发布" class="headerlink" title="通过wrapAction进行发布"></a>通过wrapAction进行发布</h3><ul><li>setup、option中的方法，会被替换成wrapAction</li><li>当调用wrapAction时，会触发actionSubscriptions、afterCallbackList或onErrorCallbackList中的回调</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal state</span></span><br><span class="line"><span class="keyword">let</span> isListening: <span class="built_in">boolean</span> <span class="comment">// 异步监听</span></span><br><span class="line"><span class="keyword">let</span> isSyncListening: <span class="built_in">boolean</span> <span class="comment">// 同步监听</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subscriptions: SubscriptionCallback&lt;S&gt;[] = markRaw([])  <span class="comment">// 监听state的订阅集合</span></span><br><span class="line"><span class="keyword">let</span> actionSubscriptions: StoreOnActionListener&lt;Id, S, G, A&gt;[] = markRaw([]) <span class="comment">// 监听action的订阅集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装action调用，追加发布订阅功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapAction</span>(<span class="params">name: <span class="built_in">string</span>, action: _Method</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 根据闭包上下文，调用时设置当前活跃的pinia</span></span><br><span class="line">   setActivePinia(pinia)</span><br><span class="line">   <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">   <span class="comment">// 调用action后回调集合</span></span><br><span class="line">   <span class="keyword">const</span> afterCallbackList: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">resolvedReturn: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>&gt; = []</span><br><span class="line">   <span class="keyword">const</span> onErrorCallbackList: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">error: unknown</span>) =&gt;</span> unknown&gt; = []</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">callback: _ArrayType&lt;<span class="keyword">typeof</span> afterCallbackList&gt;</span>) </span>&#123;</span><br><span class="line">     afterCallbackList.push(callback)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">callback: _ArrayType&lt;<span class="keyword">typeof</span> onErrorCallbackList&gt;</span>) </span>&#123;</span><br><span class="line">     onErrorCallbackList.push(callback)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 触发action时的回调，同时将after等方法通过参数传入</span></span><br><span class="line">   triggerSubscriptions(actionSubscriptions, &#123;</span><br><span class="line">     args,</span><br><span class="line">     name,</span><br><span class="line">     store,</span><br><span class="line">     after,</span><br><span class="line">     onError,</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> ret: <span class="built_in">any</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ret = action.apply(<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.$id === $id ? <span class="keyword">this</span> : store, args)</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     <span class="comment">// 处理同步错误</span></span><br><span class="line">     triggerSubscriptions(onErrorCallbackList, error)</span><br><span class="line">     <span class="keyword">throw</span> error</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果是异步方法</span></span><br><span class="line">   <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ret</span><br><span class="line">       .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">// 获取到action调用结果后触发</span></span><br><span class="line">         triggerSubscriptions(afterCallbackList, value)</span><br><span class="line">         <span class="keyword">return</span> value</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">         triggerSubscriptions(onErrorCallbackList, error)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// allow the afterCallback to override the return value</span></span><br><span class="line">   triggerSubscriptions(afterCallbackList, ret)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听修改state"><a href="#监听修改state" class="headerlink" title="监听修改state"></a>监听修改state</h2><p>修改state有两种方式，一种通过store.state直接修改然后通过watch API进行监听，另一种通过$patch进行<a href="https://so.csdn.net/so/search?q=%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9&spm=1001.2101.3001.7020" target="_blank" rel="noopener">批量修改</a>，通过$patch进行批量修改时，为了只触发一次回调需要手动触发</p><ul><li>基本使用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cartStore.$subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// import &#123; MutationType &#125; from 'pinia'</span></span><br><span class="line">  mutation.type <span class="comment">// 'direct' | 'patch object' | 'patch function'</span></span><br><span class="line">  <span class="comment">// 和 cartStore.$id 一样</span></span><br><span class="line">  mutation.storeId <span class="comment">// 'cart'</span></span><br><span class="line">  <span class="comment">// 只有 mutation.type === 'patch object'的情况下才可用</span></span><br><span class="line">  mutation.payload <span class="comment">// 传递给 cartStore.$patch() 的补丁对象。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><h3 id="直接修改state"><a href="#直接修改state" class="headerlink" title="直接修改state"></a>直接修改state</h3></li></ul><p>$subscribe监听state直接修改，内部通过watch API实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// internal state</span></span><br><span class="line"><span class="keyword">let</span> isListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"><span class="keyword">let</span> isSyncListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 对外暴露的store内容</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"> _p: pinia,</span><br><span class="line"> <span class="comment">// _s: scope,</span></span><br><span class="line"> $id,</span><br><span class="line"> <span class="comment">// 调用$onAction会将回调加入到actionSubscriptions中,调用wrapAction内会触发回调</span></span><br><span class="line"> $onAction: addSubscription.bind(<span class="literal">null</span>, actionSubscriptions),</span><br><span class="line"> $patch,</span><br><span class="line"> $reset,</span><br><span class="line"> $subscribe(callback, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 使用者调用后将订阅回调添加进subscriptions</span></span><br><span class="line"><span class="keyword">const</span> removeSubscription = addSubscription(</span><br><span class="line">  subscriptions,</span><br><span class="line">  callback,</span><br><span class="line">  options.detached,</span><br><span class="line">  () =&gt; stopWatcher()</span><br><span class="line">)</span><br><span class="line">      <span class="comment">// 通过watch监听store.state直接修改</span></span><br><span class="line"><span class="keyword">const</span> stopWatcher = scope.run(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line"> watch(</span><br><span class="line">   () =&gt; pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;,</span><br><span class="line">   (state) =&gt; &#123;</span><br><span class="line">     <span class="comment">// flush默认为'pre',而在调用$patch时isListening会被设置为false,所以不会触发$patch修改state的监听回调</span></span><br><span class="line">     <span class="comment">// 但对于store.state直接修改的情况，store在创建完成后isSyncListening和isListening都会变成true，所以能够监听</span></span><br><span class="line">     <span class="keyword">if</span> (options.flush === <span class="string">'sync'</span> ? isSyncListening : isListening) &#123;</span><br><span class="line">       callback(</span><br><span class="line">         &#123;</span><br><span class="line">           storeId: $id,</span><br><span class="line">           <span class="keyword">type</span>: MutationType.direct, <span class="comment">// type为direct直接修改</span></span><br><span class="line">           events: debuggerEvents <span class="keyword">as</span> DebuggerEvent,</span><br><span class="line">         &#125;,</span><br><span class="line">         state</span><br><span class="line">       )</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   assign(&#123;&#125;, $subscribeOptions, options)</span><br><span class="line"> )</span><br><span class="line">)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> removeSubscription</span><br><span class="line"> &#125;,</span><br><span class="line"> $dispose,</span><br><span class="line">&#125; <span class="keyword">as</span> _StoreWithState&lt;Id, S, G, A&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个store创建结束后将两个监听标识为true,意味着store创建完成,可以进行监听订阅操作</span></span><br><span class="line">isListening = <span class="literal">true</span></span><br><span class="line">isSyncListening = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="patch修改"><a href="#patch修改" class="headerlink" title="$patch修改"></a>$patch修改</h3></li></ul><p>$patch用于批量修改state，内部主要通过两个标识位的修改，不触发<a href="https://so.csdn.net/so/search?q=watch%E7%9B%91%E5%90%AC&spm=1001.2101.3001.7020" target="_blank" rel="noopener">watch监听</a>回调</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// internal state</span></span><br><span class="line"><span class="keyword">let</span> isListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"><span class="keyword">let</span> isSyncListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$patch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> partialStateOrMutator:</span></span></span><br><span class="line"><span class="function"><span class="params">   | _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">   | ((state: UnwrapRef&lt;S&gt;) =&gt; <span class="built_in">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 订阅$patch操作type</span></span><br><span class="line"> <span class="keyword">let</span> subscriptionMutation: SubscriptionCallbackMutation&lt;S&gt;</span><br><span class="line"> <span class="comment">// 避免批量修改触发$subscribe</span></span><br><span class="line"> isListening = isSyncListening = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">   debuggerEvents = []</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 兼容$patch传递函数、对象调用的两种调用方式</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> partialStateOrMutator === <span class="string">'function'</span>) &#123;</span><br><span class="line">   partialStateOrMutator(pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;)</span><br><span class="line">   subscriptionMutation = &#123;</span><br><span class="line">     <span class="keyword">type</span>: MutationType.patchFunction,  <span class="comment">// type类型</span></span><br><span class="line">     storeId: $id,</span><br><span class="line">     events: debuggerEvents <span class="keyword">as</span> DebuggerEvent[],</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// $patch传递对象走合并流程</span></span><br><span class="line">   mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator)</span><br><span class="line">   subscriptionMutation = &#123;</span><br><span class="line">     <span class="keyword">type</span>: MutationType.patchObject, <span class="comment">// type类型</span></span><br><span class="line">     payload: partialStateOrMutator,</span><br><span class="line">     storeId: $id,</span><br><span class="line">     events: debuggerEvents <span class="keyword">as</span> DebuggerEvent[],</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> myListenerId = (activeListener = Symbol())</span><br><span class="line"> <span class="comment">// 对于异步修改情况，异步还原isListening,让$subscribe不会监听通过$patch修改state</span></span><br><span class="line"> nextTick().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (activeListener === myListenerId) &#123;</span><br><span class="line">     isListening = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> isSyncListening = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 手动触发订阅,实现通过$patch批量修改state只触发一次订阅回调</span></span><br><span class="line"> triggerSubscriptions(</span><br><span class="line">   subscriptions,</span><br><span class="line">   subscriptionMutation,</span><br><span class="line">   pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个store创建结束后将两个监听标识为true,意味着store创建完成,可以进行监听订阅操作</span></span><br><span class="line">isListening = <span class="literal">true</span></span><br><span class="line">isSyncListening = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="store-API"><a href="#store-API" class="headerlink" title="store API"></a>store API</h2><ul><li><h2 id="reset"><a href="#reset" class="headerlink" title="$reset"></a>$reset</h2></li></ul><p>对于options store提供的还原初始状态的API</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options store</span></span><br><span class="line">store.$reset = <span class="function"><span class="keyword">function</span> <span class="title">$reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newState = state ? state() : &#123;&#125;  <span class="comment">// state为options中的state</span></span><br><span class="line">  <span class="comment">// 通过$patch批量修改</span></span><br><span class="line">  <span class="keyword">this</span>.$patch(<span class="function">(<span class="params">$state</span>) =&gt;</span> &#123;</span><br><span class="line">    assign($state, newState)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup store</span></span><br><span class="line"><span class="keyword">const</span> $reset = __DEV__ <span class="comment">// 开发环境下会报错</span></span><br><span class="line">  ? <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`🍍: Store "<span class="subst">$&#123;$id&#125;</span>" is built using the setup syntax and does not implement $reset().`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  : noop</span><br></pre></td></tr></table></figure><ul><li><h2 id="dispose"><a href="#dispose" class="headerlink" title="$dispose"></a>$dispose</h2></li></ul><p>卸载store的API</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 卸载store</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  scope.stop() <span class="comment">//卸载store的scope effect</span></span><br><span class="line">  subscriptions = []</span><br><span class="line">  actionSubscriptions = []</span><br><span class="line">  pinia._s.delete($id) <span class="comment">// 从pinia上删除掉对应的store</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="storeToRefs解构store"><a href="#storeToRefs解构store" class="headerlink" title="storeToRefs解构store"></a>storeToRefs解构store</h2><p>通过storeToRefs使得解构store也不会丢失响应式</p><ul><li>基本使用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> store = useCounterStore()</span><br><span class="line">    <span class="comment">// ❌ 这将无法生效，因为它破坏了响应性</span></span><br><span class="line">    <span class="comment">// 这与从 `props` 中解构是一样的。</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, doubleCount &#125; = store</span><br><span class="line"></span><br><span class="line">    name <span class="comment">// "eduardo"</span></span><br><span class="line">    doubleCount <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 始终是 "eduardo"</span></span><br><span class="line">      name,</span><br><span class="line">      <span class="comment">// 始终是 2</span></span><br><span class="line">      doubleCount,</span><br><span class="line">      <span class="comment">// 这个将是响应式的</span></span><br><span class="line">      doubleValue: computed(<span class="function"><span class="params">()</span> =&gt;</span> store.doubleCount),</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过storeToRefs调用</span></span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> store = useCounterStore()</span><br><span class="line">    <span class="comment">// `name` and `doubleCount` 都是响应式 refs</span></span><br><span class="line">    <span class="comment">// 这也将为由插件添加的属性创建 refs</span></span><br><span class="line">    <span class="comment">// 同时会跳过任何 action 或非响应式(非 ref/响应式)属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, doubleCount &#125; = storeToRefs(store)</span><br><span class="line">    <span class="comment">// 名为 increment 的 action 可以直接提取</span></span><br><span class="line">    <span class="keyword">const</span> &#123; increment &#125; = store</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">      doubleCount,</span><br><span class="line">      increment,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>storeToRefs<ul><li>类似toRefs，但会跳过方法和非响应式属性</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// storeToRefs.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">storeToRefs</span>&lt;<span class="title">SS</span> <span class="title">extends</span> <span class="title">StoreGeneric</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  store: SS</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ToRefs</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">StoreState</span>&lt;<span class="title">SS</span>&gt; &amp; <span class="title">StoreGetters</span>&lt;<span class="title">SS</span>&gt; &amp; <span class="title">PiniaCustomStateProperties</span>&lt;<span class="title">StoreState</span>&lt;<span class="title">SS</span>&gt;&gt;</span></span><br><span class="line"><span class="function">&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">    <span class="comment">// @ts-expect-error: toRefs include methods and others</span></span><br><span class="line">    <span class="keyword">return</span> toRefs(store) <span class="comment">// vue2 版本直接all in ref</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">    store = toRaw(store) <span class="comment">// 拿到store原始对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> refs = &#123;&#125; <span class="keyword">as</span> ToRefs&lt;</span><br><span class="line">      StoreState&lt;SS&gt; &amp;</span><br><span class="line">        StoreGetters&lt;SS&gt; &amp;</span><br><span class="line">        PiniaCustomStateProperties&lt;StoreState&lt;SS&gt;&gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> store) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = store[key]</span><br><span class="line">      <span class="comment">// 只转换ref、reactive属性</span></span><br><span class="line">      <span class="keyword">if</span> (isRef(value) || isReactive(value)) &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error: the key is state or getter</span></span><br><span class="line">        refs[key] =</span><br><span class="line">          <span class="comment">// ---</span></span><br><span class="line">          toRef(store, key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> refs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map系列辅助函数"><a href="#map系列辅助函数" class="headerlink" title="map系列辅助函数"></a>map系列辅助函数</h2><ul><li><h2 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h2></li></ul><p>基本使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 可以访问组件中的 this.count</span></span><br><span class="line">    <span class="comment">// 与从 store.count 中读取的数据相同</span></span><br><span class="line">    ...mapState(useCounterStore, [<span class="string">'count'</span>])</span><br><span class="line">    <span class="comment">// 与上述相同，但将其注册为 this.myOwnName</span></span><br><span class="line">    ...mapState(useCounterStore, &#123;</span><br><span class="line">      myOwnName: <span class="string">'count'</span>,</span><br><span class="line">      <span class="comment">// 你也可以写一个函数来获得对 store 的访问权</span></span><br><span class="line">      double: <span class="function"><span class="params">store</span> =&gt;</span> store.count * <span class="number">2</span>,</span><br><span class="line">      <span class="comment">// 它可以访问 `this`，但它没有标注类型...</span></span><br><span class="line">      magicValue(store) &#123;</span><br><span class="line">        <span class="keyword">return</span> store.someGetter + <span class="keyword">this</span>.count + <span class="keyword">this</span>.double</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapState</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapHelpers.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapState</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">_GettersTree</span>&lt;<span class="title">S</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  useStore: StoreDefinition&lt;Id, S, G, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  keysOrMapper: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">_MapStateReturn</span>&lt;<span class="title">S</span>, <span class="title">G</span>&gt; | <span class="title">_MapStateObjectReturn</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个对象使得能够放到组件的computed属性上</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(keysOrMapper)</span><br><span class="line">    ? keysOrMapper.reduce(<span class="function">(<span class="params">reduced, key</span>) =&gt;</span> &#123;</span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: ComponentPublicInstance</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 通过useStore，因为store已经创建，所以内部会直接通过pinia._s.get(id)直接返回store而不会重新创建</span></span><br><span class="line">          <span class="keyword">return</span> useStore(<span class="keyword">this</span>.$pinia)[key]</span><br><span class="line">        &#125; <span class="keyword">as</span> () =&gt; <span class="built_in">any</span></span><br><span class="line">        <span class="keyword">return</span> reduced</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> _MapStateReturn&lt;S, G&gt;)</span><br><span class="line">    : <span class="built_in">Object</span>.keys(keysOrMapper).reduce(<span class="function">(<span class="params">reduced, key: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error</span></span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: ComponentPublicInstance</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">const</span> store = useStore(<span class="keyword">this</span>.$pinia)</span><br><span class="line">          <span class="keyword">const</span> storeKey = keysOrMapper[key]</span><br><span class="line">          <span class="comment">// for some reason TS is unable to infer the type of storeKey to be a</span></span><br><span class="line">          <span class="comment">// function</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">typeof</span> storeKey === <span class="string">'function'</span></span><br><span class="line">            ? <span class="function">(<span class="params">storeKey <span class="keyword">as</span> (<span class="params">store: Store&lt;Id, S, G, A&gt;</span>) =&gt; <span class="built_in">any</span></span>).<span class="params">call</span>(<span class="params"><span class="keyword">this</span>, store</span>)</span></span><br><span class="line"><span class="function">            : <span class="params">store</span>[<span class="params">storeKey</span>]</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="params">return</span> <span class="params">reduced</span></span></span><br><span class="line"><span class="function">      &#125;, &#123;&#125; <span class="params">as</span> _<span class="params">MapStateObjectReturn</span>&lt;<span class="params">Id</span>, <span class="params">S</span>, <span class="params">G</span>, <span class="params">A</span>&gt;)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><h2 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h2></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = mapState <span class="comment">//👍</span></span><br></pre></td></tr></table></figure><ul><li><h2 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h2></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapActions</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">_GettersTree</span>&lt;<span class="title">S</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span>,</span></span><br><span class="line"><span class="function">  <span class="title">KeyMapper</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">keyof</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  useStore: StoreDefinition&lt;Id, S, G, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  keysOrMapper: <span class="built_in">Array</span>&lt;keyof A&gt; | KeyMapper</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">_MapActionsReturn</span>&lt;<span class="title">A</span>&gt; | <span class="title">_MapActionsObjectReturn</span>&lt;<span class="title">A</span>, <span class="title">KeyMapper</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(keysOrMapper)</span><br><span class="line">    ? keysOrMapper.reduce(<span class="function">(<span class="params">reduced, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 和mapState类似,闭包存了下this和其他参数</span></span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">this</span>: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">          ...args: <span class="built_in">any</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> useStore(<span class="keyword">this</span>.$pinia)[key](...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduced</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> _MapActionsReturn&lt;A&gt;)</span><br><span class="line">    : <span class="built_in">Object</span>.keys(keysOrMapper).reduce(<span class="function">(<span class="params">reduced, key: keyof KeyMapper</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error</span></span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">this</span>: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">          ...args: <span class="built_in">any</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> useStore(<span class="keyword">this</span>.$pinia)[keysOrMapper[key]](...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduced</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> _MapActionsObjectReturn&lt;A, KeyMapper&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和vuex区别"><a href="#和vuex区别" class="headerlink" title="和vuex区别"></a>和vuex区别</h2><ul><li><h2 id="不再有嵌套结构的模块"><a href="#不再有嵌套结构的模块" class="headerlink" title="不再有嵌套结构的模块"></a>不再有嵌套结构的模块</h2><ul><li>看过vuex的应该知道，整个vuex就是个嵌套的大对象，会根据命名空间一步一步从对象中取出内容，不过内部会帮你拼接命名空间路径，实际调用时也还好</li><li>而pinia不再通过命名空间来嵌套对象，通过pinia._s这个Map结构来存储创建的store，通过pinia.state.value[storeId]来存储state，整个就是一平级的结构</li></ul></li><li><h2 id="创建非常方便，和写一个hook函数一样轻松"><a href="#创建非常方便，和写一个hook函数一样轻松" class="headerlink" title="创建非常方便，和写一个hook函数一样轻松"></a>创建非常方便，和写一个hook函数一样轻松</h2><ul><li>虽然但是，总觉得vue越来越像React，用过hox的应该知道，Pinia的使用方式几乎和hox一模一样。。。</li></ul></li><li><h2 id="无需mutation"><a href="#无需mutation" class="headerlink" title="无需mutation"></a>无需mutation</h2><ul><li>见仁见智吧，有个mutation调用流程更规范，没有就是函数调用，无学习成本</li></ul></li><li><p>总结一下，虽然单项数据流类型的状态管理库（redux、vuex）具有十分严谨的调用步骤，但这种函数式的方式才是未来（主要是开发爽了。。。）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建pinia&quot;&gt;&lt;a href=&quot;#创建pinia&quot; class=&quot;headerlink&quot; title=&quot;创建pinia&quot;&gt;&lt;/a&gt;创建pinia&lt;/h2&gt;&lt;p&gt;基本使用&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;tab
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3响应式属性Reactive和Ref</title>
    <link href="https://summxu.github.io/2023/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B1%9E%E6%80%A7Reactive%E5%92%8CRef/"/>
    <id>https://summxu.github.io/2023/Vue3响应式属性Reactive和Ref/</id>
    <published>2023-02-27T00:49:38.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ref-的基本使用"><a href="#ref-的基本使用" class="headerlink" title="ref 的基本使用"></a>ref 的基本使用</h2><p>1.ref:接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象仅有一个 <code>.value</code> property，指向该内部值。</p><p><strong>注意</strong>：被ref包装之后需要.value 来进行赋值，因为使用ref包装，返回的是一个对象，Ref TS对应的接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, Ref &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">const message: Ref&lt;string&gt; = ref('ref响应式数据');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = '修改后的数据';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>ts的另外一种方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">const message = ref&lt;string | number&gt;('ref响应式数据');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = '修改后的数据';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>3.shallowRef创建一个跟踪自身 <code>.value</code> 变化的 ref，但不会使其值也变成响应式的。&lt;template&gt;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, shallowRef &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">type Obj = &#123;</span></span><br><span class="line"><span class="regexp">  name: string;</span></span><br><span class="line"><span class="regexp">  num: number;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">const message = shallowRef&lt;Obj&gt;(&#123;</span></span><br><span class="line"><span class="regexp">  name: 'vue3',</span></span><br><span class="line"><span class="regexp">  num: 100</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/修改的值无法显示在页面上</span></span><br><span class="line"><span class="regexp">  message.value.name = '修改了name';</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/修改的值可以显示在页面上</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/message.value = &#123; name: '修改了name', num: 123 &#125;;　</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/triggerRef强制修改，修改的值可以在页面显示  </span></span><br><span class="line"><span class="regexp">  triggerRef(message);</span></span><br><span class="line"><span class="regexp">  console.log(message, 'message');</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>4.customRef 是个工厂函数要求我们返回一个对象 并且实现 get 和 set：</p><p>应用场景：实现防抖函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, shallowRef, triggerRef, customRef &#125; from 'vue';</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">let message = MycustomRef('我是原始数据');</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = '修改了数据';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">function MycustomRef&lt;T&gt;(value: T) &#123;</span></span><br><span class="line"><span class="regexp">  return customRef((track, trigger) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      get: () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        track();/</span><span class="regexp">/通知vue，跟踪数据的变化</span></span><br><span class="line"><span class="regexp">        return value;</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      set: (newVal: T) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        value = newVal;</span></span><br><span class="line"><span class="regexp">        trigger();/</span><span class="regexp">/通知vue重新解析模版，挂载数据</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="ref-为何要用-value"><a href="#ref-为何要用-value" class="headerlink" title="ref 为何要用.value"></a>ref 为何要用.value</h2><blockquote><p>在Vue2中，所有的数据都通过一个Data进行统一的返回，并且在data中对某个组件要用的数据进行统一的管理，常见的使用形式是这样的：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">"div"</span>&gt;</span><br><span class="line">    &lt;todos :Obj=<span class="string">"tos"</span> :removeObj=<span class="string">"removeObj"</span>&gt;&lt;<span class="regexp">/todos&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import search from '@/</span>components/search<span class="string">'</span></span><br><span class="line"><span class="string">import todos from '</span>@/components/todos<span class="string">'</span></span><br><span class="line"><span class="string">import all from '</span>@/components/all<span class="string">'</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  name: '</span>App<span class="string">',</span></span><br><span class="line"><span class="string">  data () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      tos: [</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">001</span><span class="string">', value: '</span>第一个<span class="string">', done: true &#125;,</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">002</span><span class="string">', value: '</span>第二个<span class="string">', done: true &#125;,</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">003</span><span class="string">', value: '</span>第三个<span class="string">', done: false &#125;,</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">004</span><span class="string">', value: '</span>第四个<span class="string">', done: true &#125;,</span></span><br><span class="line"><span class="string">      ],</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  computed: &#123; &#125;,</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    search, todos, all,</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    removeObj (obj) &#123;</span></span><br><span class="line"><span class="string">      console.log(obj.id)</span></span><br><span class="line"><span class="string">      this.tos = this.tos.filter(item =&gt; item.id !== obj.id)</span></span><br><span class="line"><span class="string">      console.log(this.tos)</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出来这里定义的内容都在一个数组中进行，或者是一个函数，将要使用的数据返回出来，这里无论怎么进行操作处理，最终进行数据代理的时候得到的都是一个对象，Vue2中直接通过defineProperty进行处理，并绑定对应的监听事件进行响应式的处理。</p><p>而Vue3中，数据的定义可以是单独的，Vue可以让随时需要随时定义，这也就带来了另一个问题，我需要的一个数据可能不是对象</p><p><strong>如果要定义的数据不是对象，还需要代理会怎么样？</strong></p><ul><li><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</li></ul><p>通过这个可以明确看出，只能进行对象的代理，不能进行普通数据的代理</p><p>在Vue3中数据代理可以使用单一数据了，并且也改进了数据代理的方式，使用的是<code>Proxy</code>完成了数据代理，而MDN中对<code>Proxy</code>也进行了定义：</p><ul><li><code>Proxy</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</li></ul><p>即使是Vue3中使用的<code>Proxy</code>的代理方式也不能进行普通数据的代理，所以当调用Ref的时候其实仍然创建了一个<code>Proxy</code>对象，并且Vue帮你给这个对象了一个value属性，属性值就是你定义的内容，改变的时候监视的改变依然是通过<code>Proxy</code>的数据劫持来进行响应式的处理，而模板中使用的时候Vue会默认调用对应的value属性，从而完成模板中的内容的直接调用 </p><h2 id="Reactive-的基本使用"><a href="#Reactive-的基本使用" class="headerlink" title="Reactive 的基本使用"></a>Reactive 的基本使用</h2><p>1.reactive:用来绑定复杂的数据类型：数组，对象等。</p><p><strong>注意</strong>:reactive如果绑定的是基础类型数据会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; reactive &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">let obj = reactive(&#123;</span></span><br><span class="line"><span class="regexp">  name: '张三',</span></span><br><span class="line"><span class="regexp">  age: 18,</span></span><br><span class="line"><span class="regexp">  boj: &#123;</span></span><br><span class="line"><span class="regexp">    namespaced: true</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  obj.name = '异步赋值无效';</span></span><br><span class="line"><span class="regexp">&#125;, 2000);</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  obj.name = '李四';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>2.readonly:拷贝一份proxy对象并设置为只读属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; reactive, readonly &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">let obj = reactive(&#123;</span></span><br><span class="line"><span class="regexp">  name: '张三',</span></span><br><span class="line"><span class="regexp">  age: 18,</span></span><br><span class="line"><span class="regexp">  boj: &#123;</span></span><br><span class="line"><span class="regexp">    namespaced: true</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">let CopyObj = readonly(obj);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '异步赋值无效';</span></span><br><span class="line"><span class="regexp">&#125;, 2000);</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '李四';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>3.shallowReactive:拷贝一份对象，可以修改浅层数据，无法修改深层数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; reactive, shallowReactive &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">let obj = reactive(&#123;</span></span><br><span class="line"><span class="regexp">  name: '张三',</span></span><br><span class="line"><span class="regexp">  age: 18,</span></span><br><span class="line"><span class="regexp">  boj: &#123;</span></span><br><span class="line"><span class="regexp">    namespaced: true</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">let CopyObj = shallowReactive(obj);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/可以修改</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '异步赋值';</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/无法修改</span></span><br><span class="line"><span class="regexp">  CopyObj.boj.namespaced = false;</span></span><br><span class="line"><span class="regexp">&#125;, 2000);</span></span><br><span class="line"><span class="regexp">console.log(CopyObj.boj.namespaced);</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '李四';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ref-的基本使用&quot;&gt;&lt;a href=&quot;#ref-的基本使用&quot; class=&quot;headerlink&quot; title=&quot;ref 的基本使用&quot;&gt;&lt;/a&gt;ref 的基本使用&lt;/h2&gt;&lt;p&gt;1.ref:接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象仅有一
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3中watch和watchEffect的用法和区别</title>
    <link href="https://summxu.github.io/2022/Vue3%E4%B8%ADwatch%E5%92%8CwatchEffect%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://summxu.github.io/2022/Vue3中watch和watchEffect的用法和区别/</id>
    <published>2022-10-12T09:13:34.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-watch-基本使用"><a href="#1-1-watch-基本使用" class="headerlink" title="1.1 watch 基本使用"></a>1.1 watch 基本使用</h3><p>在 Vue3 中的组合式 API 中，watch 的作用和 Vue2 中的 watch 作用是一样的，他们都是用来监听响应式状态发生变化的，当响应式状态发生变化时，都会触发一个回调函数。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">"Vue logo"</span> src=<span class="string">"./assets/logo.png"</span> /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button @click="changeMsg"&gt;更改 message&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, watch &#125; from "vue";</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const message = ref("李四");</span></span><br><span class="line"><span class="regexp">watch(message, (newValue, oldValue) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log("新的值:", newValue);</span></span><br><span class="line"><span class="regexp">  console.log("旧的值:", oldValue);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">const changeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = "张三";</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>上段代码中点击按钮就会更改响应式变量 message 的值。又使用 watch 监听器监听了 message 变量，当它发生变化时，就会触发 watch 监听函数中的回调函数，并且回调函数默认接收两个参数：新值和旧值。</p><p><strong>注意：当第一进入页面时，watch 监听函数的回调函数是不会执行的。</strong></p><h3 id="1-2-watch-监听类型"><a href="#1-2-watch-监听类型" class="headerlink" title="1.2 watch 监听类型"></a>1.2 watch 监听类型</h3><p>前面一直强调 watch 监听的是响应式数据，如果监听的数据不是响应式的，那么可能会抛出警告。</p><p><strong>（1）ref 和计算属性</strong></p><p>ref 定义的数据是可以监听到的，因为前面的代码以及证明了。除此之外，计算属性也是可以监听到的，比如下列代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = ref(<span class="string">"李四"</span>);</span><br><span class="line"><span class="keyword">const</span> newMessage = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> message.value;</span><br><span class="line">&#125;);</span><br><span class="line">watch(newMessage, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 message 发生变化时，计算属性 newMessage 也会重新计算得出新的结果， watch 监听函数是可以监听到计算属性变化的。</p><p><strong>（2）getter 函数</strong></p><p>这里的 getter 函数可以简单的理解为获取数据的一个函数，说白了该函数就是一个返回值的操作，有点类似与计算属性。</p><p><strong>示例代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">"Vue logo"</span> src=<span class="string">"./assets/logo.png"</span> /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&#123;&#123; x1 + x2 &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"changeMsg"</span>&gt;更改 message&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script setup lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = ref(<span class="string">"李四"</span>);</span><br><span class="line"><span class="keyword">const</span> x1 = ref(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">const</span> x2 = ref(<span class="number">13</span>);</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; x1.value + x2.value,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> changeMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  message.value = <span class="string">"张三"</span>;</span><br><span class="line">  x1.value = <span class="number">14</span>;</span><br><span class="line">  x2.value = <span class="number">23</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上段代码中 watch 监听器中的第一个参数是一个箭头函数，也就是 getter 函数，getter 函数返回的是响应式数据 x1 和 x2 相加的值，当这两个中中有一个变化，都会执行 watch 中的回调函数。有点像是直接把计算属性写到监听器里面去了。</p><p><strong>（3）监听响应式对象</strong></p><p>前面监听的都是值类型的响应式数据，同样也可以监听响应式的对象。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(<span class="built_in">number</span>, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 watch 监听的是一个响应式对象时，会隐式地创建一个深层侦听器，即该响应式对象里面的任何属性发生变化，都会触发监听函数中的回调函数。</p><p>需要注意的，watch 不能直接监听响应式对象的属性，即下面的写法是错误的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(<span class="built_in">number</span>.count, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上段代码中相当于你直接向 watch 传递了一个非响应式的数字，然而 watch 只能监听响应式数据。</p><p><strong>但是：</strong></p><p>如果非要监听响应式对象中的某个属性，可以使用 getter 函数的形式，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>.count,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上段代码也是可以监听到 count 变化的。</p><p><strong>（4）监听多个来源的数组</strong></p><p>watch 还可以监听数组，前提是这个数组内部含有响应式数据。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x1 = ref(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch([x1, <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">number</span>.count], <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-3-深度监听"><a href="#1-3-深度监听" class="headerlink" title="1.3 深度监听"></a>1.3 深度监听</h3><p>在前面的代码中，如果将一个响应式对象传递给 watch 监听器时，只要对象里面的某个属性发生了变化，那么就会执行监听器回调函数。</p><p>究其原因，因为传入响应对象给 watch 时，隐式的添加一个深度监听器，这就让造成了牵一发而至全身的效果。</p><p>但是，如果是使用的 getter 函数返回响应式对象的形式，那么响应式对象的属性值发生变化，是不会触发 watch 的回调函数的。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上段代码中使用 getter 函数返回了响应式对象，当更改 number 中 count 的值时，watch 的回调函数是不会执行的。</p><p>为了实现上述代码的监听，可以手动给监听器加上深度监听的效果。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; deep: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加深度监听很简单，只需要给 watch 添加第三个参数即可：{ deep: true }。</p><p><strong>注意：</strong>上段代码中的 newValue 和 oldValue 的值是一样的，除非把响应式对象即 number 整个替换掉，那么这两个值才会变得不一样。除此之外，深度监听会遍历响应式对象的所有属性，开销较大，当对象体很大时，需要慎用<strong>。</strong></p><p><strong>所以推荐 getter 函数只返回相应是对象中的某一个属性！！</strong></p><h2 id="2-watchEffect"><a href="#2-watchEffect" class="headerlink" title="2.watchEffect"></a>2.watchEffect</h2><p>前面使用 watch 监听数据状态时，不知道有没有发现这样一个问题：只有当监听的数据源发生了变化，监听函数的回调函数才会执行。但是需求总是多变的，有些场景下可能需要刚进页面，或者说第一次渲染页面的时候，watch 监听器里面的回调函数就执行一遍。</p><p>面对这种需求怎样处理呢？一般有两种方式：</p><p><strong>方式一：</strong></p><p>这种方式也是通过 watch 实现的，确切的说是巧妙的实现，而不是依赖于 watch 监听器。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="comment">// 进入页面先执行一遍</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, <span class="built_in">number</span>.count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, <span class="built_in">number</span>.count);</span><br><span class="line">&#125;;</span><br><span class="line">callback();</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>.count,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; deep: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>既然想要第一次进入页面的时候就执行一遍回调函数，那么不妨把回调函数直接提取出来，进入页面执行一遍即可，这也算是巧妙的实现了的需求。</p><p>但是这种方式似乎不太优雅，而且有些繁琐。所以 Vue 推出了更加优雅的方法：watchEffect 监听器。</p><p><strong>方式二：</strong></p><p>watchEffect 也是一个监听器，只不过它不会像 watch 那样接收一个明确的数据源，它只接收一个回调函数。而在这个回调函数当中，它会自动监听响应数据，当回调函数里面的响应数据发生变化，回调函数就会立即执行。</p><p>所以可以将方式一中的代码使用 watchEffect 优雅的实现。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, <span class="built_in">number</span>.count);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上段代码中，当第一次进入页面时，number 响应数据从无到有，这个时候就会触发 watchEffect 的回调函数，因为在 watchEffect 回调函数中使用了 number 响应数据，所以它会自动跟踪 number 数据的变化。当点击按钮更改 count 的值时，watchEffect 中的回调函数便会再次执行。</p><p>这样代码是不是简单很多呀！</p><h2 id="3-watch-和-watchEffect-区别"><a href="#3-watch-和-watchEffect-区别" class="headerlink" title="3.watch 和 watchEffect 区别"></a>3.watch 和 watchEffect 区别</h2><p>已经大概知道了 watch 和 watchEffect 的用法，那么它们之间的区别相信也了解了一些，这里总结一下它们之间的区别。</p><ul><li>watch 和 watchEffect 都能监听响应式数据的变化，不同的是它们监听数据变化的方式不同。</li><li>watch 会明确监听某一个响应数据，而 watchEffect 则是隐式的监听回调函数中响应数据。</li><li>watch 在响应数据初始化时是不会执行回调函数的，watchEffect 在响应数据初始化时就会立即执行回调函数。</li></ul><h2 id="4-回调中的-DOM"><a href="#4-回调中的-DOM" class="headerlink" title="4.回调中的 DOM"></a>4.回调中的 DOM</h2><p>如果在监听器的回调函数中或取 DOM，这个时候的 DOM 是更新前的还是更新后的？</p><p>不妨实验一下。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">"Vue logo"</span> src=<span class="string">"./assets/logo.png"</span> /&gt;</span><br><span class="line">  &lt;p ref=<span class="string">"msgRef"</span>&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button @click="changeMsg"&gt;更改 message&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; computed, reactive, ref, watch, watchEffect &#125; from "vue";</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const message = ref("李四");</span></span><br><span class="line"><span class="regexp">const msgRef = ref&lt;any&gt;(null);</span></span><br><span class="line"><span class="regexp">const changeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = "张三";</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">watch(message, (newValue, oldValue) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log("DOM 节点", msgRef.value.innerHTML);</span></span><br><span class="line"><span class="regexp">  console.log("新的值:", newValue);</span></span><br><span class="line"><span class="regexp">  console.log("旧的值:", oldValue);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>通过点击按钮更改 message 的值，从“李四”变为“张三”。但是发现在监听器的回调函数里面获取到的 DOM 元素还是“李四”，说明 DOM 还没有更新。</p><p><strong>解决方法：</strong></p><p>如果想要在回调函数里面获取更新后的 DOM，非常简单，只需要再给监听器多传递一个参数选项即可：flush: ‘post’。watch 和 watchEffect 同理。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, &#123;</span><br><span class="line">  flush: <span class="string">'post'</span></span><br><span class="line">&#125;)</span><br><span class="line">watchEffect(callback, &#123;</span><br><span class="line">  flush: <span class="string">'post'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>修改后的代码：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  message,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"DOM 节点"</span>, msgRef.value.innerHTML);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">"post"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个时候在回调函数中获取到的已经是更新后的 DOM 节点了。</p><p><strong>补充：</strong></p><p>虽然 watch 和 watchEffect 都可以用上述方法解决 DOM 问题，但是 Vue3 单独给 watchEffect 提供了一个更方便的方法，也可以叫做 watchEffect 的别名，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watchPostEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 在 Vue 更新后执行 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-手动停止监听器"><a href="#5-手动停止监听器" class="headerlink" title="5.手动停止监听器"></a>5.手动停止监听器</h2><p>通常来说，的一个组件被销毁或者卸载后，监听器也会跟着被停止，并不需要手动去关闭监听器。但是总是有一些特殊情况，即使组件卸载了，但是监听器依然存在，这个时候其实式需要手动关闭它的，否则容易造成内存泄漏。</p><p>比如下面这中写法，就需要手动停止监听器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; watchEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// 它会自动停止</span></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// ...这个则不会！</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上段代码中采用异步的方式创建了一个监听器，这个时候监听器没有与当前组件绑定，所以即使组件销毁了，监听器依然存在。</p><p>关闭方法很简单，<strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// ...当该侦听器不再需要时</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure><p>需要用一个变量接收监听器函数的返回值，其实就是返回的一个函数，然后调用该函数，即可关闭当前监听器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-1-watch-基本使用&quot;&gt;&lt;a href=&quot;#1-1-watch-基本使用&quot; class=&quot;headerlink&quot; title=&quot;1.1 watch 基本使用&quot;&gt;&lt;/a&gt;1.1 watch 基本使用&lt;/h3&gt;&lt;p&gt;在 Vue3 中的组合式 API 中，wat
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>React实现原理及Fiber架构</title>
    <link href="https://summxu.github.io/2022/React%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8AFiber%E6%9E%B6%E6%9E%84/"/>
    <id>https://summxu.github.io/2022/React实现原理及Fiber架构/</id>
    <published>2022-05-12T01:36:14.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h2><p><strong>定义</strong>：vdom 就是根据真实dom的属性使用js重新按照原有结构模拟出一份dom对象，dom api 对真实 dom 做增删改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'div'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        id: <span class="string">'aaa'</span>,</span><br><span class="line">        className: [<span class="string">'bbb'</span>, <span class="string">'ccc'</span>],</span><br><span class="line">        onClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 vdom 的好处，就没有和 dom 强绑定了，可以跨平台渲染，比如 native、canvas 等等。</p><p>但是要让开发去写这样的 vdom 么？</p><p>那肯定不行，这样太麻烦了，大家熟悉的是 html 那种方式，所以要引入一些编译的手段。</p><h2 id="dsl-的编译"><a href="#dsl-的编译" class="headerlink" title="dsl 的编译"></a>dsl 的编译</h2><p>dsl 是 domain specific language，领域特定语言的意思，html、css 都是 web 领域的 dsl。</p><p>直接写 vdom 太麻烦了，所以前端框架都会设计一套 dsl，然后编译成 render function，执行后产生 vdom。</p><p>vue 和 react 都是这样：</p><blockquote><p>jsx -&gt; render function -&gt; vdom</p></blockquote><p>这套 dsl 怎么设计呢？</p><p>前端领域大家熟悉的描述 dom 的方式是 html，最好的方式自然是也设计成那样。</p><p>所以 vue 的 template，react 的 jsx 就都是这么设计的。</p><p>vue 的 template compiler 是自己实现的，而 react 的 jsx 的编译器是 babel 实现的，是两个团队合作的结果。</p><h2 id="渲染-vdom"><a href="#渲染-vdom" class="headerlink" title="渲染 vdom"></a>渲染 vdom</h2><p>渲染 vdom 也就是通过 dom api 增删改 dom。</p><p>比如一个 div，那就要 document.createElement 创建元素，然后 setAttribute 设置属性，addEventListener 设置事件监听器。</p><p>如果是文本，那就要 document.createTextNode 来创建。</p><p>所以说根据 vdom 类型的不同，写个 if else，分别做不同的处理就行了。</p><p>没错，不管 vue 还是 react，渲染器里这段 if else 是少不了的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (vdom.tag) &#123;</span><br><span class="line">  <span class="keyword">case</span> HostComponent:</span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">  <span class="keyword">case</span> HostText:</span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">  <span class="keyword">case</span> FunctionComponent: </span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">  <span class="keyword">case</span> ClassComponent: </span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react 里是通过 tag 来区分 vdom 类型的，比如 <code>HostComponent</code> 就是元素，<code>HostText</code> 就是文本，<code>FunctionComponent</code>、<code>ClassComponent</code> 就分别是函数组件和类组件。</p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>react <strong>没有响应式系统</strong>，是通过 <code>setState</code> 的 api 触发状态更新的，更新以后就<strong>重新渲染整个 vdom</strong>。</p><blockquote><p>vue 是通过对状态做代理，get 的时候收集以来，然后修改状态的时候就可以触发对应组件的 render 了，不管是子组件、父组件、还是其他位置的组件，只要用到了对应的状态，那就会被作为依赖收集起来，状态变化的时候就可以触发它们的 render，不管是组件是在哪里的。</p></blockquote><p>这就是为什么 react 需要重新渲染整个 vdom，而 vue 不用。</p><p>react 的 <code>setState</code> 会渲染整个 vdom，而一个应用的所有 vdom 可能是很庞大的，计算量就可能很大。</p><p>浏览器里 js 计算时间太长是会阻塞渲染的，会占用每一帧的动画、重绘重排的时间，这样动画就会卡顿。</p><p>作为一个有追求的前端框架，动画卡顿肯定是不行的。但是因为 <code>setState</code> 的方式只能渲染整个 vdom，所以计算量大是不可避免的。</p><p>那能不能把计算量拆分一下，每一帧计算一部分，不要阻塞动画的渲染呢？</p><p>顺着这个思路，react 就改造为了 fiber 架构。</p><h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><h3 id="一：Fiber的概念"><a href="#一：Fiber的概念" class="headerlink" title="一：Fiber的概念"></a>一：Fiber的概念</h3><p>React Fiber是react执行渲染时的一种新的调度策略，JavaScript是单线程的，一旦组件开始更新，主线程就一直被React控制，这个时候如果再次执行交互操作，就会卡顿。</p><p>  React Fiber就是通过对象记录组件上需要做或者已经完成的更新，一个组件可以对应多个Fiber。</p><p>  在render函数中创建的React Element树在第一次渲染的时候会创建一颗结构一模一样的的Fiber节点树。不同的React Element类型对应不同的Fiber节点类型。一个React Element的工作就由它对应的Fiber节点来负责。</p><p>  一个React Element可以对应不止一个Fiber，因为Fiber在update的时候，会从原来的Fiber(我们称为current)clone出一个新的Fiber(我们称之为alternate)。俩个Fiber diff出的变化(side effect)记录在alternate上。所以一个组件在更新时最多会有俩个Fiber与其对应，在更新结束后alternate会取代之前的current称为新的current节点。</p><p>  React Fiber重构这种方式，渲染过程采用切片的方式，每执行一会儿，就歇一会儿。如果有优先级更高的任务到来以后呢，就会先去执行，降低页面发生卡顿的可能性，使得React对动画等实时性要求较高的场景体验更好。</p><h3 id="二：什么是Fiber？"><a href="#二：什么是Fiber？" class="headerlink" title="二：什么是Fiber？"></a>二：什么是Fiber？</h3><p>  当js在处理大型计算的时候会导致页面出现卡帧的现象，更严重的会出现页面“假死”。所以在这些情况下，必然会导致动画丢帧、不连贯，用户体验就特别差。为了解决这个问题，我们可以将大型的计算拆分成一个个小型计算，然后按照执行顺序异步调用，这样就不会长时间霸占线程，UI也能在俩次小型计算的执行间隙进行更新，从而给与用户及时的反馈，Fiber就是这样做的，并且以一种更高逼格的方式实现了。<br><strong>Driving Idea</strong><br>  如果说v16.0之前的React解决了HOW(如何用最少的DOM操作成本来update视图)的问题，那么这一次Fiber的出现，在这个基础上还解决了WHEN(何时update视图的哪一部分)的问题。<br>   <strong>分片优先级！！！</strong></p><p>  基于上述这些原因，Fiber实现了一个虚拟调用栈，并给所有的update进行优先级排序，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"> </span><br><span class="line">NoWork: 0, // No work is pending.</span><br><span class="line"> </span><br><span class="line">SynchronousPriority: 1, // 用于控制文本输入。同步的副作用.</span><br><span class="line"></span><br><span class="line">AnimationPriority: 2, //需要在下一帧之前完成.</span><br><span class="line"> </span><br><span class="line">HighPriority: 3, // 需要很快完成的互动才能产生反应.</span><br><span class="line"> </span><br><span class="line">LowPriority: 4, // 数据获取，或更新存储的结果.</span><br><span class="line"> </span><br><span class="line">OffscreenPriority: 5, // 将不可见，但做的工作，以防它成为可见.</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  然后根据这些update的优先级，来决定执行的顺序。<br>  我们可以看到动画和页面交互都是优先级比较高的，这也是Fiber能够使得动画、布局和页面交互变得更加的流畅的原因之一。<br>  可以把Priority分为同步和异步两个类别，同步优先级的任务会在当前帧完成，包括SynchronousPriority和TaskPriority。异步优先级的任务则可能在接下来的几个帧中被完成，包括HighPriority、LowPriority以及OffscreenPriority。<br>  React v16.3.2的优先级，不再这么划分，分为三类：NoWork、sync、async，前两类可以认为是同步任务，需要在当前tick完成，过期时间为null，最后一类异步任务会计算一个。<br>  expirationTime，在workLoop中，根据过期时间来判断是否进行下一个分片任务，scheduleWork中更新任务优先级，也就是更新这个expirationTime。至于这个时间怎么计算，可以查看源码。</p><h3 id="三：Fiber的基本原则："><a href="#三：Fiber的基本原则：" class="headerlink" title="三：Fiber的基本原则："></a>三：Fiber的基本原则：</h3><p>  更新任务分成俩个阶段，Reconcilition Phase(调和阶段)和Commit Phase(交付阶段)。Reconciliation Phase的任务干的事情是，找出要做的更新工作(Diff Fiber Tree),就是一个计算阶段，计算结果可以被缓存，也就可以被打断；Commit Phase需要提交所有更新并渲染，为了防止页面抖动，被设置为不能打断。<br>  <strong>PS：componentWillMount</strong><br>  omponentWillReceiveProps componentWillUpdate 几个生命周期方法，在Reconciliation Phase被调用，有被打断的可能（时间用尽等情况），所以可能被多次调用。其实shouldComponentUpdate 也可能被多次调用，只是它只返回true或者false，没有副作用，可以暂时忽略。</p><h3 id="四：Fiber的数据结构"><a href="#四：Fiber的数据结构" class="headerlink" title="四：Fiber的数据结构"></a>四：Fiber的数据结构</h3><p>  fiber是个链表，有child和sibing属性，指向第一个子节点和相邻的兄弟节点，从而构成fiber tree。return 属性指向其父节点。<br>  更新队列，updateQueue，是一个链表，有first和last俩个属性，指向第一个和最后一个update对象。<br>  每个fiber有一个属性updateQueue指向其对应的更新队列。<br>  每个fiber(当前fiber可以称为current)有一个属性alternate，开始时指向一个自己的clone体，update的变化会先更新到alternate上，当更新完毕，alternate替换current。</p><h3 id="五：Fiber的执行流程"><a href="#五：Fiber的执行流程" class="headerlink" title="五：Fiber的执行流程"></a>五：Fiber的执行流程</h3><ol><li>用户操作引起setState被调用以后，先调用enqueueSetState方法，该方法可以划分成俩个阶段（个人理解），第一阶段Data Preparation，是初始化一些数据结构，比如fiber，updateQueue，update。</li><li>新的update会通过insertUpdateIntoQueue方法，根据优先级插入到队列的对应位置，ensureUpdateQueues方法初始化俩个更新队列，queue1和current.updateQueue对应，queue2和current.alternate.updateQueue对应。</li><li>第二阶段，Fiber Reconciler，就开始进行任务分片调度，scheduleWork首先更新每个fiber的优先级，这里并没有updatePriority这个方法，但是干了这件事。当fiber.return === null，找到父节点，把所有diff出的变化(side effect)归结到root上。</li><li>requestWork，首先把当前的更新添加到schedule list中(addRootToSchedule),然后根据当前是否为异步渲染(isAsync参数)，异步渲染调用。scheduleCallbackWithExpriation方法，下一步高能！！</li><li>scheduleCallbackWithExpriation这个方法在不同环境，实现不一样，chrome等浏览器中使用requestIdleCallback API，没有这个API的浏览器中，通过requestAnimationFrame模拟一个requestIdCallback，来在浏览器空闲时，完成下一个分片的工作，注意，这个函数会传入一个expirationTime，超过这个时间活没干完，就放弃了。</li><li>执行到performWorkOnRoot，就是fiber文档中提到的Commit Phase和Reconciliation Phase俩阶段。</li><li>第一阶段Reconciliation Phase,在workLoop中，通过一个while循环，完成每个分片任务。</li><li>performUnitOfWork也可以分成俩阶段，蓝色框表示。beginWork是一个入口函数，根据workInProgress的类型去实例化不同的react element class。workInProgress是通过alternate挂载一些新属性获得的。</li><li>实例化不同的react element class时候会调用和will有关的生命周期方法。</li><li>completeUnitOfWork是进行一些收尾工作，diff完一个节点以后，更新props和调用生命周期方法等。</li><li>然后进入Commit Phase阶段，这个阶段不能被打断。</li></ol><h3 id="六：Fiber对开发者有什么影响？"><a href="#六：Fiber对开发者有什么影响？" class="headerlink" title="六：Fiber对开发者有什么影响？"></a>六：Fiber对开发者有什么影响？</h3><ol><li>componentWillMount,componentWillReceiveProps,componentWillUpdate几个生命周期方法不再安全，由于任务执行过程可以被打断，这几个生命周期可能会执行多次，如果它们包含副作用(比如Ajax)，会有意想不到的bug。React团队提供了替换的生命周期方法。建议如果使用以上方法，尽量使用纯函数，避免以后踩坑。</li><li>需要关注react为任务片设置的优先级，特别是页面用动画的情况。</li><li>如果一直有更高的级别任务，那么fiber算法会先执行级别更高的任务，执行完毕后再通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vdom&quot;&gt;&lt;a href=&quot;#vdom&quot; class=&quot;headerlink&quot; title=&quot;vdom&quot;&gt;&lt;/a&gt;vdom&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：vdom 就是根据真实dom的属性使用js重新按照原有结构模拟出一份dom对象，do
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://summxu.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Redux源码全面解析</title>
    <link href="https://summxu.github.io/2022/Redux%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <id>https://summxu.github.io/2022/Redux源码全面解析/</id>
    <published>2022-02-26T01:36:37.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>Redux使用中的几个点：</p><ol><li>Redux三大设计原则</li><li>Create Store</li><li>Redux middleware</li><li>combineReducer</li><li>Provider与Connect</li><li>Redux流程梳理</li><li>Redux设计特点</li></ol><h4 id="1-单一数据源"><a href="#1-单一数据源" class="headerlink" title="1. 单一数据源"></a>1. 单一数据源</h4><p>在传统的 MVC 架构中，可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。因为在 Redux 的思想里，一个应用永远只有唯一的数据源。实际上，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样随时可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）。此外，这样的设计也为服务端渲染提供了可能。</p><h4 id="2-状态是只读的"><a href="#2-状态是只读的" class="headerlink" title="2. 状态是只读的"></a>2. 状态是只读的</h4><p>在 Redux 中，并不会自己用代码来定义一个 store。取而代之的是，定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里并没有直接修改应用的状态，而是返回了一份全新的状态。</p><p>Redux 提供的 createStore 方法会根据 reducer 生成 store。最后，可以利用 store. dispatch方法来达到修改状态的目的。</p><h4 id="3-状态修改均由纯函数完成"><a href="#3-状态修改均由纯函数完成" class="headerlink" title="3.状态修改均由纯函数完成"></a>3.状态修改均由纯函数完成</h4><p>在 Redux 里，通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。</p><p>这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux 利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发 action 而改变状态的结果成为了可能。</p><h2 id="2-Create-Store"><a href="#2-Create-Store" class="headerlink" title="2.Create Store"></a>2.Create Store</h2><p>从store的诞生开始说起。create store函数API文档如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createStore(reducer, [initialState], enhancer)</span><br></pre></td></tr></table></figure><p>可以看出，它接受三个参数：reducer、initialState 和 enhancer 。Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。</p><p>再来看看他的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    dispatch: f (action),</span><br><span class="line">    getState: f (),</span><br><span class="line">    replaceReducer: f (nextReducer),</span><br><span class="line">    subscribe: f (listener),</span><br><span class="line">    <span class="built_in">Symbol</span>(observable): f ()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>store的返回值就是一个普通对象，里面有几个常用的方法：</p><ul><li>dispatch：就是最常用的dispatch方法，派发action。</li><li>getState：通过该方法，可以拿到当前状态树state。</li><li>replaceReducer：这个方法主要用于 reducer 的热替换，下面介绍该方法。</li><li>subscribe：添加一个变化监听器。每当 dispatch（action）的时候就会执行，state 树中的一部分可能已经变化。</li><li>observable：观察者模式，用于处理订阅关系。</li></ul><p>这里挑几个方法介绍：</p><h3 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h3><p>在完成基本的参数校验之后，在 createStore 中声明如下变量及 getState 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentReducer = reducer</span><br><span class="line"><span class="keyword">var</span> currentState = initialState</span><br><span class="line"><span class="keyword">var</span> listeners = [] <span class="comment">// 当前监听 store 变化的监听器</span></span><br><span class="line"><span class="keyword">var</span> isDispatching = <span class="literal">false</span> <span class="comment">// 某个 action 是否处于分发的处理过程中</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Reads the state tree managed by the store.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">* @returns &#123;any&#125; The current state tree of your application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> currentState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getState方法就是简单返回当前state，如果state没有被reducer处理过，他就是initialState。</p><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p>在 getState 之后，定义了 store 的另一个方法 subscribe：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line"> listeners.push(listener)</span><br><span class="line"> <span class="keyword">var</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> isSubscribed = <span class="literal">false</span></span><br><span class="line"> <span class="keyword">var</span> index = listeners.indexOf(listener)</span><br><span class="line"> listeners.splice(index, <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Store 允许使用<code>store.subscribe</code>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p><p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入<code>listen</code>，就会实现 View 的自动渲染。你可能会感到奇怪，好像在 Redux 应用中并没有使用 store.subscribe 方法？事实上，</p><p>React Redux 中的 connect 方法隐式地帮完成了这个工作。</p><p><code>store.subscribe</code>方法返回一个函数，调用这个函数就可以解除监听。</p><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>dispatch是redux的核心方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">            <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">            <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        isDispatching = <span class="literal">true</span></span><br><span class="line">        currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    listeners.slice().forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前是否处于某个 action 的分发过程中，这个检查主要是为了避免在 reducer 中分发 action 的情况，因为这样做可能导致分发死循环，同时也增加了数据流动的复杂度。</p><p>确认当前不属于分发过程中后，先设定标志位，然后将当前的状态和 action 传给当前的reducer，用于生成最新的 state。这看起来一点都不复杂，这也是反复强调的 reducer 工作过程——纯函数、接受状态和 action 作为参数，返回一个新的状态。</p><p>在得到新的状态后，依次调用所有的监听器，通知状态的变更。需要注意的是，在通知监听器变更发生时，并没有将最新的状态作为参数传递给这些监听器。这是因为在监听器中，可以直接调用 store.getState() 方法拿到最新的状态。</p><p>最终，处理之后的 action 会被 dispatch 方法返回。</p><h3 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    currentReducer = nextReducer;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是为了拿到所有 reducer 中的初始状态（你是否还记得在定义 reducer 时，第一个参数为previousState，如果该参数为空，提供默认的 initialState）。只有所有的初始状态都成功获取后，Redux 应用才能有条不紊地开始运作。</p><h2 id="3-Redux-middleware"><a href="#3-Redux-middleware" class="headerlink" title="3.Redux middleware"></a>3.Redux middleware</h2><blockquote><p>It provides a third-party extension point between dispatching an action, and the moment it reachesthe reducer</p></blockquote><p>它提供了一个分类处理 action 的机会。在middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的action 进行相应操作，给你一次改变 action 的机会。</p><p>常规的同步数据流模式的流程图如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://sslstatic.ktanx.com/images/release/201811/Tr2gHBdB9tYoeS97.png" alt="f2BVgyd4bOqmbmPx.png](https://sslstatic.ktanx.com/images/release/201811/f2BVgyd4bOqmbmPx.png)不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：![Tr2gHBdB9tYoeS97.png" title>                </div>                <div class="image-caption">f2BVgyd4bOqmbmPx.png](https://sslstatic.ktanx.com/images/release/201811/f2BVgyd4bOqmbmPx.png)不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：![Tr2gHBdB9tYoeS97.png</div>            </figure>每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware 实现变化多样的功能。比如上面的业务，把处理log的代码封装成一个middleware，处理异步的也是一个middleware，两者串联，却又相互独立。</p><p>使用middleware之后，action触发的dispatch并不是原来的dispatch，而是经过封装的new dispatch，在这个new dispatch中，按照顺序依次执行每个middleware，最后调用原生的dispatch。</p><p>来看下logger middleware如何实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action); </span><br><span class="line">    next(action);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里代码十分简洁，就是在next调用下一个middleware之前和之后，分别打印两次。</p><p>Redux 提供了 applyMiddleware 方法来加载 middleware，该方法的源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, initialState</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> store = next(reducer, initialState);</span><br><span class="line">            <span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">            <span class="keyword">let</span> chain = [];</span><br><span class="line">            <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">                getState: store.getState,</span><br><span class="line">                dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action),</span><br><span class="line">            &#125;;</span><br><span class="line">            chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">            dispatch = compose(...chain)(store.dispatch);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...store,</span><br><span class="line">                dispatch,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中compose源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> funcs.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newStore = applyMiddleware([mid1, mid2, mid3, ...])(createStore)(reducer, initialState);</span><br></pre></td></tr></table></figure><p>ok，相关源码已就位，来详细解析一波。</p><p><strong>函数式编程思想设计</strong> ：middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的currying，它是一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个middleware 进行层层调用，动态地将 store 和 next 参数赋值。currying 的 middleware 结构的好处主要有以下两点。</p><ul><li>易串联：currying 函数具有延迟执行的特性，通过不断 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeline 来处理数据流。</li><li> 共享 store: 在 applyMiddleware 执行的过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。</li></ul><p><strong>给 middleware 分发 store</strong>：newStore创建完成之后，applyMiddleware 方法陆续获得了3个参数，第一个是 middlewares 数组[mid1, mid2, mid3, …]，第二个是 Redux 原生的 createStore ，最后一个是 reducer。然后，可以看到 applyMiddleware 利用 createStore 和 reducer 创建了一个 store。而 store 的 getState方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量 store：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line"> getState: store.getState,</span><br><span class="line"> dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action),</span><br><span class="line">&#125;;</span><br><span class="line">chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br></pre></td></tr></table></figure><p>然后，让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍。执行完后，获得 chain数组 [f1, f2, … , fx, …, fn]，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数都可以访问相同的 store，即 middlewareAPI。</p><blockquote><p>middlewareAPI 中的 dispatch 为什么要用匿名函数包裹呢？</p><p>用 applyMiddleware 是为了改造 dispatch，所以 applyMiddleware 执行完后，dispatch 是变化了的，而 middlewareAPI 是 applyMiddleware 执行中分发到各个 middleware 的，所以必须用匿名函数包裹 dispatch，这样只要 dispatch 更新了，middlewareAPI 中的 dispatch 应用也会发生变化。</p></blockquote><p><strong>组合串联 middleware</strong>：这一层只有一行代码，却是 applyMiddleware 精华之所在<code>dispatch = compose(...chain)(store.dispatch);</code>，其中 compose 是函数式编程中的组合，它将 chain 中的所有匿名函数 [f1, f2, … , fx, …, fn]组装成一个新的函数，即新的 dispatch。当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行。</p><p>compose(…funcs) 返回的是一个匿名函数，其中 funcs 就是 chain 数组。当调用 reduceRight时，依次从 funcs 数组的右端取一个函数 fx 拿来执行，fx 的参数 composed 就是前一次 fx+1 执行的结果，而第一次执行的 fn（n 代表 chain 的长度）的参数 arg 就是 store.dispatch。所以，当 compose 执行完后，得到的 dispatch 是这样的，假设 n = 3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = f1(f2(f3(store.dispatch))));</span><br></pre></td></tr></table></figure><p>这时调用新 dispatch，每一个 middleware 就依次执行了。</p><p><strong>在 middleware 中调用 dispatch 会发生什么</strong>：经过 compose 后，所有的 middleware 算是串联起来了。可是还有一个问题，在分发 store 时，提到过每个 middleware 都可以访问 store，即 middlewareAPI 这个变量，也可以拿到 store 的dispatch 属性。那么，在 middleware 中调用 store.dispatch() 会发生什么，和调用 next() 有区别吗？现在来说明两者的不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action);</span><br><span class="line"> next(action);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action);</span><br><span class="line"> store.dispatch(action);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在分发 store 时解释过，middleware 中 store 的 dispatch 通过匿名函数的方式和最终compose 结束后的新 dispatch 保持一致，所以，在 middleware 中调用 store.dispatch() 和在其他任何地方调用的效果一样。而在 middleware 中调用 next()，效果是进入下一个 middleware，下图就是redux middleware最著名的洋葱模型图。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://sslstatic.ktanx.com/images/release/201811/IArjf9kjKecPhnFF.png" alt="IArjf9kjKecPhnFF.png" title>                </div>                <div class="image-caption">IArjf9kjKecPhnFF.png</div>            </figure></p><h2 id="4-combineReducer"><a href="#4-combineReducer" class="headerlink" title="4.combineReducer"></a>4.combineReducer</h2><p>如果一个项目过大，通常按模块来写reducer，但是redux create store只接受一个reducer参数，所以需要合并reducer。这里就用到了redux提供的<code>combineReducer</code>辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">combineReducers(&#123;</span><br><span class="line">      layout,</span><br><span class="line">      home,</span><br><span class="line">      ...asyncReducers</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>这个函数用起来很简单，就是传入一个对象，key是模块reducer对应的名字， 值是对应reducer。值是一个function，相当于是一个新的reducer，源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">var</span> finalReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = reducerKeys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        warning(<span class="string">`No reducer provided for key "<span class="subst">$&#123;key&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> unexpectedKeyCache = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> sanityError</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    assertReducerSanity(finalReducers)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    sanityError = e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sanityError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> sanityError</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)</span><br><span class="line">      <span class="keyword">if</span> (warningMessage) &#123;</span><br><span class="line">        warning(warningMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">var</span> reducer = finalReducers[key]</span><br><span class="line">      <span class="keyword">var</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码不是很多，除去一些验证代码，剩下的就是说：return一个function，暂时称呼他combination，就相当于是与一个总的reducer，每次action都会走到combination中，combination会遍历输入的reducer，将action放到每个reducer中执行一下，计算出返回结果就是nextState，nextState于previousState如果!==说明改变了，返回nextState，否则返回执行之前的state。</p><p>这也解释了不同模块actionType如果相同的话，两个模块的reducer都会走一遍的问题，在actionType名称前面加上模块前缀即可解决问题。</p><h2 id="5-Provider与Connect"><a href="#5-Provider与Connect" class="headerlink" title="5. Provider与Connect"></a>5. Provider与Connect</h2><p>Provider与Connet组件都是React-Redux提供的核心组件，两者看起来功能一样，都是帮助容器组件获取store中的数据，但是原理与功能却不同。</p><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider组件在所有组件的最外层，其接受store作为参数，将store里的state使用context属性向下传递。部分源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> getChildContext() &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line"> <span class="keyword">super</span>(props, context)</span><br><span class="line"> <span class="keyword">this</span>.store = props.store</span><br><span class="line"> &#125;</span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props</span><br><span class="line"> <span class="keyword">return</span> Children.only(children)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用context这个属性，Provider所有子组件均可以拿到这个属性。</p><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>connect实现的功能是将需要关联store的组件和store的dispatch等数据混合到一块，这块就是一个高阶组件典型的应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">if</span> (withRef) &#123;</span><br><span class="line"> <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent, &#123;</span><br><span class="line"> ...this.mergedProps,</span><br><span class="line"> ref: <span class="string">'wrappedInstance'</span></span><br><span class="line"> &#125;)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent,</span><br><span class="line"> <span class="keyword">this</span>.mergedProps</span><br><span class="line"> )</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.renderedElement</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">return</span> hoistStatcis(Connect, WrappedComponent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是先从他的四个参数说起：</p><h4 id="1-mapStateToProps"><a href="#1-mapStateToProps" class="headerlink" title="1.mapStateToProps"></a>1.mapStateToProps</h4><p>connect 的第一个参数定义了需要从 Redux 状态树中提取哪些部分当作 props 传给当前组件。一般来说，这也是使用 connect 时经常传入的参数。事实上，如果不传入这个参数，React 组件将永远不会和 Redux 的状态树产生任何关系。具体在源代码中的表现为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> shouldSubscribe = <span class="built_in">Boolean</span>(mapStateToProps)</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> trySubscribe() &#123;</span><br><span class="line"> <span class="keyword">if</span> (shouldSubscribe &amp;&amp; !<span class="keyword">this</span>.unsubscribe) &#123;</span><br><span class="line"> <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>))</span><br><span class="line"> <span class="keyword">this</span>.handleChange()</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p><p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p><p>这块的源码相对较简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapState = mapStateToProps || defaultMapStateToProps </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line">    computeStateProps(store, props) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.finalMapStateToProps) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.configureFinalMapState(store, props)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> state = store.getState()</span><br><span class="line">        <span class="keyword">const</span> stateProps = <span class="keyword">this</span>.doStatePropsDependOnOwnProps ?</span><br><span class="line">          <span class="keyword">this</span>.finalMapStateToProps(state, props) :</span><br><span class="line">          <span class="keyword">this</span>.finalMapStateToProps(state)</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          checkStateShape(stateProps, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stateProps</span><br><span class="line">      &#125;</span><br><span class="line">      configureFinalMapState(store, props) &#123;</span><br><span class="line">        <span class="keyword">const</span> mappedState = mapState(store.getState(), props)</span><br><span class="line">        <span class="keyword">const</span> isFactory = <span class="keyword">typeof</span> mappedState === <span class="string">'function'</span></span><br><span class="line">        <span class="keyword">this</span>.finalMapStateToProps = isFactory ? mappedState : mapState</span><br><span class="line">        <span class="keyword">this</span>.doStatePropsDependOnOwnProps = <span class="keyword">this</span>.finalMapStateToProps.length !== <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.computeStateProps(store, props)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          checkStateShape(mappedState, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mappedState</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块原理很简单，进行一些参数校验，判断第一个参数mapStateToProps返回值是否为function，如果是递归调用，不是的话算出返回值。如果没传这个参数，默认给{}。</p><blockquote><p>可能会疑惑为什么传给 connect 的第一个参数本身是一个函数，react-redux 还允许这个函数的返回值也是一个函数呢？简单地说，这样设计可以允许在 connect 的第一个参数里利用函数闭包进行一些复杂计算的缓存，从而实现效率优化的目的</p></blockquote><p>当使用的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    home: state.home,</span><br><span class="line">    layout: state.layout</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染</p><h4 id="2-mapDispatchToProps"><a href="#2-mapDispatchToProps" class="headerlink" title="2.mapDispatchToProps"></a>2.mapDispatchToProps</h4><p>人如其名，它接受 store 的 dispatch 作为第一个参数，同时接受 this.props 作为可选的第二个参数。利用这个方法，可以在 connect 中方便地将 actionCreator 与 dispatch 绑定在一起（利用 bindActionCreators 方法），最终绑定好的方法也会作为 props 传给当前组件。这块的源码与mapStateToProps一样，就不贴了。</p><p>bindActionCreator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-mergeProps"><a href="#3-mergeProps" class="headerlink" title="3.mergeProps"></a>3.mergeProps</h4><p>前两个参数返回的对象，都要跟组件自身的props merge一下，形成一个新的对象赋值给对应组件，可以在这一步做一些处理，这个参数就是干这个的，该参数签名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mergeProps(stateProps, dispatchProps, ownProps): props</span><br></pre></td></tr></table></figure><p>默认情况如果没传该参数，返回<code>Object.assign(ownProps, stateProps, dispatchProps)</code>。</p><h4 id="4-options"><a href="#4-options" class="headerlink" title="4.options"></a>4.options</h4><p>如果指定这个参数，可以定制 connector 的行为。</p><ul><li>[<code>pure = true</code>] <em>(Boolean)</em>: 如果为 true，connector 将执行 <code>shouldComponentUpdate</code> 并且浅对比 <code>mergeProps</code> 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。*默认值为 true。*</li><li>[<code>withRef = false</code>] <em>(Boolean)</em>: 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 <code>getWrappedInstance()</code> 方法获得。*默认值为 false。*</li></ul><p>这个connect组件还干了一件事，状态缓存判断。当store变了的时候，前后状态判断，如果状态不等，更新组件，并且完成事件分发。</p><h2 id="6-Redux流程梳理"><a href="#6-Redux流程梳理" class="headerlink" title="6. Redux流程梳理"></a>6. Redux流程梳理</h2><p>上面讲了大量的函数源码，这么些函数之间的关系：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://sslstatic.ktanx.com/images/release/201811/4g40yEqEfjeRqxs6.png" alt="4g40yEqEfjeRqxs6.png" title>                </div>                <div class="image-caption">4g40yEqEfjeRqxs6.png</div>            </figure>初始化阶段：</p><ol><li>createStore创建一个store对象</li><li>将store对象通过参数给Provider组件</li><li>Provider组件将store通过context向子组件传递</li><li>Connect组件通过context获取到store，存入自己的state</li><li>componentDidMount里面订阅store.subscribe事件</li></ol><p>更新数据阶段：</p><ol><li>用户事件触发</li><li>actionCreator生成action交给dispatch</li><li>实际上交给了封装后的中间层（compose(applyMiddleware(…))）</li><li>请求依次通过每个中间件，中间件通过next进行下一步</li><li>最后一个中间件将action交给store.dispatch</li><li>dispatch内部将action交给reducer执行</li><li>combineReducer将每个子reducer执行一遍算出新的state</li><li>dispatch内部调用所有订阅事件</li><li>Connect组件handleChange事件触发判断新state和旧state是否===</li><li>并且判断新的state是否与mapStateToProps shallowEqual</li><li>不等则setState触发更新</li></ol><h2 id="7-Redux设计技巧"><a href="#7-Redux设计技巧" class="headerlink" title="7.Redux设计技巧"></a>7.Redux设计技巧</h2><ol><li><p>匿名函数&amp;&amp;闭包使用</p><p>redux核心函数大量使用了匿名函数和闭包来实现数据共享和状态同步。</p></li><li><p>函数柯里化使用</p><p>使用函数柯里化s实现参数复用，本质上是降低通用性，提高适用性。</p></li><li><p>核心状态读取是拷贝而不是地址</p><p>对于state这种核心状态使用getState()计算出新的state，而不是直接返回一个state对象。</p></li><li><p>观察者订阅者是核心实现</p><p>使用观察者订阅者模式实现数据响应。</p></li><li><p>context这个api的使用</p><p>平时开发不常接触的api实现Provider与Connect通信。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redux使用中的几个点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redux三大设计原则&lt;/li&gt;
&lt;li&gt;Create Store&lt;/li&gt;
&lt;li&gt;Redux middleware&lt;/li&gt;
&lt;li&gt;combineReducer&lt;/li&gt;
&lt;li&gt;Provider与Connect&lt;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入了解useMemo和useCallback</title>
    <link href="https://summxu.github.io/2021/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3useMemo%E5%92%8CuseCallback/"/>
    <id>https://summxu.github.io/2021/深入了解useMemo和useCallback/</id>
    <published>2021-10-31T01:06:38.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>从 <code>useMemo</code> 开始。<code>useMemo</code> 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。</p><p>React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“re-render”。基于当前应用程序状态，每次重新呈现都是应用程序UI在给定时刻应该是什么样子的快照。可以把它想象成一堆照片，每一张照片都记录了给定每个状态变量的特定值时事物的样子。</p><p>每次“re-render”都会根据当前状态在脑海中生成 DOM 应该是什么样子的图像。但实际上它是一堆JS对象，被称为“<strong>virtual DOM</strong>”。</p><p>不直接告诉 React 需要更改哪些 DOM 节点。相反，根据当前状态告诉React UI应该是什么样子。通过重新渲染，React 创建一个新的快照，它可以通过比较快照找出需要更改的内容，就像玩“寻找差异”游戏一样。</p><p>React 在开箱即用时进行了大量优化，所以通常情况下，重新渲染不是什么大问题。但是，在某些情况下，创建这些快照确实需要一些时间。这可能会导致性能问题，比如 UI 在用户执行操作后更新不够快。</p><p>而 <code>useMemo</code> 和 <code>useCallback</code> 是用来帮助优化重渲染的工具。他们通过两种方式做到这一点：</p><ol><li>减少在给定渲染中需要完成的工作量。</li><li>减少组件需要重新呈现的次数。</li></ol><p>让通过下面的栗子来理解它们吧。</p><h2 id="2-示例1：大量的计算"><a href="#2-示例1：大量的计算" class="headerlink" title="2. 示例1：大量的计算"></a>2. 示例1：大量的计算</h2><p>假设正在构建一个工具来帮助用户查找 0 到 <code>selectedNum</code> 之间的所有素数，其中 <code>selectedNum</code> 是用户提供的值。**质数是只能被1和自身整除的数，比如17。**下面是一个可能的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存储用户所选号码的状态。</span></span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算从 0 到用户选择的数字 selectedNum 之间的所有素数</span></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line"></span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:&#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;&#123;allPrimes.join(', ')&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定数字是否是素数的 Helper 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>有一个状态，一个叫做 <code>selectedNum</code> 的数字。使用 <code>for</code> 循环，手动计算 0 到 <code>selectedNum</code> 之间的所有素数。呈现一个受控制的数字输入，因此用户可以更改 <code>selectedNum</code> 。向用户显示计算的所有质数。</p><p>这段代码需要大量的计算。如果用户选择一个较大的 <code>selectedNum</code>，将需要遍历成千上万个数字，检查是否每个数字都是素数。而且，虽然有比我上面使用的更有效的质数检查算法，但它总是需要大量的计算。</p><p>有时确实需要执行这个计算，比如当用户选择一个新的 <code>selectedNum</code> 时。但是可能会遇到一些性能问题，如果在不需要做的时候无偿地做这项工作。</p><p>例如，让假设的例子还包含一个数字时钟:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// time 是一个每秒改变一次的状态变量，因此它总是与当前时间同步。</span></span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算所有质数（与前面的示例相同）</span></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">        &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label htmlFor="num"&gt;Your number:&lt;/</span>label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = React.useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  </span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearInterval(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>的应用程序现在有两个状态，<code>selectedNum</code> 和 <code>time</code>。时间变量每秒更新一次，以反映当前时间，该值用于呈现右上角的数字时钟。</p><p>问题在于：<strong>每当这些状态变量发生变化时，就会重新运行那些昂贵的质数计算。因为时间每秒改变一次，这意味着不断地重新生成质数列表，即使用户选择的数字没有改变！！！</strong></p><p>在 JavaScript 中，只有一个主线程，通过一遍又一遍地运行这段代码让它非常繁忙，每一秒。这意味着当用户尝试做其他事情时，应用程序可能会感到迟缓，特别是在低端设备上。</p><p>但如果可以“跳过”这些计算呢？如果已经有了一个给定数字的质数列表，为什么不重用这个值而不是每次都从头计算呢？这正是 <code>useMemo</code> 允许做的。它看起来是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allPrimes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      result.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;, [selectedNum]);</span><br></pre></td></tr></table></figure><p><code>useMemo</code> 有两个参数：</p><ol><li>要执行的工作块，封装在函数中</li><li>依赖项列表</li></ol><p>在挂载期间，当这个组件第一次呈现时，React 将调用这个函数来运行所有的逻辑，计算所有的质数。无论从这个函数返回什么，都被赋值给 <code>allPrimes</code> 变量。</p><p>然而，对于每一个后续渲染，React 都要做出选择。</p><ol><li>再次调用函数，重新计算值</li><li>重用它上次执行此工作时已经拥有的数据。</li></ol><p>为了做出选择，React 查看提供的依赖项列表。对于之前的渲染有任何改变吗？如果是，React 将重新运行提供的函数，以计算一个新的值。否则，它将跳过所有这些工作并重用之前计算的值。</p><p><code>useMemo</code> 本质上类似于缓存，依赖项是缓存失效策略。在本例中，实际上是在说“只有当 <code>selectedNum</code> 发生变化时才重新计算质数列表”。当组件由于其他原因重新呈现时（例如。当时间状态变量发生变化时），<code>useMemo</code> 忽略函数并传递缓存的值。</p><p>这通常被称为记忆，这就是为什么这个钩子被称为 <code>useMemo</code>。下面是这个解决方案的实时版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> allPrimes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">        result.push(counter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;, [selectedNum]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">        &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label htmlFor="num"&gt;Your number:&lt;/</span>label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = React.useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearInterval(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>useMemo</code> 钩子确实可以帮助避免这里不必要的计算。但它真的是这里的最佳解决方案吗？通常，可以通过重组应用程序中的内容来避免对 <code>useMemo</code> 的需求。可以这样做：</p><ol><li><code>PrimeCalculator.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PrimeCalculator;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Clock.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">      &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useTime() &#123;</span></span><br><span class="line"><span class="regexp">  const [time, setTime] = React.useState(new Date());</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const intervalId = window.setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTime(new Date());</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    return () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      window.clearInterval(intervalId);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  return time;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Clock;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">'./Clock'</span>;</span><br><span class="line"><span class="keyword">import</span> PrimeCalculator <span class="keyword">from</span> <span class="string">'./PrimeCalculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;PrimeCalculator /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>我提取了两个新组件，<code>Clock</code> 和 <code>PrimeCalculator</code>。通过从 <code>App</code> 分支，这两个组件各自管理自己的状态。一个组件中的重新渲染不会影响另一个组件。</p><p>或许你听到很多关于提升状态的说法，但有时，更好的方法是将状态向下推。每个组件应该有一个单独的职责，在上面的例子中，<code>App</code> 正在做两件完全不相关的事情。</p><p>现在，这并不总是一个选择。在一个大型的现实应用中，有许多状态需要向上提升，而不能向下推。对于这种情况，我还有另一个妙计。让看一个例子。假设需要将 <code>time</code> 变量提升到 <code>PrimeCalculator</code> 之上：</p><ol><li><code>PrimeCalculator.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PrimeCalculator;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Clock.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">&#123; time &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">      &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Clock;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getHours &#125; <span class="keyword">from</span> <span class="string">'date-fns'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">'./Clock'</span>;</span><br><span class="line"><span class="keyword">import</span> PrimeCalculator <span class="keyword">from</span> <span class="string">'./PrimeCalculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将的PrimeCalculator转换为一个纯组件</span></span><br><span class="line"><span class="keyword">const</span> PurePrimeCalculator = React.memo(PrimeCalculator);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据一天中的时间选择一个合适的背景色</span></span><br><span class="line">  <span class="keyword">const</span> backgroundColor = getBackgroundColorFromTime(time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; backgroundColor &#125;&#125;&gt;</span><br><span class="line">      &lt;Clock time=&#123;time&#125; /&gt;</span><br><span class="line">      &lt;PurePrimeCalculator /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const getBackgroundColorFromTime = (time) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const hours = getHours(time);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  if (hours &lt; 12) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 早晨用的淡黄色</span></span><br><span class="line"><span class="regexp">    return 'hsl(50deg 100% 90%)';</span></span><br><span class="line"><span class="regexp">  &#125; else if (hours &lt; 18) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 下午暗淡的蓝色</span></span><br><span class="line"><span class="regexp">    return 'hsl(220deg 60% 92%)'</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 夜晚的深蓝色</span></span><br><span class="line"><span class="regexp">    return 'hsl(220deg 100% 80%)';</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useTime() &#123;</span></span><br><span class="line"><span class="regexp">  const [time, setTime] = React.useState(new Date());</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const intervalId = window.setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTime(new Date());</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    return () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      window.clearInterval(intervalId);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  return time;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><code>React.memo</code> 包在组件周围，保护它免受不相关的更新。<code>PurePrimeCalculator</code> 只有在接收到新数据或内部状态发生变化时才会重新呈现。这就是所谓的纯组件。本质上，告诉 React 这个组件将总是在相同的输入条件下产生相同的输出，可以跳过没有任何改变的重新呈现。</p><p>在上面的例子中，我应用了 <code>React.memo</code> 到导入的 <code>PrimeCalculator</code> 组件。事实上,我选择了这样的结构，以便所有内容都在同一个文件中可见，以便更容易理解。在实践中，使用 <code>React.memo</code> 组件导出，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrimeCalculator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 这里的组件内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(PrimeCalculator);</span><br></pre></td></tr></table></figure><p>的 <code>PrimeCalculator</code> 组件现在将始终是纯的，当要使用它时，不需要对它进行修补。</p><p>这里有一个视角转换：之前，在记忆一个特定计算的结果，计算质数。然而，在本例中，我记住了整个组件。无论哪种方式，只有当用户选择一个新的 <code>selectedNum</code> 时，昂贵的计算才会重新运行。但优化的是父组件，而不是特定的慢代码行。</p><p>我并不是说一种方法比另一种更好；每种工具在工具箱中都有自己的位置。但在这个特定的情况下，我更喜欢这种方法。现在，如果您曾经尝试在现实世界的设置中使用纯组件，您可能会注意到一些特殊的东西：纯组件经常重新渲染相当多，即使看起来没有任何变化！这很好地将引入了 <code>useMemo</code> 解决的第二个问题。</p><h2 id="3-示例2：保留引用"><a href="#3-示例2：保留引用" class="headerlink" title="3. 示例2：保留引用"></a>3. 示例2：保留引用</h2><p>在下面的示例中，我创建了一个 <code>Boxes</code> 组件。它展示了一组彩色的盒子，用于某种装饰目的。我还有一个不相关的状态：用户名。</p><ol><li><code>Boxes.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Boxes</span>(<span class="params">&#123; boxes &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"boxes-wrapper"</span>&gt;</span><br><span class="line">      &#123;boxes.map(<span class="function">(<span class="params">boxStyles, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;div</span><br><span class="line">          key=&#123;index&#125;</span><br><span class="line">          className=<span class="string">"box"</span></span><br><span class="line">          style=&#123;boxStyles&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default React.memo(Boxes);</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Boxes <span class="keyword">from</span> <span class="string">'./Boxes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = React.useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [boxWidth, setBoxWidth] = React.useState(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> id = React.useId();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 尝试改变这些值</span></span><br><span class="line">  <span class="keyword">const</span> boxes = [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Boxes boxes=&#123;boxes&#125; /&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;label htmlFor=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-name`</span>&#125;&gt;</span><br><span class="line">          Name:</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          id=&#123;`$&#123;id&#125;-name`&#125;</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          value=&#123;name&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(event) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setName(event.target.value);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;label htmlFor=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-box-width`</span>&#125;&gt;</span><br><span class="line">          First box width:</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          id=&#123;`$&#123;id&#125;-box-width`&#125;</span></span><br><span class="line"><span class="regexp">          type="range"</span></span><br><span class="line"><span class="regexp">          min=&#123;1&#125;</span></span><br><span class="line"><span class="regexp">          max=&#123;5&#125;</span></span><br><span class="line"><span class="regexp">          step=&#123;0.01&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;boxWidth&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(event) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setBoxWidth(Number(event.target.value));</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>由于在 <code>boxes.js</code> 中使用了<code>React.memo()</code> 封装默认导出，<code>Boxes</code> 是一个纯组件。这意味着它应该只在它的<code>props</code>改变时重新渲染。然而，每当用户更改其名称时，<code>Boxes</code> 也会重新呈现。</p><p>为什么的 <code>React.memo()</code> 没有保护？盒子组件只有1个<code>prop</code>，盒子，它看起来好像给它在每次渲染完全相同的数据。总是一样的东西：一个红盒子，一个紫色的宽盒子，一个黄色的盒子。确实有一个影响<code>boxes</code> 数组的 <code>boxWidth</code> 状态变量，但没有更改它！</p><p>问题在于：每次 React 重新渲染时，都会生成一个全新的数组。它们在值上是相等的，但在参照物上是不同的。我想如果先不谈 React，只谈普通的 JavaScript，会很有帮助。让来看一个类似的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> firstResult = getNumbers();</span><br><span class="line"><span class="keyword">const</span> secondResult = getNumbers();</span><br><span class="line"><span class="built_in">console</span>.log(firstResult === secondResult);</span><br></pre></td></tr></table></figure><p>你怎么看？<code>firstResult</code> 是否等于 <code>secondResult</code>？从某种意义上说，的确如此。两个变量都具有相同的结构<code>[1,2,3]</code>。但这不是 <code>===</code> 运算符实际检查的内容。相反，<code>===</code> 检查两个表达式是否相同。已经创建了两个不同的数组。它们可能包含相同的内容，但它们不是同一个数组。</p><p>每次调用 <code>getNumbers</code> 函数时，都会创建一个全新的数组，它是保存在计算机内存中的一个不同的东西。如果多次调用它，将在内存中存储该数组的多个副本。注意，简单的数据类型——比如<strong>字符串</strong>、<strong>数字</strong>和<strong>布尔值</strong>——可以按值进行比较。但是当涉及到<strong>数组</strong>和<strong>对象</strong>时，它们只能通过<strong>引用</strong>进行比较。</p><p>让回到 React：的 <code>Boxes</code> React组件也是一个 JavaScript 函数。当渲染它时，调用那个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次渲染这个组件时，调用这个函数…</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最后创造了一个全新的数组</span></span><br><span class="line">  <span class="keyword">const</span> boxes = [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// .然后将其作为 prop 传递给该组件!</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Boxes boxes=&#123;boxes&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当名称状态改变时，的 <code>App</code> 组件将重新呈现，这将重新运行所有的代码。构造一个全新的 <code>boxes</code> 数组，并将其传递给的 <code>Boxes</code> 组件。从而导致盒子重新渲染，因为给了它一个全新的数组。盒子数组的结构在渲染之间没有改变，但这无关紧要。React 所知道的是，箱子 <code>prop</code> 已经收到了一个新创建的，从未见过的数组。要解决这个问题，可以使用 <code>useMemo</code> hook：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boxes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;, [boxWidth]);</span><br></pre></td></tr></table></figure><p>与之前看到的质数例子不同，这里不担心计算成本很高的计算。的唯一目标是<strong>保留对特定数组的引用</strong>。将 <code>boxWidth</code> 列为一个依赖项，因为确实希望在用户调整红色框的宽度时重新呈现 <code>Boxes</code> 组件。然而，在 <code>useMemo</code> 中，重用了之前创建的 <code>boxes</code> 数组。</p><p>通过在多个渲染中保留相同的引用，允许纯组件按希望的方式工作，忽略不影响 UI 的渲染。</p><h2 id="4-useCallback"><a href="#4-useCallback" class="headerlink" title="4. useCallback"></a>4. useCallback</h2><p>前面了解了 <code>useMemo</code>。那 <code>useCallback</code> 呢？这是一个简短的版本：<strong>这是完全相同的事情，但用于函数而不是数组/对象</strong>。与数组和对象类似，函数是根据引用比较的，而不是根据值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functionOne = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> functionTwo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(functionOne === functionTwo); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这意味着，如果在组件中定义一个函数，它将在每次渲染时重新生成，每次生成一个相同但唯一的函数。让看一个例子：</p><ol><li><code>MegaBoost.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MegaBoost</span>(<span class="params">&#123; handleClick &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Render MegaBoost'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">      className=<span class="string">"mega-boost-button"</span></span><br><span class="line">      onClick=&#123;handleClick&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      MEGA BOOST!</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default React.memo(MegaBoost);</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MegaBoost <span class="keyword">from</span> <span class="string">'./MegaBoost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleMegaBoost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          setCount(count + <span class="number">1</span>)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Click me!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MegaBoost handleClick=&#123;handleMegaBoost&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>这个栗子描述了一个典型的计数器应用程序，但有一个特殊的“Mega Boost”按钮。这个按钮大大增加了计数，以防你很匆忙，不想多次点击标准按钮。</p><p>多亏了 <code>React.memo</code>, <code>MegaBoost</code> 组件是一个纯组件。它不依赖于计数，但每当计数改变时它就会重新呈现！就像看到的盒子数组，这里的问题是在每个渲染上生成一个全新的函数。如果渲染 3 次，将创建 3 个单独的 <code>handleMegaBoost</code> 函数，突破 <code>React.memo</code>的保护。利用对 <code>useMemo</code> 的了解，可以像这样解决问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleMegaBoost = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>返回的不是一个数组，而是一个函数。然后将此函数存储在 <code>handleMegaBoost</code> 变量中。这很有效，但还有更好的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleMegaBoost = React.useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><code>useCallback</code> 的作用与 <code>useMemo</code> 相同，但它是专门为函数构建的。直接给它一个函数，它记住那个函数，在渲染之间进行线程处理。换句话说，这两个表达有相同的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.useCallback(<span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;&#125;, []);</span><br><span class="line"><span class="comment">// 在功能上等价于</span></span><br><span class="line">React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;&#125;, []);</span><br></pre></td></tr></table></figure><p><code>useCallback</code> 是语法糖。它的存在纯粹是为了让在记忆回调函数时更加方便。</p><h2 id="5-什么时候使用这些-hook"><a href="#5-什么时候使用这些-hook" class="headerlink" title="5. 什么时候使用这些 hook"></a>5. 什么时候使用这些 hook</h2><p>好了，已经看到了 <code>useMemo</code> 和 <code>useCallback</code> 如何允许跨多个渲染线程引用重用复杂的计算或避免破坏纯组件。问题是：应该多经常使用它？</p><p>在我个人看来，将每个对象/数组/函数包装在这些钩子中是浪费时间。在大多数情况下，好处是可以忽略不计的；React 是高度优化的，重新渲染通常不像通常认为的那样缓慢或昂贵！</p><p>使用这些钩子的最佳方式是响应问题。如果你注意到你的应用程序变得有点迟缓，你可以使用 <code>React Profiler</code> 来查找缓慢的渲染。在某些情况下，可以通过重构应用程序来提高性能。在其他情况下，<code>useMemo</code> 和<code>useCallback</code> 可以帮助加快速度。</p><h3 id="5-1-用于自定义-hook-内部"><a href="#5-1-用于自定义-hook-内部" class="headerlink" title="5.1 用于自定义 hook 内部"></a>5.1 用于自定义 hook 内部</h3><p>例如下面这个自定义 hook <code>useToggle</code>，它的工作方式几乎和 <code>useState</code> 完全一样，但只能在 <code>true</code> 和 <code>false</code> 之间切换状态变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isDarkMode, toggleDarkMode] = useToggle(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;toggleDarkMode&#125;&gt;</span><br><span class="line">      Toggle color theme</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>下面是如何定义这个自定义 hook 的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useToggle</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(initialValue);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> toggle = React.useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(<span class="function"><span class="params">v</span> =&gt;</span> !v);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [value, toggle];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>toggle</code> 函数是用 <code>useCallback</code> 记忆的。当我构建这样的自定义可重用钩子时，我希望使它们尽可能高效，因为我不知道将来会在哪里使用它们。在95%的情况下，这可能是多余的，但如果我使用这个钩子30或40次，这很有可能有助于提高应用程序的性能。</p><h3 id="5-2-在-context-提供者"><a href="#5-2-在-context-提供者" class="headerlink" title="5.2 在 context 提供者"></a>5.2 在 context 提供者</h3><p>当在具有 <code>context</code> 的应用程序之间共享数据时，通常会传递一个大对象作为 <code>value</code> 属性。记住这个对象通常是个好主意：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AuthContext = React.createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AuthProvider</span>(<span class="params">&#123; user, status, forgotPwLink, children &#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedValue = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user,</span><br><span class="line">      status,</span><br><span class="line">      forgotPwLink,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [user, status, forgotPwLink]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider value=&#123;memoizedValue&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/AuthContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>为什么这是有益的？可能有几十个纯组件使用这个上下文。如果没有 <code>useMemo</code>，如果 <code>AuthProvider</code> 的父组件碰巧重新渲染，那么所有这些组件都将被迫重新渲染。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从 &lt;code&gt;useMemo&lt;/code&gt; 开始。&lt;code&gt;useMemo&lt;/code&gt; 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。&lt;/p&gt;
&lt;p&gt;React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue的响应式原理</title>
    <link href="https://summxu.github.io/2021/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://summxu.github.io/2021/Vue的响应式原理/</id>
    <published>2021-05-07T01:07:32.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue2使用Object-defineProperty实现响应式"><a href="#vue2使用Object-defineProperty实现响应式" class="headerlink" title="vue2使用Object.defineProperty实现响应式"></a>vue2使用Object.defineProperty实现响应式</h2><ul><li>遍历属性，对每一个属性的值用Object.defineProperty进行getter和setter的改造；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">data, key</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get data:'</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">data, key, value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'set data:'</span>, key,<span class="string">'-'</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">    <span class="keyword">let</span> value = data[key]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>()&#123;</span><br><span class="line">        track(data, key)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">        trigger(data, key, newVal)</span><br><span class="line">        value = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'object'</span>)&#123;</span><br><span class="line">      observe(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'win'</span>,</span><br><span class="line">  family: [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(obj)</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'ten'</span></span><br><span class="line">obj.family[<span class="number">3</span>] = <span class="number">6</span> <span class="comment">//不是响应式，没有被Object.defineProperty包装一下</span></span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">//不是响应式，没有被Object.defineProperty包装一下</span></span><br><span class="line"><span class="built_in">console</span>.log(obj, <span class="string">'obj'</span>)</span><br></pre></td></tr></table></figure><p>Vue3相对于Vue2响应式原理也发生了变化，由原先的 <code>Object.defineproperty</code> 改成了使用 <code>Proxy</code> 替代。<code>Proxy</code> 相对于 <code>Object.defineproperty</code> 有以下几个优化点：</p><ul><li>对象新增属性不再需要手动 <code>$set</code> 添加响应式，<code>Proxy</code> 默认会监听动态添加属性和属性的删除等操作。</li><li>消除无法监听数组索引，length 属性等等，不再需要在数组原型对象上重写数组的方法。</li><li><code>Object.defineproperty</code> 是劫持所有对象属性的 <code>get</code>/<code>set</code> 方法,需要遍历递归去实现，<code>Proxy</code> 是代理整个对象。</li><li>Vue2 只能拦截对象属性的 <code>get</code> 和 <code>set</code> 操作,而 <code>Proxy</code> 拥有 <code>13</code> 种拦截方法。</li></ul><h2 id="Vue3中的响应式原理"><a href="#Vue3中的响应式原理" class="headerlink" title="Vue3中的响应式原理"></a>Vue3中的响应式原理</h2><p>实现原理：</p><p>通过Proxy（代理）： 拦截对象中任意属性的变化，包括：属性值的读写，属性的增加，属性的删除等。</p><p>通过Reffect（反射）： 对源对象的属性进行操作</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul><li>Proxy对象对于创建一个对象的代理，也可以理解成在对象前面设了一层拦截，<strong>可以实现基本操作的拦截和一些自定义操作（比如一些赋值、属性查找、函数调用等）；</strong></li><li>用法：<code>var proxy = new Proxy(target, handler);</code><br><strong>target：</strong>目标函数（即进行改造的函数）；<br><strong>handler：</strong>一些自定义操作（比如vue中getter和setter的操作）；</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li>Reflect是es6为操作对象而提供的新API，设计它的目的有：<br>① 把Object对象上一些明显属于语言内部的方法放到Reflect对象身上，比如Object.defineProperty；<br>② 修改了某些object方法返回的结果；<br>③ 让Object操作都变成函数行为；<br>④ Reflect对象上的方法和Proxy对象上的方法一一对应，这样就可以让Proxy对象方便地调用对应的Reflect方法；</li><li><code>Reflect.get(target, propertyKey, receiver)</code>：<strong>等价于<code>target[propertyKey]</code>，</strong>Reflect.get方法查找并返回target对象的propertyKey属性，如果没有该属性，则返回undefined。</li><li><code>Reflect.set(target, propertyKey, value, receiver)</code>：<strong>等价于<code>target[propertyKey] = value</code>，</strong>Reflect.set方法设置target对象的propertyKey属性等于value。</li></ul><h3 id="Proxy和Reflect的使用"><a href="#Proxy和Reflect的使用" class="headerlink" title="Proxy和Reflect的使用"></a>Proxy和Reflect的使用</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'win'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get--'</span>, key)</span><br><span class="line">    <span class="keyword">return</span> Reflect.get(...arguments)  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set--'</span>, key, <span class="string">'='</span>, value)</span><br><span class="line">    <span class="keyword">return</span> Reflect.set(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> Proxy(obj, handler)</span><br><span class="line">data.name = <span class="string">'ten'</span></span><br><span class="line"><span class="built_in">console</span>.log(data.name,<span class="string">'data.name22'</span>)</span><br></pre></td></tr></table></figure><h2 id="使用Proxy和Reflect完成响应式"><a href="#使用Proxy和Reflect完成响应式" class="headerlink" title="使用Proxy和Reflect完成响应式"></a>使用Proxy和Reflect完成响应式</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get--'</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key, value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'set--'</span>, key, <span class="string">'='</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key, receiver)&#123;</span><br><span class="line">      track(target, key)</span><br><span class="line">      <span class="keyword">const</span> value = Reflect.get(...arguments)</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reactive(value)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, val, receiver)&#123;</span><br><span class="line">      trigger(target, key, val)</span><br><span class="line">      <span class="keyword">return</span> Reflect.set(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'win'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = reactive(obj)</span><br><span class="line"></span><br><span class="line">data.list = [<span class="number">5</span>] <span class="comment">//响应式  这两句话是执行Reflect.set()</span></span><br><span class="line">data.age = <span class="number">18</span> <span class="comment">//响应式</span></span><br><span class="line"><span class="built_in">console</span>.log(data, <span class="string">'data111'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue2使用Object-defineProperty实现响应式&quot;&gt;&lt;a href=&quot;#vue2使用Object-defineProperty实现响应式&quot; class=&quot;headerlink&quot; title=&quot;vue2使用Object.defineProperty实
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ReactNative踩坑记</title>
    <link href="https://summxu.github.io/2020/ReactNative%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://summxu.github.io/2020/ReactNative踩坑记/</id>
    <published>2020-07-21T04:16:24.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近在使用react-native的时候遇到了很多坑-这里记录一下"><a href="#最近在使用react-native的时候遇到了很多坑-这里记录一下" class="headerlink" title="最近在使用react-native的时候遇到了很多坑,这里记录一下"></a>最近在使用react-native的时候遇到了很多坑,这里记录一下</h2><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>react-native 虽然支持flex布局，但是所有的样式均是css样式的一个很小的集合，尤其是在安卓机下问题尤为凸显：</p><ol><li><p>View内部的元素千万不要超出父级的范围，iso上问题倒是不大，安卓上就什么超出的都看不到了</p></li><li><p>lineHeight 可以用，不过千万不要写成小数，否则安卓上会直接崩溃</p></li><li><p>rn的样式不存在继承的情况，所以基本上每个节点都要写style，真的是体力活</p></li><li><p>如果Text的父级元素设置了背景颜色，那么ios下Text的背景颜色也是父级的背景颜色，要么自己写个Text重置下样式，要么就遇到了再改</p></li><li><p>react-native的字号是没有设置单位的，所以会随着系统设置的字体大小而变化，我也不知道这是不是坑，不过貌似有的app也没有管这个，如果硬要去设置Text的文字不随系统改变，安卓是可以统一设置的，ios上Text设置allowFontScaling ={false}就可以解决</p></li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>react-native 在发生js异常的时候，debug的时候会直接红屏幕，但是再release的时候直接会崩溃退出，解决办法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ErrorUtils <span class="keyword">from</span> <span class="string">"ErrorUtils"</span> &lt;br&gt;<span class="comment">//这里应该做个判断，如果不是debug的才做这样的异常全局处理</span></span><br><span class="line">ErrorUtils.setGlobalHandler(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;&lt;br&gt;　　<span class="comment">//发生异常的处理方法,当然如果是打包好的话可能你找都找不到是哪段代码出问题了</span></span><br><span class="line">　　Alert.alert(<span class="string">"异常"</span>,<span class="built_in">JSON</span>.stringify(e))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>react-native虽然自带有fetch，不过在使用的时候发现了一个问题，如果需要获取http的header头的时候问题就来了，可能得到的是一些千奇百怪的样式，这并不是react-native的错，而是第三方的 whatwg-fetch 留下的坑，当然也有人再github上跟react-native反映过这个问题，不过得到的解决方案都很坑，唯有一个办法，就是拷贝自己修改，修改如下:</p><ol><li><p>注释该注释的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">　　 <span class="comment">//注释这里，不然总是用的是全局的fetch</span></span><br><span class="line">    <span class="comment">// if (self.fetch) &#123;</span></span><br><span class="line">    <span class="comment">//     return</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>修改该修改的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHeaders</span>(<span class="params">rawHeaders</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> headers = <span class="keyword">new</span> Headers()&lt;br&gt;　　　　　<span class="comment">//把\t\n改成\t，因为一般header都是用\n来分割的</span></span><br><span class="line">    rawHeaders.split(<span class="string">'\n'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//rawHeaders.split('\t\n').forEach(function(line) &#123;</span></span><br><span class="line">            <span class="keyword">var</span> parts = line.split(<span class="string">':'</span>)</span><br><span class="line">            <span class="keyword">var</span> key = parts.shift().trim()</span><br><span class="line">            <span class="keyword">if</span> (key) &#123;</span><br><span class="line">                <span class="keyword">var</span> value = parts.join(<span class="string">':'</span>).trim()</span><br><span class="line">                headers.append(key, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接import你改好的文件，fetch就可以用了</p></li></ol><h2 id="Modal"><a href="#Modal" class="headerlink" title="Modal"></a>Modal</h2><p>Mode控件在使用的时候要注意了，因为这个是rn提供的，并且也写的很清楚是最高层级的一个弹出层，所以你想要又打开Model又要跳转基本是无望的了，所以建议不要使用这个，最好是使用第三方的控件，我们用的是 react-native-modalbox + 高阶控件 实现的全遮盖的弹出层</p><h2 id="点击屏幕其他位置关闭的菜单"><a href="#点击屏幕其他位置关闭的菜单" class="headerlink" title="点击屏幕其他位置关闭的菜单"></a>点击屏幕其他位置关闭的菜单</h2><p>这类菜单有个共同的特点就是点击屏幕其他地方然后菜单就关闭，我们的解决办法就是用自己写的 react-native-modalbox + 高阶控件 也就是说放在一个弹出层里面，当然可以试试把当前页面套进一个大的 TouchableWithoutFeedback 里面</p><h2 id="接口请求"><a href="#接口请求" class="headerlink" title="接口请求"></a>接口请求</h2><p>非特殊情况下都应该这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;InteractionManager&#125; <span class="keyword">from</span> <span class="string">"react-native"</span></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">  InteractionManager.runAfterInteractions(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fetch(<span class="string">"xxx.xxx.xxx"</span>,&#123;&#125;)</span><br><span class="line">    &#125;);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>官方提供的自定义隐藏键盘的方法是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Keyboard &#125; <span class="keyword">from</span> <span class="string">'react-native'</span></span><br><span class="line">Keyboard.dismiss()</span><br></pre></td></tr></table></figure><p>但是我试了很多次之后发现根本不能，而且还报错，楼主的react-native版本是0.35.0</p><p>看了官方的issue才知道这个不行，推荐下面方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dismissKeyboard <span class="keyword">from</span> <span class="string">'dismissKeyboard'</span>dismissKeyboard()</span><br></pre></td></tr></table></figure><p>这样就可以隐藏了，太坑了</p><p>还有个很坑的地方，官方提供的移除键盘事件的方法不可用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;　　Keyboard.addListener(<span class="string">'keyboardDidShow'</span>, <span class="keyword">this</span>.keyboardDidShow.bind(<span class="keyword">this</span>))　　Keyboard.addListener(<span class="string">'keyboardDidHide'</span>, <span class="keyword">this</span>.keyboardDidHide.bind(<span class="keyword">this</span>))&#125;componentWillUnmount () &#123;</span><br><span class="line">    Keyboard.removeAllListeners(<span class="string">'keyboardDidShow'</span>)</span><br><span class="line">    Keyboard.removeAllListeners(<span class="string">'keyboardDidHide'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的方式特么的如果操作快了，或者有时候莫名其妙的就会出错,下面的才是正确的打开方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">　　<span class="keyword">this</span>.keyboardDidShowListener = Keyboard.addListener(<span class="string">'keyboardDidShow'</span>, <span class="keyword">this</span>.keyboardDidShow.bind(<span class="keyword">this</span>))</span><br><span class="line">　　<span class="keyword">this</span>.keyboardDidHideListener = Keyboard.addListener(<span class="string">'keyboardDidHide'</span>, <span class="keyword">this</span>.keyboardDidHide.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidShowListener.remove()</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidHideListener.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>https这个问题上ios还好，安卓问题就来了，前期我们准备将ajax请求的库丢给原生安卓和ios来做我们直接调用就是了，但是后来发现问题这样那样的问题太多了，</p><p>所以在热更新服务器启动或者打包的时候就把源代码先改了在进行打包或者启动服务器</p><p>文件位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java</span><br></pre></td></tr></table></figure><p>这个文件的最后一个方法修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> OkHttpClient createClient() &#123;</span><br><span class="line">  <span class="comment">// No timeouts by default</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">  .sslSocketFactory(sslContext.getSocketFactory())</span><br><span class="line">  .hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public boolean verify(<span class="built_in">String</span> hostname, SSLSession session) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//忽略所有的认证，直接返回了true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    .connectTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .readTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .writeTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .cookieJar(<span class="keyword">new</span> ReactCookieJarContainer())</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改源代码的方式有点略坑，不过可以解决很多问题，还节约时间！！！</p><h2 id="BackAndroid"><a href="#BackAndroid" class="headerlink" title="BackAndroid"></a>BackAndroid</h2><p>安卓机有独特的点击按键返回，所以在最外层会注册一个监听方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bindHardwareBackPress()&#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">        BackAndroid.addEventListener(<span class="string">'hardwareBackPress'</span>, <span class="keyword">this</span>._onHomeBackPress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">onHomeBackPress()&#123;</span><br><span class="line">    <span class="keyword">let</span> routeList = <span class="keyword">this</span>.getRouteList();</span><br><span class="line">    <span class="keyword">if</span> (routeList.length !== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.navigator.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.handleHomeBackPress();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">handleHomeBackPress()&#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">"android"</span>) &#123;</span><br><span class="line">        ToastAndroid.show(<span class="string">"再按一次退出应用"</span>, ToastAndroid.SHORT);</span><br><span class="line">        BackAndroid.removeEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onHomeBackPress);</span><br><span class="line">        BackAndroid.addEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onExitApp);</span><br><span class="line">        <span class="keyword">this</span>.timer = TimerMixin.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            TimerMixin.clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">            BackAndroid.removeEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onExitApp);</span><br><span class="line">            BackAndroid.addEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onHomeBackPress);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exitApp()&#123;</span><br><span class="line">    BackAndroid.exitApp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是监听返回键，如果不是在最外层的路由就返回上一个,如果在最外层就直接关闭app，但是有很多这样那样的需求要去对安卓的返回键进行操作，坑就来了，你以为提供的removeEventListener方法是没问题的？no ！！！ 他会移除所有的监听，这是不是很坑！！！！</p><p>所以：<strong>在需要对安卓返回键进行特殊处理的时候记得其他地方做了监听的再重新监听一次！！！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最近在使用react-native的时候遇到了很多坑-这里记录一下&quot;&gt;&lt;a href=&quot;#最近在使用react-native的时候遇到了很多坑-这里记录一下&quot; class=&quot;headerlink&quot; title=&quot;最近在使用react-native的时候遇到了很多坑
      
    
    </summary>
    
    
    
      <category term="ReactNative" scheme="https://summxu.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存-ETag</title>
    <link href="https://summxu.github.io/2019/http-cache-etag/"/>
    <id>https://summxu.github.io/2019/http-cache-etag/</id>
    <published>2019-08-10T12:44:11.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。</p></blockquote><h2 id="ETag验证缓存的响应"><a href="#ETag验证缓存的响应" class="headerlink" title="ETag验证缓存的响应"></a>ETag验证缓存的响应</h2><p>在本地通过 express 启了一个非常简单的个服务，具体如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello http'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://127.0.0.1:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是仔细看却发现，第一次进入页面<strong><a href="http://127.0.0.1:3000/" target="_blank" rel="noopener">http://127.0.0.1:3000/</a></strong>时，Status为200而再次刷新发现Status却是304</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-e14290fe5a1aaa4b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-f19b1eb12e8d8cc4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>仔细对比发现</p><ol><li>第一次请求时候请求参数中并没有 If-None-Match 字段但是却有个Pragma；同时在请求的Response中有一个 <strong>ETag: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg”</strong>字段。</li><li>刷新页面后再次请求在请求头中却有个 *<em>If-None-Match: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg” *</em>，If-None-Match 的值和第一次请求的ETag的值相同。</li></ol><p>经过查询才了解原理浏览器会根据HTTP请求的ETag验证请求的资源是否发生了改变，如果它未发生变化，服务器将返回“304 Not Modified”响应，并且资源从浏览器缓存中读取，这样就不必再次下载请求。</p><p>由此看来整个的过程就是下面这样：</p><ol><li>如果缓存中有ETag 令牌，客户端请求时会自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。</li><li>服务器根据当前资源核对令牌，验证是否发生变化，将验证结果通知给客户端，客户端根据结果看看是否需要从缓存中读取还是发送资源请求。</li></ol><p>补充一个很直白的 <a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">TCP协议的三次握手</a> 的理解。</p><p>为了验证查证的结果，我又添加一个请求处理。这个过程是，客户端明确返回一个ETag, 但是这里每次请求的的返回值都不相同，这里简单的使用了个<strong>etag++</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello http'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证ETag</span></span><br><span class="line"><span class="keyword">let</span> etag = <span class="number">0</span>;</span><br><span class="line">app.get(<span class="string">'/test'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  etag++;</span><br><span class="line">  res.set(<span class="string">'ETag'</span>, etag);</span><br><span class="line">  res.send(<span class="string">'ETag'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://127.0.0.1:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-71230f0ad656f455.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>查看下 /test 地址的请求结果，会发现If-None-Match 的值和 Response中的 ETag值每次都不相同，并且是 浏览器会将每次的 ETag 值都缓存起来在下次请求的时候发送给服务器。这样一来，每次服务器每次校验的值都是不相同的，所以这种就没有做缓存，因此每次请求 /test 地址都是 200 的状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 
      
    
    </summary>
    
    
    
      <category term="网络" scheme="https://summxu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>fixed 定位失效 与 CSS 层叠上下文</title>
    <link href="https://summxu.github.io/2019/fixed-stacking-context/"/>
    <id>https://summxu.github.io/2019/fixed-stacking-context/</id>
    <published>2019-05-22T15:38:51.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分，position: fixed失效的问题；<br>第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。</p><h1 id="关于-position-fixed"><a href="#关于-position-fixed" class="headerlink" title="关于 position: fixed"></a>关于 position: fixed</h1><p><strong>position: fixed</strong> 在日常布局中比较常用，如移动端头部和底部导航定位、模态框、悬浮按钮等，设置了这个属性值得元素会相对于屏幕视口（viewport）进行定位，其位置在屏幕进行滚动时会保持不变，不占用文档流中的位置，而且打印时这个元素会出现在 每一页 的相同位置。设置了 <strong>position: fixed</strong> 的元素最终的位置由它的 <strong>top, right, bottom, left</strong> 来决定，这个值会创建一个新的 <strong>stacking context</strong><br>但是，有些情况下，这种定位方式会失效，使得元素相对于视窗定位的定位不符合预期（其实是 <strong>fixed</strong> 定位的参考元素变了）。当该元素的父元素中（广义，包含祖先元素）有元素的 <strong>transform</strong> 或 <strong>perspective</strong> 的值不是 <strong>none</strong>，该元素就会相对于这个父元素而不是视口进行定位。<br>具体的原因是这样：</p><blockquote><p>Specifying a value other than none for the transform property establishes a new local coordinate system at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element’s transformation matrix. Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent. From the perspective of the user, an element effectively accumulates all the transform properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a current transformation matrix for the element.</p></blockquote><p>解释一下，<strong>transform</strong> 或 perspective 的非 none 值会影响元素的包含块和层叠上下文，这些值会在应用它的元素上建立一个局部的坐标系（X轴向右水平增加; Y轴垂直向下增加），由变换矩阵（<strong>transform</strong> 的值）给出元素到该局部坐标系的映射，而且 <strong>transform</strong> 带来的局部坐标系的改变是可以累积的——也就是说，子元素会在它的父元素的坐标系内建立子元素自己的局部坐标系：<br>父元素的 <strong>transform</strong> 们一层层积累定义了子元素当前的变换矩阵（一个元素的变换矩阵是从 <strong>transform</strong> 和 <strong>transform</strong>-origin 属性中计算出来的），步骤如下：</p><ul><li>通过 <strong>transform-origin</strong> 的值对坐标原点 X 和 Y 的位置进行转换</li><li>以变换后的 X、Y 为坐标原点原点，根据 <strong>transform</strong> 的属性值进行变换</li><li>X 和 Y 根据 <strong>transform-origin</strong> 的相反值平移回去</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180102175637761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGFuZGFfbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="如图" title>                </div>                <div class="image-caption">如图</div>            </figure><p><strong>transform</strong> 会影响最终的渲染效果，但是不影响除overflow外的CSS布局，当通过 <strong>getClientRects()</strong>、<strong>getBoundingClientRect()</strong> 这些接口获取 <strong>client rectangles</strong> 时，<strong>transform</strong> 的效果也会被考虑进去。</p><p>可以应用 <strong>transform</strong> 的元素（<strong>transformable elements</strong>）有：</p><ul><li>满足CSS盒模型的块级元素或行内元素，或者它的 display 值为 table-row, table-row-group, table-header-group, table-footer-group, table-cell, table-caption 中的一个</li><li>SVG 命名空间中具有 transform, patternTransform 或 gradientTransform 属性的元素</li></ul><p>p.s. 关于上面的应用<strong>transform</strong>后元素位置的计算方式。原文如下：</p><ol><li>Start with the identity matrix.</li><li>Translate by the computed X and Y of transform-origin</li><li>Multiply by each of the transform functions in transform property from left to right</li><li>Translate by the negated computed X and Y values of transform-origin</li></ol><p>参考文档：</p><p><a href="https://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="noopener">The transform Property - W3C Working Draft - 30 November 2017</a></p><p><a href="https://www.w3.org/TR/css-transforms-1/#transform-rendering" target="_blank" rel="noopener">The Transform Rendering Model - W3C Working Draft - 30 November 2017</a></p><h1 id="层叠上下文-Stacking-Context"><a href="#层叠上下文-Stacking-Context" class="headerlink" title="层叠上下文 Stacking Context"></a>层叠上下文 Stacking Context</h1><p>通过上文我们知道了有层叠上下文这么一个东西，层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。和BFC还有IFC这些xx context一样，创建层叠上下文也是有条件的，文档中的层叠上下文由满足以下任意一个条件的元素形成：</p><ul><li>根元素 (HTML),</li><li>z-index 值不为 auto 的 绝对/相对定位元素</li><li>position 不是 static 的元素（sticky 也会创建层叠上下文，这是一个神奇的实验中的属性值）</li><li>一个 z-index 值不为 auto 的 flex 项目 (flex item)</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity）</li><li>transform 属性值不为 none 的元素</li><li>mix-blend-mode 属性值不为 normal 的元素</li><li>有 transform、filter、perspective、clip-path、mask / mask-image / mask-border 这些属性中任意一个或多个属性的元素</li><li>isolation 属性被设置为 isolate的元素</li><li>在 will-change 中指定了任意CSS` 属性的元素（即使没有直接指定这些属性的值）</li><li>-webkit-overflow-scrolling 属性被设置 touch的元素</li><li>设置了 transform-style: preserve-3d 的元素</li></ul><p>在层叠上下文中的子元素也会按照上面的规则进行层叠，子元素的 z-index 值只在父级层叠上下文中有意义，子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</p><p>但是，并不是创建了新的层叠上下文的元素并不一定都会对其拥有position: fixed的子元素的效果产生影响，<br>在Chrome（Blink内核）中，可以明确看到产生了影响的是：</p><ul><li>transform 属性值不为 none 的元素</li><li>设置了 transform-style: preserve-3d 的元素</li><li>perspective 值不为 none 的元素</li><li>在 will-change 中指定了任意 CSS 属性的元素</li><li>但是，在不同的浏览器内核下，上述结论也会有所差异，例如，在 Safari（Webkit内核） 中，只有transform 属性值不为 none 的元素会对 fixed 定位的效果产生影响.</li></ul><p>参考文档：</p><p><a href="https://www.w3.org/TR/css-color-3/#transparency" target="_blank" rel="noopener">the specification for opacity - W3C</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">The stacking context - MDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一部分，position: fixed失效的问题；&lt;br&gt;第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。&lt;/p&gt;
&lt;h1 id=&quot;关于-position-fixed&quot;&gt;&lt;a href=&quot;#关于-position-fixed&quot; class=&quot;h
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css3 transform对普通元素的n多渲染影响</title>
    <link href="https://summxu.github.io/2019/transform-element-impact/"/>
    <id>https://summxu.github.io/2019/transform-element-impact/</id>
    <published>2019-05-18T15:15:18.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 <code>position:fixed</code> 无效，问题是因为dilog定位时用了transform，深究下问题原因，发现事情并不是这么简单！</p></blockquote><p>一个普普通通的元素，如果应用了CSS3 transform变换，即便这个transform属性值不会改变其任何表面的变化（如scale(1), translate(0,0)），但是，实际上，对这些元素还是造成了很深远的影响。</p><h1 id="transform提升元素的垂直地位"><a href="#transform提升元素的垂直地位" class="headerlink" title="transform提升元素的垂直地位"></a>transform提升元素的垂直地位</h1><p>当遭遇元素margin负值重叠的时候，如果没有static以外的position属性值的话，后面的元素是会覆盖前面的元素的。<br><code>img src=&quot;mm1&quot;&gt;&lt;img src=&quot;mm2&quot; style=&quot;margin-left:-60px;&quot;&gt;</code><br>在transform出现之前，这个规则一直很稳健；但是，自从transform降临，这个规则就变了。元素应用了transform属性之后，就会变得应用了position:relative一个尿性，原本应该被覆盖的元素会雄起，变成覆盖其他元素，修改为如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm1"</span> <span class="attr">style</span>=<span class="string">"-ms-transform:scale(1);transform:scale(1);"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm2"</span> <span class="attr">style</span>=<span class="string">"margin-left:-60px;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要是支持transform元素的浏览器，包括IE9(-ms-), 都会提高普通元素的垂直地位，使其覆盖其他元素而不是被覆盖。</p><p>这种特性底层原理是层叠上下文，具体可参见“<a href="www.baidu.com">深入理解CSS中的层叠上下文和层叠顺序</a>”一文。</p><h1 id="transform限制position-fixed的跟随效果"><a href="#transform限制position-fixed的跟随效果" class="headerlink" title="transform限制position:fixed的跟随效果"></a>transform限制position:fixed的跟随效果</h1><p>我们应该都知道，<code>position:fixed</code>可以让元素不跟随浏览器的滚动条滚动，而且这种跟随效果连它的兄弟们<code>position:relative/absolute</code>都限制不了。但是，真是一物降一物，<code>position:fixed</code>固定效果却被小小的<code>transform</code>给干掉了，直接降级变成<code>position:absolute</code>的蛋疼表现。</p><p>例如下面示意代码：</p><p><code>&lt;p style=&quot;transform:scale(1);&quot;&gt;&lt;img src=&quot;mm1.jpg&quot;style=&quot;position:fixed;&quot; /&gt;&lt;/p&gt;</code><br>结果，本来应该不跟着滚动条滚动的傲娇<code>fixed</code>元素，变成<code>absolute</code>一样的行为表现，归根结底就是父元素加了个小小的<code>transform</code>属性值。</p><p>注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有，IE浏览器，包括IE11, <code>fixed</code>还是<code>fixed</code>的表现。</p><h1 id="transform改变overflow对absolute元素的限制"><a href="#transform改变overflow对absolute元素的限制" class="headerlink" title="transform改变overflow对absolute元素的限制"></a>transform改变overflow对absolute元素的限制</h1><p>在以前，<code>overflow</code>与<code>absolute</code>之间的限制规范内容大致是这样的：</p><p><code>absolute</code>绝对定位元素，如果含有<code>overflow</code>不为<code>visible</code>的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有<code>position</code>为非<code>static</code>属性的声明，则<code>overflow</code>对该<code>absolute</code>元素不起作用。</p><p>比方说如下示意代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"width:96px; height:96px; border:2px solid #beceeb; overflow:hidden;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm1.jpg"</span><span class="attr">style</span>=<span class="string">"position:absolute;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，一旦我们给<code>overflow</code>容器或者与图片有嵌套关系的子元素使用<code>transform</code>声明，估计<code>absolute</code>元素就要去领便当了！</p><p>无论是<code>overflow</code>容器还是嵌套子元素，只要有<code>transform</code>属性，就会<code>hidden</code>溢出的<code>absolute</code>元素。</p><h1 id="transform限制absolute的100-宽度大小"><a href="#transform限制absolute的100-宽度大小" class="headerlink" title="transform限制absolute的100%宽度大小"></a>transform限制absolute的100%宽度大小</h1><p>以前，我们设置<code>absolute</code>元素宽度100%, 则都会参照第一个非<code>static</code>值的<code>position</code>祖先元素计算，没有就<code>window</code>. 现在，需要把<code>transform</code>也考虑在内了。</p><p>结果，无论是IE9+，还是Chrome还是FireFox浏览器，所有绝对定位图片100%宽度，都是相对设置了<code>transform</code>的容器计算了，于是，上面的图片拉长到了西伯利亚；下面的图片被限制成了小胖墩。</p><p><code>transform</code>对<code>absolute</code>宽度100%限制~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 &lt;code&gt;position:fixed&lt;/code&gt; 无效，问题是因为dilog定位时用了transform，深究下
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>基于 document.execCommand 的富文本</title>
    <link href="https://summxu.github.io/2019/rich-text-editor-by-execCommand/"/>
    <id>https://summxu.github.io/2019/rich-text-editor-by-execCommand/</id>
    <published>2019-04-30T13:05:35.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需求，但其提供的诸多功能是用不上的，可以使用更轻量的实现代替。</p><p>在寻找新的替代品时，也顺便瞄了下各种编辑器的内部实现。一些体积庞大的编辑器一般都兼容低版本浏览器，不得不写很多兼容性的代码。而一些 MINI、轻量的编辑器是不对低端浏览器作兼容的，使用<code>Selection</code>、<code>Range</code>或者<code>document.execCommand</code>实现。</p><p>之前在 JavaScript 获取输入时的光标位置及场景问题 中提到过<code>Selection</code>和<code>Range</code>，这次就说说<code>document.execCommand</code>。</p><h1 id="document-execCommand"><a href="#document-execCommand" class="headerlink" title="document.execCommand"></a>document.execCommand</h1><p>该方法可以对可编辑器区域进行操作，比如加粗文字、改变字号、插入链接等。可编辑区域也就是设置了<code>contentEditable</code>属性的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">bool = document.execCommand(commandName, showDefaultUI[, arg])</span><br></pre></td></tr></table></figure><ul><li><code>commandName</code>：String，命令的名称</li><li><code>showDefaultUI</code>：Boolean，是否展示用户界面（暂时没有发现“用户界面”指的是什么），一般为false</li><li><code>arg</code>：String，要传递的参数，比如插入链接需要传入一个 URL，可选</li><li>返回值：Boolean，表示操作是否支持或是否启用<br>假如要把选中的文字加粗，只需要这样：</li></ul><p><code>document.execCommand(&#39;bold&#39;, false)</code></p><h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>[<a href="http://static.imys.net/execCommand-support-2017113.jpg]" target="_blank" rel="noopener">http://static.imys.net/execCommand-support-2017113.jpg]</a></p><p>对于现代浏览器的兼容度较好，不过 Android 53 取消兼容的什么鬼？</p><p>除了了解该方法的兼容性外，还需要了解每一种可执行命令的兼容性。比如<code>decreaseFontSize</code>，给选中文字添加<code>small</code>标签，也就是小号字体，谷歌是不支持的。</p><p>可以使用以下方法检测命令是否在浏览器中支持：</p><p><code>document.queryCommandSupported(commandName)</code></p><h1 id="简陋的实现"><a href="#简陋的实现" class="headerlink" title="简陋的实现"></a>简陋的实现</h1><p>不到 50 行代码，基于<a href="https://imys.net/demo/cmdEditor.html" target="_blank" rel="noopener">document.execCommand实现富文本编辑器</a>。</p><p>有兴趣的同学可以以此为出发点，去开发一个具备完整功能的编辑器。懒得折腾的可以像我一样多搜索几下，找一个合适的轮子。😅</p><p>参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">MDN: document.execCommand</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack按需打包Lodash的几种方式</title>
    <link href="https://summxu.github.io/2019/webpack-use-lodash/"/>
    <id>https://summxu.github.io/2019/webpack-use-lodash/</id>
    <published>2019-04-16T05:23:06.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。</p><p>ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 71k 的体积。不能为了吃一口饭而买下一个饭店啊。</p><p>针对这个问题，其实已经有很多可选方案了。</p><h1 id="函数模块"><a href="#函数模块" class="headerlink" title="函数模块"></a>函数模块</h1><p>Lodash 中的每个函数在 NPM 都有一个单独的发布模块。<code>NPM: results for ‘lodash’</code><br>假如你只需要使用<code>_.isEqual</code>，那么你只需要安装<code>lodash.isequal</code>模块，然后按以下方式引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEqual = <span class="built_in">require</span>(<span class="string">'lodash.isequal'</span>)</span><br><span class="line"><span class="comment">// or ES6</span></span><br><span class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isequal'</span></span><br><span class="line">isEqual([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="全路径引用"><a href="#全路径引用" class="headerlink" title="全路径引用"></a>全路径引用</h1><p>在你完整安装 Lodash 后，可以按<code>lodash/函数名</code>的格式单独引入需要的函数模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> difference = <span class="built_in">require</span>(<span class="string">'lodash/difference'</span>)</span><br><span class="line"><span class="comment">// or ES6</span></span><br><span class="line"><span class="keyword">import</span> difference <span class="keyword">from</span> <span class="string">'lodash/difference'</span></span><br><span class="line">difference([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>])  <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure><h1 id="使用插件优化"><a href="#使用插件优化" class="headerlink" title="使用插件优化"></a>使用插件优化</h1><p>在简单场景下，以上两种方式足以解决问题。<br>而遇到复杂的数据对象时，我们不得不在一个文件中引入多个 Lodash 函数，这样就需要在文件中写多个<code>require</code>或<code>import</code>相关函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> remove <span class="keyword">from</span> <span class="string">'lodash/remove'</span></span><br><span class="line"><span class="keyword">import</span> uniq <span class="keyword">from</span> <span class="string">'lodash/uniq'</span></span><br><span class="line"><span class="keyword">import</span> invokeMap <span class="keyword">from</span> <span class="string">'lodash/invokeMap'</span></span><br><span class="line"><span class="keyword">import</span> sortBy <span class="keyword">from</span> <span class="string">'lodash/sortBy'</span></span><br><span class="line"><span class="comment">// more...</span></span><br></pre></td></tr></table></figure><p>正写到关键处却因为引入一个函数要拉到文件头部去定义引用而打乱了思路，很不爽！</p><p>于是我机智的到 Github 去搜索了webpack和lodash两个关键词的组合，排在首位的 lodash-webpack-plugin 就是为了解决这个问题而生。</p><p>使用时需要以下模块，其实除了前两个剩下的一般都已安装了：</p><p><code>$ npm i -S lodash-webpack-plugin babel-plugin-lodash babel-core babel-loader babel-preset-es2015 webpack</code><br><strong>配置：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"><span class="keyword">var</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      loader: <span class="string">'babel'</span>,</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        plugins: [<span class="string">'transform-runtime'</span>, <span class="string">'lodash'</span>],</span><br><span class="line">        presets: [<span class="string">'es2015'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> LodashModuleReplacementPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>babel-plugin-lodash</code>的配置，也就是<code>plugins: [&#39;lodash&#39;]</code>，并不是一定要在<code>loaders</code>中，也可以单独定义<code>babel</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"><span class="keyword">var</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      loader: <span class="string">'babel'</span>,</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  babel: &#123;</span><br><span class="line">    presets: [<span class="string">'es2015'</span>],</span><br><span class="line">    plugins: [<span class="string">'transform-runtime'</span>, <span class="string">'lodash'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> LodashModuleReplacementPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又或者是<code>.babelrc</code>文件中。</p><p>以上工作完成了，在每个你需要使用 lodash 函数的文件中只需要引用一次 lodash，即可调用任意函数而不会造成完全打包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line">_.add(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 打包时只会引入这一个函数模块</span></span><br></pre></td></tr></table></figure><p>注意：必须要使用 ES2015 的模块引用方式才有效。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>以上即是我目前所知道的几种方式，如果哪位朋友有更好的方式（比如只需要全局引入一次），请一定分享与我！😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。&lt;/p&gt;
&lt;p&gt;ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正确使用Vue指令的钩子函数</title>
    <link href="https://summxu.github.io/2019/vue-directive-hook/"/>
    <id>https://summxu.github.io/2019/vue-directive-hook/</id>
    <published>2019-03-24T07:28:24.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>在 Vue 中可以把一系列<strong>复杂的操作</strong>包装为一个指令。</p><blockquote><p><strong>什么是复杂的操作？</strong><br>我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段的掩盖等。我们总是期望以操作数据的形式来实现功能逻辑。</p></blockquote><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>对于自定义指令的定义，Vue2 有 5 个可选的钩子函数。</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li><li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。</li><li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind: 只调用一次，指令与元素解绑时调用。<br>接下来，定义一个简单的指令以验证这些钩子函数的触发时机。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-comp</span> <span class="attr">v-if</span>=<span class="string">"msg"</span> <span class="attr">:msg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"update"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"uninstall"</span>&gt;</span>卸载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"install"</span>&gt;</span>安装<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'bind'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inserted'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'componentUpdated'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'unbind'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> myComp = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1 v-hello&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        msg: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">'Hello'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        myComp: myComp</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">'Hi'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        uninstall: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        install: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">'Hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="页面加载时"><a href="#页面加载时" class="headerlink" title="页面加载时"></a>页面加载时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind</span><br><span class="line">inserted</span><br></pre></td></tr></table></figure><h2 id="组件更新时"><a href="#组件更新时" class="headerlink" title="组件更新时"></a>组件更新时</h2><p>点击“更新”按钮，更改数据触发组件更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update</span><br><span class="line">componentUpdated</span><br></pre></td></tr></table></figure><h2 id="卸载组件时"><a href="#卸载组件时" class="headerlink" title="卸载组件时"></a>卸载组件时</h2><p>点击“卸载”按钮，数据置空否定判断以触发组件卸载。</p><p><code>unbind</code></p><h2 id="重新安装组件时"><a href="#重新安装组件时" class="headerlink" title="重新安装组件时"></a>重新安装组件时</h2><p>点击“安装”按钮，数据赋值肯定判断以触发组件重新安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind</span><br><span class="line">inserted</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>从案例的运行中，对 5 个钩子函数的触发时机有了初步的认识。存疑的也就是<code>bind</code>和<code>inserted</code>、<code>update</code>和<code>componentUpdated</code>的区别了。</p><h3 id="bind-和-inserted"><a href="#bind-和-inserted" class="headerlink" title="bind 和 inserted"></a>bind 和 inserted</h3><p>据文档所说，插入父节点时调用 inserted，来个测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.parentNode)  <span class="comment">// null</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bind'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.parentNode)  <span class="comment">// &lt;div id="app"&gt;...&lt;/div&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'inserted'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别在两个钩子函数中输出父节点：<strong>bind 时父节点为 null，inserted 时父节点存在。</strong></p><h3 id="update-和-componentUpdated"><a href="#update-和-componentUpdated" class="headerlink" title="update 和 componentUpdated"></a><strong>update</strong> 和 <strong>componentUpdated</strong></h3><p>关于这两个的介绍，从字眼上看感觉是组件更新周期有关，继续验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.innerHTML)   <span class="comment">// Hello</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.innerHTML)   <span class="comment">// Hi</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentUpdated'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没毛病，<strong>update 和 componentUpdated 就是组件更新前和更新后的区别。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>文档说的没错…😒<br><a href="https://jsfiddle.net/imys/twbv0sov/1/" target="_blank" rel="noopener">Demo</a></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>根据需求的不同，我们要选择恰当的时机去初始化指令、更新指令调用参数以及释放指令存在时的内存占用等。</p><p>比较常见的场景是：用指令包装一些无依赖的第三方库以扩展组件功能。而一个健壮的库通常会包含：初始化实例、参数更新和释放实例资源占用等操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在 bind 钩子中初始化库实例</span></span><br><span class="line">        <span class="comment">// 如果需要使用父节点，也可以在 inserted 钩子中执行</span></span><br><span class="line">        el.__library__ = <span class="keyword">new</span> Library(el, binding.value)</span><br><span class="line">    &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 模版更新意味着指令的参数可能被改变，这里可以对库实例的参数作更新</span></span><br><span class="line">        <span class="comment">// 酌情使用 update 或 componentUpdated 钩子</span></span><br><span class="line">        el.__library__.setOptions(<span class="built_in">Object</span>.assign(binding.oldValue, binding.value))</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 释放实例</span></span><br><span class="line">        el.__library__.destory()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Vue 中可以把一系列&lt;strong&gt;复杂的操作&lt;/strong&gt;包装为一个指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是复杂的操作？&lt;/strong&gt;&lt;br&gt;我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>使用队列解决插队业务场景</title>
    <link href="https://summxu.github.io/2019/queue-solve-continuous/"/>
    <id>https://summxu.github.io/2019/queue-solve-continuous/</id>
    <published>2019-03-01T01:02:36.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。<br>但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。<br>理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。</p><p>我觉得用“插队”来描述这个场景真是再好不过了。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>既然有人要“插队”，我们就要定义一个规则：先进先出。<br>也就是数据结构中的“队列”了。</p><p>javascript 中队列的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="keyword">var</span> queue = []</span><br><span class="line"><span class="comment">// 进队</span></span><br><span class="line">queue.push(<span class="number">1</span>)</span><br><span class="line">queue.push(<span class="number">2</span>)</span><br><span class="line">queue.push(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">queue.shift() <span class="comment">// 1</span></span><br><span class="line">queue.shift() <span class="comment">// 2</span></span><br><span class="line">queue.shift() <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="keyword">var</span> queue2 = []</span><br><span class="line"><span class="comment">// 进队</span></span><br><span class="line">queue2.unshift(<span class="number">1</span>)</span><br><span class="line">queue2.unshift(<span class="number">2</span>)</span><br><span class="line">queue2.unshift(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">queue2.pop() <span class="comment">// 1</span></span><br><span class="line">queue2.pop() <span class="comment">// 2</span></span><br><span class="line">queue2.pop() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestQueue = []</span><br><span class="line"><span class="keyword">var</span> XHR = <span class="function"><span class="keyword">function</span>(<span class="params">method, url, param</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>点击操作的入口函数，先创建请求进队。<br>因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myClick</span>(<span class="params">method, url, param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = requestQueue.push(XHR(method, url, param))</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">1</span>) &#123;</span><br><span class="line">        update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的永远是队列中的第一个请求。<br>当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。<br>如果存在未完成的请求，继续调用更新操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    requestQueue[<span class="number">0</span>].then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// request success</span></span><br><span class="line">        requestQueue.shift()</span><br><span class="line">        requestQueue.length &amp;&amp; update()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。&lt;br&gt;但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。&lt;br&gt;理想的状态是上一个请求结束后
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何为Canvas中特定图形绑定事件？</title>
    <link href="https://summxu.github.io/2019/canvas-event/"/>
    <id>https://summxu.github.io/2019/canvas-event/</id>
    <published>2019-02-14T10:47:15.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。<br>但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。</p><p>我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件时，动态判断当前响应元素为目标子节点时再执行对应的操作。</p><p>这个思想同样也可以用在 Canvas 上，只需要为 <code>canvas</code> 元素绑定事件，事件响应时判断当前鼠标位置处于哪个图形之上，执行对应的操作。</p><h1 id="isPointInPath"><a href="#isPointInPath" class="headerlink" title="isPointInPath"></a>isPointInPath</h1><p><code>context.isPointInPath(x, y);</code></p><p>理论上讲，想要知道一个点是否处于一个图形之中，现成的算法应该是有很多了。不过难得 canvas 本身就提供了这样的函数，用来判断一个点是否处于当前路径中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ctx.isPointInPath(<span class="number">50</span>, <span class="number">100</span>))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>就像这样，当你创建一个矩形时，就会产生一个路径，此时就可以调用该方法去判断一个点是否存在于该路径。</p><p>产生路径的函数还有其他，比如：<code>lineTo()</code>、<code>clip()</code>、<code>arc()</code>、<code>arcTo()</code> 等。</p><h1 id="实现图形的事件绑定"><a href="#实现图形的事件绑定" class="headerlink" title="实现图形的事件绑定"></a>实现图形的事件绑定</h1><p>先来个简单的饼图吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> r = canvas.width / <span class="number">2</span>;</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#2196f3'</span>; <span class="comment">//蓝色</span></span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(r, r, r, <span class="built_in">Math</span>.PI * <span class="number">1</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#f44336'</span>; <span class="comment">//红色</span></span><br><span class="line">ctx.fill();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInPath</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx.isPointInPath(x, y);</span><br><span class="line">&#125;</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInPath(e.offsetX, e.offsetY)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在创建一个红蓝拼接的饼图，<code>isInPath</code> 方法判断一个点是否处于蓝色区。理想的结果是只有当鼠标点击区域为蓝色区域时才输出<code>hello。</code></p><p>但事实确不是如此，示例Demo。无论点击红色还是蓝色区域均会输出 <code>hello</code>，这是怎么回事呢</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>既然 <code>isPointInPath(x, y)</code> 的基于路径判断的，那我们就从路径入手。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#2196f3'</span>;</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.arc(r, r, r, <span class="built_in">Math</span>.PI * <span class="number">1</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#f44336'</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p>当我们把画图时的 <code>ctx.beginPath()</code> 去掉后，发现生成的图形变成一个红色的整圆了：示例Demo。</p><p><code>beginPath()</code> 用来重置路径，由于第一个半圆画完路径未重置，第二个半圆就绘制了两条路径。这似乎解释了上个问题的答案。</p><p>在 <code>isInPath(x, y)</code>函数中，由于路径没有重置，所以最终最终判断的不止是 <code>ctx.arc(r, r, r, 0, Math.PI * 1)</code> 这个路径，还有方法外的画红色圆的路径。两个路径加一起自然就是个整圆，所以无论蓝色区还是红色区都会输出。</p><h2 id="正确结果"><a href="#正确结果" class="headerlink" title="正确结果"></a>正确结果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInPath</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx.isPointInPath(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>isInPath</code> 函数，加入重置路径，结果正确输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。&lt;br&gt;但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。&lt;/p&gt;
&lt;p&gt;我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件间样式污染大坑</title>
    <link href="https://summxu.github.io/2018/vue-scoped-keng/"/>
    <id>https://summxu.github.io/2018/vue-scoped-keng/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Vue 组件内的样式可以写在 Style 标签下，而各组件之间的样式冲突(污染)问题也十分常见，当然我们可以尽量避免起相同的类名，但项目较大的时候，Class类名时而会冲突。</p><p>当然 Vue官方也给了我们解决方法，就是定义了 scoped 这个属性的设置：</p><blockquote><p>这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover。</p></blockquote><blockquote><p>最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在 <style> 标签内。</p></blockquote><p>但是问题就在于 <strong>虽然加了scoped,但是却仍热无法锁住用@import引入的外部css文件</strong></p><p>这里的解决方法也比较神奇，就是把引入的css文件改为使用预处理器处理的 less sass 或者 styl 文件，具体原理暂时还不得而知</p><p>使用 /deep/ 来解决更深一级的标签</p></style></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道，Vue 组件内的样式可以写在 Style 标签下，而各组件之间的样式冲突(污染)问题也十分常见，当然我们可以尽量避免起相同的类名，但项目较大的时候，Class类名时而会冲突。&lt;/p&gt;
&lt;p&gt;当然 Vue官方也给了我们解决方法，就是定义了 scoped 这个属性的
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.$emit Promise 回调后的深坑</title>
    <link href="https://summxu.github.io/2018/vue-emit-keng/"/>
    <id>https://summxu.github.io/2018/vue-emit-keng/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2023-08-25T10:01:39.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有个登录需求，是 login.vue 属于 App.vue 的子组件，默认路由页面是进入 login.vue 因为你一开始需要验证登录用户，又要通过登录用户来进行</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有个登录需求，是 login.vue 属于 App.vue 的子组件，默认路由页面是进入 login.vue 因为你一开始需要验证登录用户，又要通过登录用户来进行&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Express + 模板引擎 + jQuery load 实现局部页面的异步加载</title>
    <link href="https://summxu.github.io/2018/express-jqueryload/"/>
    <id>https://summxu.github.io/2018/express-jqueryload/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2023-08-25T10:01:39.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目匿名评论系统的局部异步加载服务的实现</p></blockquote><h2 id="问题需求"><a href="#问题需求" class="headerlink" title="问题需求"></a>问题需求</h2><p>目前的论坛系统带有聊天室，在浏览帖子的同时可以随时聊天，这就意味着页面不能经常刷新，一是刷新就会重连服务器，导致一直断开重连的状态，二是刷新之后聊天记录消失，还要做数据的持久化，再者就是影响用户体验，所以最好的解决方案就是异步加载局部页面。前后端分离是挺好做，直接load加载本地页面就可以，但一和express结合起来就不知道该怎么办了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/5563645.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实仔细思考这个问题并不复杂，和前后端分离的模式是完全一模一样的，<strong>只是把本地要加载的局部页面换成了服务器上渲染出来的局部页面</strong> 。 这时就需要重新配置express的路由和 render 的页面分离，路由多了两条： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.get(<span class="string">'/main'</span>,(req,res) =&gt; &#123;</span><br><span class="line">  mongo.Post.find(<span class="function">(<span class="params">err, postdata</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> res.status(<span class="number">500</span>)</span><br><span class="line">    <span class="comment">/* 对象属性抽离，解决template陷入递归 */</span></span><br><span class="line">    <span class="comment">/* mogon取出的对象不正常，转换一下 */</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.stringify(postdata)</span><br><span class="line">    data = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    <span class="keyword">var</span> images = []</span><br><span class="line">    data.forEach(<span class="function">(<span class="params">element, a</span>) =&gt;</span> &#123;</span><br><span class="line">      images.push(element.images)</span><br><span class="line">      <span class="keyword">delete</span> element.images</span><br><span class="line">    &#125;);</span><br><span class="line">    res.render(<span class="string">'./components/main.html'</span>, &#123;</span><br><span class="line">      post: data,</span><br><span class="line">      images: images</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="string">'/sendpost'</span>,(req,res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'./components/sendpost.html'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>渲染出独立页面，这是各个页面的路径分配：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/52866315.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样两个在服务器路径中真实存在的页面出来了，通过浏览器也能访问，只不过没了样式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/99119243.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/67452684.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在客户端上写上这么一句，就大功告成了！！</p><p><code>$(&#39;.center .left&#39;).load(&quot;/main&quot;);</code><br><code>$(&#39;.center .left&#39;).load(&quot;/sendpost&quot;);</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;项目匿名评论系统的局部异步加载服务的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题需求&quot;&gt;&lt;a href=&quot;#问题需求&quot; class=&quot;headerlink&quot; title=&quot;问题需求&quot;&gt;&lt;/a&gt;问题需求&lt;/h2&gt;&lt;p&gt;目前的论坛系统
      
    
    </summary>
    
    
    
      <category term="jQuery" scheme="https://summxu.github.io/tags/jQuery/"/>
    
      <category term="Node.js" scheme="https://summxu.github.io/tags/Node-js/"/>
    
  </entry>
  
</feed>
