<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小兵旭旭的博客</title>
  
  <subtitle>Reality&#39;s more solid worth,Appearance studied to set forth.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://summxu.github.io/"/>
  <updated>2023-07-21T06:33:35.773Z</updated>
  <id>https://summxu.github.io/</id>
  
  <author>
    <name>summxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试文章</title>
    <link href="https://summxu.github.io/2023/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <id>https://summxu.github.io/2023/测试文章/</id>
    <published>2023-07-21T01:58:02.000Z</published>
    <updated>2023-07-21T06:33:35.773Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTTP缓存-ETag</title>
    <link href="https://summxu.github.io/2019/http-cache-etag/"/>
    <id>https://summxu.github.io/2019/http-cache-etag/</id>
    <published>2019-08-10T12:44:11.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。</p></blockquote><h2 id="ETag验证缓存的响应"><a href="#ETag验证缓存的响应" class="headerlink" title="ETag验证缓存的响应"></a>ETag验证缓存的响应</h2><p>在本地通过 express 启了一个非常简单的个服务，具体如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello http'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://127.0.0.1:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是仔细看却发现，第一次进入页面<strong><a href="http://127.0.0.1:3000/" target="_blank" rel="noopener">http://127.0.0.1:3000/</a></strong>时，Status为200而再次刷新发现Status却是304</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-e14290fe5a1aaa4b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-f19b1eb12e8d8cc4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>仔细对比发现</p><ol><li>第一次请求时候请求参数中并没有 If-None-Match 字段但是却有个Pragma；同时在请求的Response中有一个 <strong>ETag: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg”</strong>字段。</li><li>刷新页面后再次请求在请求头中却有个 *<em>If-None-Match: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg” *</em>，If-None-Match 的值和第一次请求的ETag的值相同。</li></ol><p>经过查询才了解原理浏览器会根据HTTP请求的ETag验证请求的资源是否发生了改变，如果它未发生变化，服务器将返回“304 Not Modified”响应，并且资源从浏览器缓存中读取，这样就不必再次下载请求。</p><p>由此看来整个的过程就是下面这样：</p><ol><li>如果缓存中有ETag 令牌，客户端请求时会自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。</li><li>服务器根据当前资源核对令牌，验证是否发生变化，将验证结果通知给客户端，客户端根据结果看看是否需要从缓存中读取还是发送资源请求。</li></ol><p>补充一个很直白的 <a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">TCP协议的三次握手</a> 的理解。</p><p>为了验证查证的结果，我又添加一个请求处理。这个过程是，客户端明确返回一个ETag, 但是这里每次请求的的返回值都不相同，这里简单的使用了个<strong>etag++</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello http'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证ETag</span></span><br><span class="line"><span class="keyword">let</span> etag = <span class="number">0</span>;</span><br><span class="line">app.get(<span class="string">'/test'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  etag++;</span><br><span class="line">  res.set(<span class="string">'ETag'</span>, etag);</span><br><span class="line">  res.send(<span class="string">'ETag'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://127.0.0.1:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-71230f0ad656f455.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>查看下 /test 地址的请求结果，会发现If-None-Match 的值和 Response中的 ETag值每次都不相同，并且是 浏览器会将每次的 ETag 值都缓存起来在下次请求的时候发送给服务器。这样一来，每次服务器每次校验的值都是不相同的，所以这种就没有做缓存，因此每次请求 /test 地址都是 200 的状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 
      
    
    </summary>
    
    
    
      <category term="HTTP" scheme="https://summxu.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>fixed 定位失效 与 CSS 层叠上下文</title>
    <link href="https://summxu.github.io/2019/fixed-stacking-context/"/>
    <id>https://summxu.github.io/2019/fixed-stacking-context/</id>
    <published>2019-05-22T15:38:51.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分，position: fixed失效的问题；<br>第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。</p><h1 id="关于-position-fixed"><a href="#关于-position-fixed" class="headerlink" title="关于 position: fixed"></a>关于 position: fixed</h1><p><strong>position: fixed</strong> 在日常布局中比较常用，如移动端头部和底部导航定位、模态框、悬浮按钮等，设置了这个属性值得元素会相对于屏幕视口（viewport）进行定位，其位置在屏幕进行滚动时会保持不变，不占用文档流中的位置，而且打印时这个元素会出现在 每一页 的相同位置。设置了 <strong>position: fixed</strong> 的元素最终的位置由它的 <strong>top, right, bottom, left</strong> 来决定，这个值会创建一个新的 <strong>stacking context</strong><br>但是，有些情况下，这种定位方式会失效，使得元素相对于视窗定位的定位不符合预期（其实是 <strong>fixed</strong> 定位的参考元素变了）。当该元素的父元素中（广义，包含祖先元素）有元素的 <strong>transform</strong> 或 <strong>perspective</strong> 的值不是 <strong>none</strong>，该元素就会相对于这个父元素而不是视口进行定位。<br>具体的原因是这样：</p><blockquote><p>Specifying a value other than none for the transform property establishes a new local coordinate system at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element’s transformation matrix. Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent. From the perspective of the user, an element effectively accumulates all the transform properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a current transformation matrix for the element.</p></blockquote><p>解释一下，<strong>transform</strong> 或 perspective 的非 none 值会影响元素的包含块和层叠上下文，这些值会在应用它的元素上建立一个局部的坐标系（X轴向右水平增加; Y轴垂直向下增加），由变换矩阵（<strong>transform</strong> 的值）给出元素到该局部坐标系的映射，而且 <strong>transform</strong> 带来的局部坐标系的改变是可以累积的——也就是说，子元素会在它的父元素的坐标系内建立子元素自己的局部坐标系：<br>父元素的 <strong>transform</strong> 们一层层积累定义了子元素当前的变换矩阵（一个元素的变换矩阵是从 <strong>transform</strong> 和 <strong>transform</strong>-origin 属性中计算出来的），步骤如下：</p><ul><li>通过 <strong>transform-origin</strong> 的值对坐标原点 X 和 Y 的位置进行转换</li><li>以变换后的 X、Y 为坐标原点原点，根据 <strong>transform</strong> 的属性值进行变换</li><li>X 和 Y 根据 <strong>transform-origin</strong> 的相反值平移回去</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180102175637761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGFuZGFfbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="如图" title>                </div>                <div class="image-caption">如图</div>            </figure><p><strong>transform</strong> 会影响最终的渲染效果，但是不影响除overflow外的CSS布局，当通过 <strong>getClientRects()</strong>、<strong>getBoundingClientRect()</strong> 这些接口获取 <strong>client rectangles</strong> 时，<strong>transform</strong> 的效果也会被考虑进去。</p><p>可以应用 <strong>transform</strong> 的元素（<strong>transformable elements</strong>）有：</p><ul><li>满足CSS盒模型的块级元素或行内元素，或者它的 display 值为 table-row, table-row-group, table-header-group, table-footer-group, table-cell, table-caption 中的一个</li><li>SVG 命名空间中具有 transform, patternTransform 或 gradientTransform 属性的元素</li></ul><p>p.s. 关于上面的应用<strong>transform</strong>后元素位置的计算方式。原文如下：</p><ol><li>Start with the identity matrix.</li><li>Translate by the computed X and Y of transform-origin</li><li>Multiply by each of the transform functions in transform property from left to right</li><li>Translate by the negated computed X and Y values of transform-origin</li></ol><p>参考文档：</p><p><a href="https://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="noopener">The transform Property - W3C Working Draft - 30 November 2017</a></p><p><a href="https://www.w3.org/TR/css-transforms-1/#transform-rendering" target="_blank" rel="noopener">The Transform Rendering Model - W3C Working Draft - 30 November 2017</a></p><h1 id="层叠上下文-Stacking-Context"><a href="#层叠上下文-Stacking-Context" class="headerlink" title="层叠上下文 Stacking Context"></a>层叠上下文 Stacking Context</h1><p>通过上文我们知道了有层叠上下文这么一个东西，层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。和BFC还有IFC这些xx context一样，创建层叠上下文也是有条件的，文档中的层叠上下文由满足以下任意一个条件的元素形成：</p><ul><li>根元素 (HTML),</li><li>z-index 值不为 auto 的 绝对/相对定位元素</li><li>position 不是 static 的元素（sticky 也会创建层叠上下文，这是一个神奇的实验中的属性值）</li><li>一个 z-index 值不为 auto 的 flex 项目 (flex item)</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity）</li><li>transform 属性值不为 none 的元素</li><li>mix-blend-mode 属性值不为 normal 的元素</li><li>有 transform、filter、perspective、clip-path、mask / mask-image / mask-border 这些属性中任意一个或多个属性的元素</li><li>isolation 属性被设置为 isolate的元素</li><li>在 will-change 中指定了任意CSS` 属性的元素（即使没有直接指定这些属性的值）</li><li>-webkit-overflow-scrolling 属性被设置 touch的元素</li><li>设置了 transform-style: preserve-3d 的元素</li></ul><p>在层叠上下文中的子元素也会按照上面的规则进行层叠，子元素的 z-index 值只在父级层叠上下文中有意义，子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</p><p>但是，并不是创建了新的层叠上下文的元素并不一定都会对其拥有position: fixed的子元素的效果产生影响，<br>在Chrome（Blink内核）中，可以明确看到产生了影响的是：</p><ul><li>transform 属性值不为 none 的元素</li><li>设置了 transform-style: preserve-3d 的元素</li><li>perspective 值不为 none 的元素</li><li>在 will-change 中指定了任意 CSS 属性的元素</li><li>但是，在不同的浏览器内核下，上述结论也会有所差异，例如，在 Safari（Webkit内核） 中，只有transform 属性值不为 none 的元素会对 fixed 定位的效果产生影响.</li></ul><p>参考文档：</p><p><a href="https://www.w3.org/TR/css-color-3/#transparency" target="_blank" rel="noopener">the specification for opacity - W3C</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">The stacking context - MDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一部分，position: fixed失效的问题；&lt;br&gt;第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。&lt;/p&gt;
&lt;h1 id=&quot;关于-position-fixed&quot;&gt;&lt;a href=&quot;#关于-position-fixed&quot; class=&quot;h
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css3 transform对普通元素的n多渲染影响</title>
    <link href="https://summxu.github.io/2019/transform-element-impact/"/>
    <id>https://summxu.github.io/2019/transform-element-impact/</id>
    <published>2019-05-18T15:15:18.000Z</published>
    <updated>2023-07-21T06:33:35.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 <code>position:fixed</code> 无效，问题是因为dilog定位时用了transform，深究下问题原因，发现事情并不是这么简单！</p></blockquote><p>一个普普通通的元素，如果应用了CSS3 transform变换，即便这个transform属性值不会改变其任何表面的变化（如scale(1), translate(0,0)），但是，实际上，对这些元素还是造成了很深远的影响。</p><h1 id="transform提升元素的垂直地位"><a href="#transform提升元素的垂直地位" class="headerlink" title="transform提升元素的垂直地位"></a>transform提升元素的垂直地位</h1><p>当遭遇元素margin负值重叠的时候，如果没有static以外的position属性值的话，后面的元素是会覆盖前面的元素的。<br><code>img src=&quot;mm1&quot;&gt;&lt;img src=&quot;mm2&quot; style=&quot;margin-left:-60px;&quot;&gt;</code><br>在transform出现之前，这个规则一直很稳健；但是，自从transform降临，这个规则就变了。元素应用了transform属性之后，就会变得应用了position:relative一个尿性，原本应该被覆盖的元素会雄起，变成覆盖其他元素，修改为如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm1"</span> <span class="attr">style</span>=<span class="string">"-ms-transform:scale(1);transform:scale(1);"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm2"</span> <span class="attr">style</span>=<span class="string">"margin-left:-60px;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要是支持transform元素的浏览器，包括IE9(-ms-), 都会提高普通元素的垂直地位，使其覆盖其他元素而不是被覆盖。</p><p>这种特性底层原理是层叠上下文，具体可参见“<a href="www.baidu.com">深入理解CSS中的层叠上下文和层叠顺序</a>”一文。</p><h1 id="transform限制position-fixed的跟随效果"><a href="#transform限制position-fixed的跟随效果" class="headerlink" title="transform限制position:fixed的跟随效果"></a>transform限制position:fixed的跟随效果</h1><p>我们应该都知道，<code>position:fixed</code>可以让元素不跟随浏览器的滚动条滚动，而且这种跟随效果连它的兄弟们<code>position:relative/absolute</code>都限制不了。但是，真是一物降一物，<code>position:fixed</code>固定效果却被小小的<code>transform</code>给干掉了，直接降级变成<code>position:absolute</code>的蛋疼表现。</p><p>例如下面示意代码：</p><p><code>&lt;p style=&quot;transform:scale(1);&quot;&gt;&lt;img src=&quot;mm1.jpg&quot;style=&quot;position:fixed;&quot; /&gt;&lt;/p&gt;</code><br>结果，本来应该不跟着滚动条滚动的傲娇<code>fixed</code>元素，变成<code>absolute</code>一样的行为表现，归根结底就是父元素加了个小小的<code>transform</code>属性值。</p><p>注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有，IE浏览器，包括IE11, <code>fixed</code>还是<code>fixed</code>的表现。</p><h1 id="transform改变overflow对absolute元素的限制"><a href="#transform改变overflow对absolute元素的限制" class="headerlink" title="transform改变overflow对absolute元素的限制"></a>transform改变overflow对absolute元素的限制</h1><p>在以前，<code>overflow</code>与<code>absolute</code>之间的限制规范内容大致是这样的：</p><p><code>absolute</code>绝对定位元素，如果含有<code>overflow</code>不为<code>visible</code>的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有<code>position</code>为非<code>static</code>属性的声明，则<code>overflow</code>对该<code>absolute</code>元素不起作用。</p><p>比方说如下示意代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"width:96px; height:96px; border:2px solid #beceeb; overflow:hidden;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm1.jpg"</span><span class="attr">style</span>=<span class="string">"position:absolute;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，一旦我们给<code>overflow</code>容器或者与图片有嵌套关系的子元素使用<code>transform</code>声明，估计<code>absolute</code>元素就要去领便当了！</p><p>无论是<code>overflow</code>容器还是嵌套子元素，只要有<code>transform</code>属性，就会<code>hidden</code>溢出的<code>absolute</code>元素。</p><h1 id="transform限制absolute的100-宽度大小"><a href="#transform限制absolute的100-宽度大小" class="headerlink" title="transform限制absolute的100%宽度大小"></a>transform限制absolute的100%宽度大小</h1><p>以前，我们设置<code>absolute</code>元素宽度100%, 则都会参照第一个非<code>static</code>值的<code>position</code>祖先元素计算，没有就<code>window</code>. 现在，需要把<code>transform</code>也考虑在内了。</p><p>结果，无论是IE9+，还是Chrome还是FireFox浏览器，所有绝对定位图片100%宽度，都是相对设置了<code>transform</code>的容器计算了，于是，上面的图片拉长到了西伯利亚；下面的图片被限制成了小胖墩。</p><p><code>transform</code>对<code>absolute</code>宽度100%限制~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 &lt;code&gt;position:fixed&lt;/code&gt; 无效，问题是因为dilog定位时用了transform，深究下
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>基于 document.execCommand 的富文本</title>
    <link href="https://summxu.github.io/2019/rich-text-editor-by-execCommand/"/>
    <id>https://summxu.github.io/2019/rich-text-editor-by-execCommand/</id>
    <published>2019-04-30T13:05:35.000Z</published>
    <updated>2023-07-21T06:33:35.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需求，但其提供的诸多功能是用不上的，可以使用更轻量的实现代替。</p><p>在寻找新的替代品时，也顺便瞄了下各种编辑器的内部实现。一些体积庞大的编辑器一般都兼容低版本浏览器，不得不写很多兼容性的代码。而一些 MINI、轻量的编辑器是不对低端浏览器作兼容的，使用<code>Selection</code>、<code>Range</code>或者<code>document.execCommand</code>实现。</p><p>之前在 JavaScript 获取输入时的光标位置及场景问题 中提到过<code>Selection</code>和<code>Range</code>，这次就说说<code>document.execCommand</code>。</p><h1 id="document-execCommand"><a href="#document-execCommand" class="headerlink" title="document.execCommand"></a>document.execCommand</h1><p>该方法可以对可编辑器区域进行操作，比如加粗文字、改变字号、插入链接等。可编辑区域也就是设置了<code>contentEditable</code>属性的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">bool = document.execCommand(commandName, showDefaultUI[, arg])</span><br></pre></td></tr></table></figure><ul><li><code>commandName</code>：String，命令的名称</li><li><code>showDefaultUI</code>：Boolean，是否展示用户界面（暂时没有发现“用户界面”指的是什么），一般为false</li><li><code>arg</code>：String，要传递的参数，比如插入链接需要传入一个 URL，可选</li><li>返回值：Boolean，表示操作是否支持或是否启用<br>假如要把选中的文字加粗，只需要这样：</li></ul><p><code>document.execCommand(&#39;bold&#39;, false)</code></p><h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>[<a href="http://static.imys.net/execCommand-support-2017113.jpg]" target="_blank" rel="noopener">http://static.imys.net/execCommand-support-2017113.jpg]</a></p><p>对于现代浏览器的兼容度较好，不过 Android 53 取消兼容的什么鬼？</p><p>除了了解该方法的兼容性外，还需要了解每一种可执行命令的兼容性。比如<code>decreaseFontSize</code>，给选中文字添加<code>small</code>标签，也就是小号字体，谷歌是不支持的。</p><p>可以使用以下方法检测命令是否在浏览器中支持：</p><p><code>document.queryCommandSupported(commandName)</code></p><h1 id="简陋的实现"><a href="#简陋的实现" class="headerlink" title="简陋的实现"></a>简陋的实现</h1><p>不到 50 行代码，基于<a href="https://imys.net/demo/cmdEditor.html" target="_blank" rel="noopener">document.execCommand实现富文本编辑器</a>。</p><p>有兴趣的同学可以以此为出发点，去开发一个具备完整功能的编辑器。懒得折腾的可以像我一样多搜索几下，找一个合适的轮子。😅</p><p>参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">MDN: document.execCommand</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack按需打包Lodash的几种方式</title>
    <link href="https://summxu.github.io/2019/webpack-use-lodash/"/>
    <id>https://summxu.github.io/2019/webpack-use-lodash/</id>
    <published>2019-04-16T05:23:06.000Z</published>
    <updated>2023-07-21T06:33:35.773Z</updated>
    
    <content type="html"><![CDATA[<p>在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。</p><p>ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 71k 的体积。不能为了吃一口饭而买下一个饭店啊。</p><p>针对这个问题，其实已经有很多可选方案了。</p><h1 id="函数模块"><a href="#函数模块" class="headerlink" title="函数模块"></a>函数模块</h1><p>Lodash 中的每个函数在 NPM 都有一个单独的发布模块。<code>NPM: results for ‘lodash’</code><br>假如你只需要使用<code>_.isEqual</code>，那么你只需要安装<code>lodash.isequal</code>模块，然后按以下方式引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEqual = <span class="built_in">require</span>(<span class="string">'lodash.isequal'</span>)</span><br><span class="line"><span class="comment">// or ES6</span></span><br><span class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isequal'</span></span><br><span class="line">isEqual([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="全路径引用"><a href="#全路径引用" class="headerlink" title="全路径引用"></a>全路径引用</h1><p>在你完整安装 Lodash 后，可以按<code>lodash/函数名</code>的格式单独引入需要的函数模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> difference = <span class="built_in">require</span>(<span class="string">'lodash/difference'</span>)</span><br><span class="line"><span class="comment">// or ES6</span></span><br><span class="line"><span class="keyword">import</span> difference <span class="keyword">from</span> <span class="string">'lodash/difference'</span></span><br><span class="line">difference([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>])  <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure><h1 id="使用插件优化"><a href="#使用插件优化" class="headerlink" title="使用插件优化"></a>使用插件优化</h1><p>在简单场景下，以上两种方式足以解决问题。<br>而遇到复杂的数据对象时，我们不得不在一个文件中引入多个 Lodash 函数，这样就需要在文件中写多个<code>require</code>或<code>import</code>相关函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> remove <span class="keyword">from</span> <span class="string">'lodash/remove'</span></span><br><span class="line"><span class="keyword">import</span> uniq <span class="keyword">from</span> <span class="string">'lodash/uniq'</span></span><br><span class="line"><span class="keyword">import</span> invokeMap <span class="keyword">from</span> <span class="string">'lodash/invokeMap'</span></span><br><span class="line"><span class="keyword">import</span> sortBy <span class="keyword">from</span> <span class="string">'lodash/sortBy'</span></span><br><span class="line"><span class="comment">// more...</span></span><br></pre></td></tr></table></figure><p>正写到关键处却因为引入一个函数要拉到文件头部去定义引用而打乱了思路，很不爽！</p><p>于是我机智的到 Github 去搜索了webpack和lodash两个关键词的组合，排在首位的 lodash-webpack-plugin 就是为了解决这个问题而生。</p><p>使用时需要以下模块，其实除了前两个剩下的一般都已安装了：</p><p><code>$ npm i -S lodash-webpack-plugin babel-plugin-lodash babel-core babel-loader babel-preset-es2015 webpack</code><br><strong>配置：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"><span class="keyword">var</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      loader: <span class="string">'babel'</span>,</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        plugins: [<span class="string">'transform-runtime'</span>, <span class="string">'lodash'</span>],</span><br><span class="line">        presets: [<span class="string">'es2015'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> LodashModuleReplacementPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>babel-plugin-lodash</code>的配置，也就是<code>plugins: [&#39;lodash&#39;]</code>，并不是一定要在<code>loaders</code>中，也可以单独定义<code>babel</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"><span class="keyword">var</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      loader: <span class="string">'babel'</span>,</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  babel: &#123;</span><br><span class="line">    presets: [<span class="string">'es2015'</span>],</span><br><span class="line">    plugins: [<span class="string">'transform-runtime'</span>, <span class="string">'lodash'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> LodashModuleReplacementPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又或者是<code>.babelrc</code>文件中。</p><p>以上工作完成了，在每个你需要使用 lodash 函数的文件中只需要引用一次 lodash，即可调用任意函数而不会造成完全打包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line">_.add(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 打包时只会引入这一个函数模块</span></span><br></pre></td></tr></table></figure><p>注意：必须要使用 ES2015 的模块引用方式才有效。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>以上即是我目前所知道的几种方式，如果哪位朋友有更好的方式（比如只需要全局引入一次），请一定分享与我！😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。&lt;/p&gt;
&lt;p&gt;ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是
      
    
    </summary>
    
    
    
      <category term="WebPack" scheme="https://summxu.github.io/tags/WebPack/"/>
    
      <category term="Lodash" scheme="https://summxu.github.io/tags/Lodash/"/>
    
  </entry>
  
  <entry>
    <title>正确使用Vue指令的钩子函数</title>
    <link href="https://summxu.github.io/2019/vue-directive-hook/"/>
    <id>https://summxu.github.io/2019/vue-directive-hook/</id>
    <published>2019-03-24T07:28:24.000Z</published>
    <updated>2023-07-21T06:33:35.773Z</updated>
    
    <content type="html"><![CDATA[<p>在 Vue 中可以把一系列<strong>复杂的操作</strong>包装为一个指令。</p><blockquote><p><strong>什么是复杂的操作？</strong><br>我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段的掩盖等。我们总是期望以操作数据的形式来实现功能逻辑。</p></blockquote><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>对于自定义指令的定义，Vue2 有 5 个可选的钩子函数。</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li><li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。</li><li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind: 只调用一次，指令与元素解绑时调用。<br>接下来，定义一个简单的指令以验证这些钩子函数的触发时机。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-comp</span> <span class="attr">v-if</span>=<span class="string">"msg"</span> <span class="attr">:msg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"update"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"uninstall"</span>&gt;</span>卸载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"install"</span>&gt;</span>安装<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'bind'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inserted'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'componentUpdated'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'unbind'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> myComp = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1 v-hello&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        msg: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">'Hello'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        myComp: myComp</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">'Hi'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        uninstall: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        install: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">'Hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="页面加载时"><a href="#页面加载时" class="headerlink" title="页面加载时"></a>页面加载时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind</span><br><span class="line">inserted</span><br></pre></td></tr></table></figure><h2 id="组件更新时"><a href="#组件更新时" class="headerlink" title="组件更新时"></a>组件更新时</h2><p>点击“更新”按钮，更改数据触发组件更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update</span><br><span class="line">componentUpdated</span><br></pre></td></tr></table></figure><h2 id="卸载组件时"><a href="#卸载组件时" class="headerlink" title="卸载组件时"></a>卸载组件时</h2><p>点击“卸载”按钮，数据置空否定判断以触发组件卸载。</p><p><code>unbind</code></p><h2 id="重新安装组件时"><a href="#重新安装组件时" class="headerlink" title="重新安装组件时"></a>重新安装组件时</h2><p>点击“安装”按钮，数据赋值肯定判断以触发组件重新安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind</span><br><span class="line">inserted</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>从案例的运行中，对 5 个钩子函数的触发时机有了初步的认识。存疑的也就是<code>bind</code>和<code>inserted</code>、<code>update</code>和<code>componentUpdated</code>的区别了。</p><h3 id="bind-和-inserted"><a href="#bind-和-inserted" class="headerlink" title="bind 和 inserted"></a>bind 和 inserted</h3><p>据文档所说，插入父节点时调用 inserted，来个测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.parentNode)  <span class="comment">// null</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bind'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.parentNode)  <span class="comment">// &lt;div id="app"&gt;...&lt;/div&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'inserted'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别在两个钩子函数中输出父节点：<strong>bind 时父节点为 null，inserted 时父节点存在。</strong></p><h3 id="update-和-componentUpdated"><a href="#update-和-componentUpdated" class="headerlink" title="update 和 componentUpdated"></a><strong>update</strong> 和 <strong>componentUpdated</strong></h3><p>关于这两个的介绍，从字眼上看感觉是组件更新周期有关，继续验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.innerHTML)   <span class="comment">// Hello</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.innerHTML)   <span class="comment">// Hi</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentUpdated'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没毛病，<strong>update 和 componentUpdated 就是组件更新前和更新后的区别。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>文档说的没错…😒<br><a href="https://jsfiddle.net/imys/twbv0sov/1/" target="_blank" rel="noopener">Demo</a></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>根据需求的不同，我们要选择恰当的时机去初始化指令、更新指令调用参数以及释放指令存在时的内存占用等。</p><p>比较常见的场景是：用指令包装一些无依赖的第三方库以扩展组件功能。而一个健壮的库通常会包含：初始化实例、参数更新和释放实例资源占用等操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在 bind 钩子中初始化库实例</span></span><br><span class="line">        <span class="comment">// 如果需要使用父节点，也可以在 inserted 钩子中执行</span></span><br><span class="line">        el.__library__ = <span class="keyword">new</span> Library(el, binding.value)</span><br><span class="line">    &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 模版更新意味着指令的参数可能被改变，这里可以对库实例的参数作更新</span></span><br><span class="line">        <span class="comment">// 酌情使用 update 或 componentUpdated 钩子</span></span><br><span class="line">        el.__library__.setOptions(<span class="built_in">Object</span>.assign(binding.oldValue, binding.value))</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 释放实例</span></span><br><span class="line">        el.__library__.destory()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Vue 中可以把一系列&lt;strong&gt;复杂的操作&lt;/strong&gt;包装为一个指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是复杂的操作？&lt;/strong&gt;&lt;br&gt;我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>使用队列解决插队业务场景</title>
    <link href="https://summxu.github.io/2019/queue-solve-continuous/"/>
    <id>https://summxu.github.io/2019/queue-solve-continuous/</id>
    <published>2019-03-01T01:02:36.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<p>为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。<br>但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。<br>理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。</p><p>我觉得用“插队”来描述这个场景真是再好不过了。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>既然有人要“插队”，我们就要定义一个规则：先进先出。<br>也就是数据结构中的“队列”了。</p><p>javascript 中队列的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="keyword">var</span> queue = []</span><br><span class="line"><span class="comment">// 进队</span></span><br><span class="line">queue.push(<span class="number">1</span>)</span><br><span class="line">queue.push(<span class="number">2</span>)</span><br><span class="line">queue.push(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">queue.shift() <span class="comment">// 1</span></span><br><span class="line">queue.shift() <span class="comment">// 2</span></span><br><span class="line">queue.shift() <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="keyword">var</span> queue2 = []</span><br><span class="line"><span class="comment">// 进队</span></span><br><span class="line">queue2.unshift(<span class="number">1</span>)</span><br><span class="line">queue2.unshift(<span class="number">2</span>)</span><br><span class="line">queue2.unshift(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">queue2.pop() <span class="comment">// 1</span></span><br><span class="line">queue2.pop() <span class="comment">// 2</span></span><br><span class="line">queue2.pop() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestQueue = []</span><br><span class="line"><span class="keyword">var</span> XHR = <span class="function"><span class="keyword">function</span>(<span class="params">method, url, param</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>点击操作的入口函数，先创建请求进队。<br>因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myClick</span>(<span class="params">method, url, param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = requestQueue.push(XHR(method, url, param))</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">1</span>) &#123;</span><br><span class="line">        update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的永远是队列中的第一个请求。<br>当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。<br>如果存在未完成的请求，继续调用更新操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    requestQueue[<span class="number">0</span>].then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// request success</span></span><br><span class="line">        requestQueue.shift()</span><br><span class="line">        requestQueue.length &amp;&amp; update()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。&lt;br&gt;但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。&lt;br&gt;理想的状态是上一个请求结束后
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="Promise" scheme="https://summxu.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>如何为Canvas中特定图形绑定事件？</title>
    <link href="https://summxu.github.io/2019/canvas-event/"/>
    <id>https://summxu.github.io/2019/canvas-event/</id>
    <published>2019-02-14T10:47:15.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<p>Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。<br>但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。</p><p>我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件时，动态判断当前响应元素为目标子节点时再执行对应的操作。</p><p>这个思想同样也可以用在 Canvas 上，只需要为 <code>canvas</code> 元素绑定事件，事件响应时判断当前鼠标位置处于哪个图形之上，执行对应的操作。</p><h1 id="isPointInPath"><a href="#isPointInPath" class="headerlink" title="isPointInPath"></a>isPointInPath</h1><p><code>context.isPointInPath(x, y);</code></p><p>理论上讲，想要知道一个点是否处于一个图形之中，现成的算法应该是有很多了。不过难得 canvas 本身就提供了这样的函数，用来判断一个点是否处于当前路径中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ctx.isPointInPath(<span class="number">50</span>, <span class="number">100</span>))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>就像这样，当你创建一个矩形时，就会产生一个路径，此时就可以调用该方法去判断一个点是否存在于该路径。</p><p>产生路径的函数还有其他，比如：<code>lineTo()</code>、<code>clip()</code>、<code>arc()</code>、<code>arcTo()</code> 等。</p><h1 id="实现图形的事件绑定"><a href="#实现图形的事件绑定" class="headerlink" title="实现图形的事件绑定"></a>实现图形的事件绑定</h1><p>先来个简单的饼图吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> r = canvas.width / <span class="number">2</span>;</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#2196f3'</span>; <span class="comment">//蓝色</span></span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(r, r, r, <span class="built_in">Math</span>.PI * <span class="number">1</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#f44336'</span>; <span class="comment">//红色</span></span><br><span class="line">ctx.fill();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInPath</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx.isPointInPath(x, y);</span><br><span class="line">&#125;</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInPath(e.offsetX, e.offsetY)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在创建一个红蓝拼接的饼图，<code>isInPath</code> 方法判断一个点是否处于蓝色区。理想的结果是只有当鼠标点击区域为蓝色区域时才输出<code>hello。</code></p><p>但事实确不是如此，示例Demo。无论点击红色还是蓝色区域均会输出 <code>hello</code>，这是怎么回事呢</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>既然 <code>isPointInPath(x, y)</code> 的基于路径判断的，那我们就从路径入手。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#2196f3'</span>;</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.arc(r, r, r, <span class="built_in">Math</span>.PI * <span class="number">1</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#f44336'</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p>当我们把画图时的 <code>ctx.beginPath()</code> 去掉后，发现生成的图形变成一个红色的整圆了：示例Demo。</p><p><code>beginPath()</code> 用来重置路径，由于第一个半圆画完路径未重置，第二个半圆就绘制了两条路径。这似乎解释了上个问题的答案。</p><p>在 <code>isInPath(x, y)</code>函数中，由于路径没有重置，所以最终最终判断的不止是 <code>ctx.arc(r, r, r, 0, Math.PI * 1)</code> 这个路径，还有方法外的画红色圆的路径。两个路径加一起自然就是个整圆，所以无论蓝色区还是红色区都会输出。</p><h2 id="正确结果"><a href="#正确结果" class="headerlink" title="正确结果"></a>正确结果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInPath</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx.isPointInPath(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>isInPath</code> 函数，加入重置路径，结果正确输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。&lt;br&gt;但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。&lt;/p&gt;
&lt;p&gt;我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="Canvas" scheme="https://summxu.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件间样式污染大坑</title>
    <link href="https://summxu.github.io/2018/vue-scoped-keng/"/>
    <id>https://summxu.github.io/2018/vue-scoped-keng/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Vue 组件内的样式可以写在 Style 标签下，而各组件之间的样式冲突(污染)问题也十分常见，当然我们可以尽量避免起相同的类名，但项目较大的时候，Class类名时而会冲突。</p><p>当然 Vue官方也给了我们解决方法，就是定义了 scoped 这个属性的设置：</p><blockquote><p>这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover。</p></blockquote><blockquote><p>最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在 <style> 标签内。</p></blockquote><p>但是问题就在于 <strong>虽然加了scoped,但是却仍热无法锁住用@import引入的外部css文件</strong></p><p>这里的解决方法也比较神奇，就是把引入的css文件改为使用预处理器处理的 less sass 或者 styl 文件，具体原理暂时还不得而知</p><p>使用 /deep/ 来解决更深一级的标签</p></style></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道，Vue 组件内的样式可以写在 Style 标签下，而各组件之间的样式冲突(污染)问题也十分常见，当然我们可以尽量避免起相同的类名，但项目较大的时候，Class类名时而会冲突。&lt;/p&gt;
&lt;p&gt;当然 Vue官方也给了我们解决方法，就是定义了 scoped 这个属性的
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.$emit Promise 回调后的深坑</title>
    <link href="https://summxu.github.io/2018/vue-emit-keng/"/>
    <id>https://summxu.github.io/2018/vue-emit-keng/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有个登录需求，是 login.vue 属于 App.vue 的子组件，默认路由页面是进入 login.vue 因为你一开始需要验证登录用户，又要通过登录用户来进行</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有个登录需求，是 login.vue 属于 App.vue 的子组件，默认路由页面是进入 login.vue 因为你一开始需要验证登录用户，又要通过登录用户来进行&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Express + 模板引擎 + jQuery load 实现局部页面的异步加载</title>
    <link href="https://summxu.github.io/2018/express-jqueryload/"/>
    <id>https://summxu.github.io/2018/express-jqueryload/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目匿名评论系统的局部异步加载服务的实现</p></blockquote><h2 id="问题需求"><a href="#问题需求" class="headerlink" title="问题需求"></a>问题需求</h2><p>目前的论坛系统带有聊天室，在浏览帖子的同时可以随时聊天，这就意味着页面不能经常刷新，一是刷新就会重连服务器，导致一直断开重连的状态，二是刷新之后聊天记录消失，还要做数据的持久化，再者就是影响用户体验，所以最好的解决方案就是异步加载局部页面。前后端分离是挺好做，直接load加载本地页面就可以，但一和express结合起来就不知道该怎么办了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/5563645.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实仔细思考这个问题并不复杂，和前后端分离的模式是完全一模一样的，<strong>只是把本地要加载的局部页面换成了服务器上渲染出来的局部页面</strong> 。 这时就需要重新配置express的路由和 render 的页面分离，路由多了两条： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.get(<span class="string">'/main'</span>,(req,res) =&gt; &#123;</span><br><span class="line">  mongo.Post.find(<span class="function">(<span class="params">err, postdata</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> res.status(<span class="number">500</span>)</span><br><span class="line">    <span class="comment">/* 对象属性抽离，解决template陷入递归 */</span></span><br><span class="line">    <span class="comment">/* mogon取出的对象不正常，转换一下 */</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.stringify(postdata)</span><br><span class="line">    data = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    <span class="keyword">var</span> images = []</span><br><span class="line">    data.forEach(<span class="function">(<span class="params">element, a</span>) =&gt;</span> &#123;</span><br><span class="line">      images.push(element.images)</span><br><span class="line">      <span class="keyword">delete</span> element.images</span><br><span class="line">    &#125;);</span><br><span class="line">    res.render(<span class="string">'./components/main.html'</span>, &#123;</span><br><span class="line">      post: data,</span><br><span class="line">      images: images</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="string">'/sendpost'</span>,(req,res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'./components/sendpost.html'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>渲染出独立页面，这是各个页面的路径分配：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/52866315.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样两个在服务器路径中真实存在的页面出来了，通过浏览器也能访问，只不过没了样式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/99119243.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-12/67452684.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在客户端上写上这么一句，就大功告成了！！</p><p><code>$(&#39;.center .left&#39;).load(&quot;/main&quot;);</code><br><code>$(&#39;.center .left&#39;).load(&quot;/sendpost&quot;);</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;项目匿名评论系统的局部异步加载服务的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题需求&quot;&gt;&lt;a href=&quot;#问题需求&quot; class=&quot;headerlink&quot; title=&quot;问题需求&quot;&gt;&lt;/a&gt;问题需求&lt;/h2&gt;&lt;p&gt;目前的论坛系统
      
    
    </summary>
    
    
    
      <category term="Node.js" scheme="https://summxu.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://summxu.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB的查找find方法取出不正经对象</title>
    <link href="https://summxu.github.io/2018/mongo-object-files/"/>
    <id>https://summxu.github.io/2018/mongo-object-files/</id>
    <published>2018-09-09T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目匿名评论系统的MongoDB操作</p></blockquote><p>起因：用art-template来渲染前端页面的时候，数组里又包含了数组，这是模板引擎报了一个递归错误，貌似 <strong>模板引擎不支持递归？</strong> 想到的解决办法是对象的 <strong>数组属性</strong> 分离渲染，在删除对象属性时遇到了问题。</p><h2 id="delete-方法"><a href="#delete-方法" class="headerlink" title="delete 方法"></a>delete 方法</h2><p>原生 js 中支持 delete 方法，即删除对象里的某个属性，并且带有一个布尔类型的返回值，本事一个很简单的事情，放到普通代码中也很好实现，但是和MongoDB集合起来的时候，就出了问题。</p><p>原因就是 mongoDB find 出来的对象 <strong>不正经</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-9-10/77300539.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这里的id没有引号，原本js代码是不能执行，更不能直接删除对象的属性值，但是这里很奇怪的是，<strong>js居然不会报错？？</strong>而把这个对象格式直接复制到正常程序里却报错。</p><p>正确的解决办法就是转换一下 对象的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 对象属性抽离，解决template陷入递归 */</span><br><span class="line">/* mogon取出的对象不正常，转换一下 */</span><br><span class="line">var data = JSON.stringify(postdata)</span><br><span class="line">data = JSON.parse(data)</span><br></pre></td></tr></table></figure><h2 id="循环嵌套的异步"><a href="#循环嵌套的异步" class="headerlink" title="循环嵌套的异步"></a>循环嵌套的异步</h2><p>还遇到就是循环图片的时候，等循环结束要res。send（）图片数组，但是 fs.rename 是一个异步操作，要等到循环结束，可以这么操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if (req.files.pic.length &gt; 1) &#123;</span><br><span class="line">  var c = req.files.pic.length</span><br><span class="line">  req.files.pic.forEach(item =&gt; &#123;</span><br><span class="line">    var target_path = &apos;./upload/&apos; + item.name</span><br><span class="line">    fs.rename(&apos;./&apos; + item.path, target_path, function (err) &#123;</span><br><span class="line">      if (err) throw err;</span><br><span class="line">      postObj.images.push(target_path.replace(&apos;.&apos;,&apos;&apos;))</span><br><span class="line">      </span><br><span class="line">      c--;</span><br><span class="line">      if (c === 0 )&#123;</span><br><span class="line">        console.log(postObj.images)</span><br><span class="line">        postObj.save((err, result) =&gt; &#123;</span><br><span class="line">        if (err) throw err</span><br><span class="line">          res.send(&apos;success&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      // 删除临时文件夹文件, </span><br><span class="line">      fs.unlink(&apos;./&apos; + item.path, function () &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>用计数器判断循环的次数，为 0 时执行代码。</p><p>听说用递归也可以</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;项目匿名评论系统的MongoDB操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;起因：用art-template来渲染前端页面的时候，数组里又包含了数组，这是模板引擎报了一个递归错误，貌似 &lt;strong&gt;模板引擎不支持递归？&lt;/strong&gt; 想
      
    
    </summary>
    
    
    
      <category term="模板引擎" scheme="https://summxu.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
      <category term="MongoDB" scheme="https://summxu.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Web文件上传实现</title>
    <link href="https://summxu.github.io/2018/upload-files/"/>
    <id>https://summxu.github.io/2018/upload-files/</id>
    <published>2018-09-09T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目匿名评论系统的文件上传服务的实现</p></blockquote><p>做了个匿名评论论坛的小系统，里面涉及到了图片的上传，期间遇到的问题汇总。</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>首先上传文件还是要套到form表单里，并且文件上传是 input type = file 的一个标签‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;form1&quot; method=&quot;POST&quot; enctype =&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;label class=&quot;color&quot; for=&quot;exampleInputFile&quot;&gt;图片发表&lt;/label&gt;</span><br><span class="line">    &lt;input class=&quot;color&quot; type=&quot;file&quot;  id=&quot;exampleInputFile&quot; multiple=&quot;multiple&quot; onchange=&quot;imagechange(this)&quot; value=&quot;&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;textarea style=&quot;resize:none;&quot; name=&quot;content&quot; class=&quot;form-control&quot; rows=&quot;9&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">  &lt;button style=&quot;margin-top:10px;&quot; type=&quot;button&quot; onclick=&quot;upload1()&quot; class=&quot;btn btn-primary btn-lg btn-block&quot;&gt;发表发表发发表发表发表表发发表发表&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>这里上表单上传多了一个 <code>enctype =&quot;multipart/form-data&quot;</code> 属性，这是代表表单可以上传带有数据的文件。input type = file 的控件是文件标签，其中 <code>class=&quot;form-control&quot;</code> 是可以上传多个文件？ （但我实践上这个属性并没有什么用，最后还是在js里push了多文件上传） <code>onchange=&quot;imagechange(this)&quot;</code> 这个是在文件选择被改变的事件，这里把本dom对象传给js就不用麻烦的获取该dom对象了。</p><p>其中该dom节点有一个files对象，这是一个数组，里面放了文件的对象，按道理来说 <code>enctype =&quot;multipart/form-data&quot;</code>会在这里生效在多文件的时候往files里添加多个文件，但实际并没有，新的文件还是把旧的文件覆盖了。所以下面我手动push到了一个新的数组里。<strong>这地方还有待研究</strong></p><p>注意的是这里一个坑，<strong>当我把函数名命名为 upload 的时候，居然不会生效？</strong> 难道是函数命名有冲突？</p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function imagechange(a) &#123;</span><br><span class="line">  files.push(a.files);</span><br><span class="line">&#125;</span><br><span class="line">function upload1() &#123;</span><br><span class="line">  var fd = new FormData(document.getElementById(&apos;form1&apos;))</span><br><span class="line">  files.forEach(item =&gt; &#123;</span><br><span class="line">    fd.append(&apos;pic&apos;,item[0])</span><br><span class="line">  &#125;);</span><br><span class="line">  fd.append(&apos;postuser&apos;,&apos;小兵旭旭&apos;)</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: &quot;/sendpost&quot;,</span><br><span class="line">    type: &quot;POST&quot;,</span><br><span class="line">    data: fd,</span><br><span class="line">    sync: false,</span><br><span class="line">    processData: false,  // 告诉jQuery不要去处理发送的数据</span><br><span class="line">    contentType: false,   // 告诉jQuery不要去设置Content-Type请求头</span><br><span class="line">    success: function(response,status,xhr)&#123;</span><br><span class="line">      console.log(xhr);</span><br><span class="line">      if (response === &apos;success&apos;) &#123;</span><br><span class="line">        $(&apos;#sendpost&apos;).toggle();</span><br><span class="line">        location.reload()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js里是用了新的 FormData 对象，这个对象可以接收一个form表单的对象，并且 FormData <strong>可以自己添加属性的</strong>，他会一并跟随上传到服务器上。这里把文件数组添加了进去，再通过ajax异步发送到服务器，摆脱了页面停止响应的异步表单提交。</p><p>不过需要注意的是，直接console.log（FormData）的对象看上去是个空的对象，<strong>他传的参数是不直接在对象里的，而在对象的更深处</strong> 这种情况可以在 network 里查看到传出的参数</p><h2 id="Node…"><a href="#Node…" class="headerlink" title="Node…"></a>Node…</h2><p>在Node接收文件的时候也有许多坑，其中就是 express 接收post的请求，<strong>并且含有文件数据请求的时候，需要一个中间件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const multiparty = require(&apos;connect-multiparty&apos;)</span><br><span class="line">.use(multiparty(&#123;uploadDir:&apos;./linshi&apos;&#125;))</span><br><span class="line">var mutipartMiddeware = multiparty();</span><br><span class="line">.post(&apos;/sendpost&apos;, mutipartMiddeware, (req, res) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><p>{uploadDir:’./linshi’} 配置了该中间件接收到的文件存放的临时目录。并且该中间件接收到的res有以下几个有用的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">req.body: 请求体</span><br><span class="line">req.files: 接收到的文件数组</span><br><span class="line">req.files.file.path: 临时存放文件的路径</span><br><span class="line">req.files.file.name: 接收到的文件名字</span><br></pre></td></tr></table></figure><p>上面注意到，该中间件存放的是临时文件，并且文件名是随机命名的（req属性里有真实的文件名字），如果想正常保存上传来的文件，还是需要自己手动去处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var target_path = &apos;./upload/&apos; + req.files.pic.name</span><br><span class="line">fs.rename(&apos;./&apos; + req.files.pic.path, target_path, function (err) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  postObj.images.push(target_path.replace(&apos;.&apos;,&apos;&apos;))</span><br><span class="line">  // 删除临时文件夹文件, </span><br><span class="line">  fs.unlink(&apos;./&apos; + req.files.pic.path, function () &#123;</span><br><span class="line">    if (err) throw err;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这样一个基本的文件上传服务就完成了，当然还有很多判断需要自己手动去实现。这里是使用了 FormData 对象，MDN上也给出了不使用该对象的方法。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects" target="_blank" rel="noopener">FromData上传文件的方法</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files" target="_blank" rel="noopener">Ajax序列化及文件上传</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;项目匿名评论系统的文件上传服务的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做了个匿名评论论坛的小系统，里面涉及到了图片的上传，期间遇到的问题汇总。&lt;/p&gt;
&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://summxu.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue-resouce改为Axios之旅</title>
    <link href="https://summxu.github.io/2018/vue-axios/"/>
    <id>https://summxu.github.io/2018/vue-axios/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尤雨溪说了，vue2.0 将不再维护自己的原生请求插件 vue-resource 而推荐使用axios，所以以后就用axios来发送vue请求了。</p></blockquote><h2 id="使用-cnpm-安装-axios"><a href="#使用-cnpm-安装-axios" class="headerlink" title="使用 cnpm 安装 axios"></a>使用 cnpm 安装 axios</h2><p><code>cnpm install axios --save-dev</code></p><p>安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入<br>为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton。这里只说修改原型链的方式<br>改写原型链</p><h2 id="首先在-main-js-中引入-axios"><a href="#首先在-main-js-中引入-axios" class="headerlink" title="首先在 main.js 中引入 axios"></a>首先在 main.js 中引入 axios</h2><p><code>import axios from &#39;axios&#39;</code></p><p>这时候如果在其它的组件中，是无法使用 axios 命令的。所以我们将 axios 改写为 Vue 的原型属性</p><p><code>Vue.prototype.$http= axios</code></p><p>在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令<br>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  show() &#123;</span><br><span class="line">    this.$http(&#123;</span><br><span class="line">      method: &apos;get&apos;,</span><br><span class="line">      url: &apos;/user&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        name: &apos;virus&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置-axios"><a href="#配置-axios" class="headerlink" title="配置 axios"></a>配置 axios</h2><p>实际上只有 url 是必须的，完整的 api 可以参考<br><a href="https://link.jianshu.com/?t=https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://link.jianshu.com/?t=https://www.kancloud.cn/yunye/axios/234845</a></p><ol><li>对于get请求</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">  params:&#123;</span><br><span class="line">        name:&quot;virus&quot;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>对于POST请求</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;,&#123;</span><br><span class="line">  name:&quot;virus&quot; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>一次并发多个请求</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount()&#123;</span><br><span class="line">  return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">  return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(),getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function(acct,perms)&#123;</span><br><span class="line">    //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果</span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><ol start="4"><li>axios可以通过配置（config）来发送请求</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method:&quot;POST&quot;,</span><br><span class="line">  url:&apos;/user/1111&apos;,</span><br><span class="line">  data:&#123;</span><br><span class="line">    name:&quot;virus&quot; </span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>完整的请求还应当包括 .then 和 .catch</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.then(function(res)&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">.catch(function(err)&#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当请求成功时，会执行 .then，否则执行 .catch<br>这两个回调函数都有各自独立的作用域，如果直接在里面访问 this，无法访问到 Vue 实例,这时只要添加一个 .bind(this) 就能解决这个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then(function(res)&#123;</span><br><span class="line">    console.log(this.data)</span><br><span class="line">&#125;.bind(this))</span><br></pre></td></tr></table></figure><h2 id="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"><a href="#请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名" class="headerlink" title="请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名"></a>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config);</span><br><span class="line"></span><br><span class="line">axios.get(url[,config]);</span><br><span class="line"></span><br><span class="line">axios.delete(url[,config]);</span><br><span class="line"></span><br><span class="line">axios.head(url[,config]);</span><br><span class="line"></span><br><span class="line">axios.post(url[,data[,config]]);</span><br><span class="line"></span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;尤雨溪说了，vue2.0 将不再维护自己的原生请求插件 vue-resource 而推荐使用axios，所以以后就用axios来发送vue请求了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用-cnpm-安装-axios&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap响应式轮播图问题</title>
    <link href="https://summxu.github.io/2018/mobileweb-bootstrap-slide/"/>
    <id>https://summxu.github.io/2018/mobileweb-bootstrap-slide/</id>
    <published>2018-08-24T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>bootstrap 原生轮播图，因为轮播图是图片，所以为了做响应式就要麻烦一些，因为要涉及到图片的大小还有小屏幕的显示比例，把这次遇到的问题重新捋一下 。</p></blockquote><h1 id="两站单独设计"><a href="#两站单独设计" class="headerlink" title="两站单独设计"></a>两站单独设计</h1><p>因为PC端的轮播图是定高的，而且图片尺寸又大，但是移动端是百分比可缩小的，图片是小图，所以只能是两站单独设计，这是两站单独的CSS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.pc_img &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  height: 400px;</span><br><span class="line">  background: no-repeat center;</span><br><span class="line">  background-size: cover;</span><br><span class="line">&#125;</span><br><span class="line">.m_img &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.m_img img&#123;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样HTML的结构就可以这么放(用了模板引擎之后)，并且用了响应式工具使两者实现不同屏幕尺寸单独显示，不会同时显示出来。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt;</span><br><span class="line">  &lt;a class=&quot;m_img hidden-lg hidden-md hidden-sm&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot;&gt;&lt;img src=&quot;&#123; &#123;$value&#125; &#125;&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;pc_img hidden-xs&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot; style=&quot;background-image: url(&apos;&#123; &#123;$value&#125; &#125;&apos;);&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样虽说是视觉上看不出来有什么问题，但是在请求中两者都会同时请求，加载的图片太多，而且只是小屏幕的话，会多加载大屏幕中的大图片。。。</p><p>为了优化 不得不用js判断访问的屏幕大小。这样一系列的问题就来了。</p><h1 id="屏幕大小判断并单独加载"><a href="#屏幕大小判断并单独加载" class="headerlink" title="屏幕大小判断并单独加载"></a>屏幕大小判断并单独加载</h1><p>因为要单独判断当前屏幕的大小来指定到底要加载哪种图片，什么结构，又要做响应式，就会涉及到以下两点问题：</p><ol><li>判断页面大小，请求页面数据，渲染模板引擎</li><li>响应式实时判断页面大小，而不重复发送请求</li></ol><p>难点在第二点，我们只需要页面在需要请求数据的时候才不得不请求（如果现在是大屏幕，只请求大图片，如果是小屏幕，之请求小图片。如果从大屏幕响应式到了小屏幕，这时不得不再去求情一次）</p><p>做响应式，实时判断页面大小，又不用每次改变大小时去实时发送请。这时我们可以在特定的时候来请求数据，并把数据缓存下来，这里用的方法是绑定到 <strong>window</strong> 上一个全局对象的属性，并且用 <strong>回调函数</strong> 把全局对象的属性返回，具体代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* 判断访问来源 ， 以便使pc和m都加载 */</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">  function getData(callback) &#123;</span><br><span class="line">    /* 判断 window.data 是不是有缓存数据 */</span><br><span class="line">    if (window.data) &#123;</span><br><span class="line">      callback &amp;&amp; callback(window.data)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        type: &quot;GET&quot;,</span><br><span class="line">        url: &quot;./data.json&quot;,</span><br><span class="line">        dataType: &quot;json&quot;,</span><br><span class="line">        // async: false,</span><br><span class="line">        success: function (response) &#123;</span><br><span class="line">          window.data = response</span><br><span class="line">          callback &amp;&amp; callback(window.data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function render() &#123;</span><br><span class="line">    /* 这里通过回调函数获取传递过来的数据，是为了每次调用 render 的时候不ajax */</span><br><span class="line">    getData(function (response) &#123; </span><br><span class="line">      var data = &#123;&#125;</span><br><span class="line">      var iSMobile = window.innerWidth &lt; 750 ? true : false</span><br><span class="line">      if (iSMobile) &#123;</span><br><span class="line">        data.type = &apos;m&apos;</span><br><span class="line">        data.content = response.m</span><br><span class="line">        var html = template(&apos;carousel-content&apos;,data)</span><br><span class="line">        $(&apos;.banner .carousel-inner&apos;).html(html)</span><br><span class="line">        var html = template(&apos;carousel-indicators&apos;,data)</span><br><span class="line">        $(&apos;.banner .carousel-indicators&apos;).html(html)</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        data.type = &apos;pc&apos;</span><br><span class="line">        data.content = response.pc</span><br><span class="line">        var html = template(&apos;carousel-content&apos;,data)</span><br><span class="line">        $(&apos;.banner .carousel-inner&apos;).html(html)</span><br><span class="line">        var html = template(&apos;carousel-indicators&apos;,data)</span><br><span class="line">        $(&apos;.banner .carousel-indicators&apos;).html(html)</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  /* 这里要做响应式，所以要把数据渗透成全局对象 window.data */</span><br><span class="line">  $(window).on(&apos;resize&apos;,function () &#123; </span><br><span class="line">    render()</span><br><span class="line">    /* 通过js主动触发事件 */</span><br><span class="line">  &#125;).trigger(&apos;resize&apos;,function ()&#123;</span><br><span class="line">    render()</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>这里要注意一点，就是当数据请求和没请求的两种状态下，都要进行回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">success: function (response) &#123;</span><br><span class="line">  window.data = response</span><br><span class="line">  callback &amp;&amp; callback(window.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用 jQuery 的 trigger 方法来主动调用一次 window.onresize 就不用手动调用 render() 了。</p><h2 id="实现移动端滑动功能"><a href="#实现移动端滑动功能" class="headerlink" title="实现移动端滑动功能"></a>实现移动端滑动功能</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* 加载轮播图滑动 控制 prev 和 next */</span><br><span class="line">  var startX = 0</span><br><span class="line">  var endX = 0</span><br><span class="line">  isMove = false</span><br><span class="line">  $(&apos;#carousel-id&apos;).on(&apos;touchstart&apos;, function (e) &#123;</span><br><span class="line">    startX = e.originalEvent.touches[0].clientX;</span><br><span class="line">  &#125;).on(&apos;touchmove&apos;,function(e)&#123;</span><br><span class="line">    isMove = true</span><br><span class="line">    /* originalEvent 是原生事件的属性。 */</span><br><span class="line">    endX = e.originalEvent.touches[0].clientX;</span><br><span class="line">  &#125;).on(&apos;touchend&apos;,function(e)&#123;</span><br><span class="line">    lr = endX - startX</span><br><span class="line">    tmp = Math.abs( endX - startX)</span><br><span class="line">    if (isMove &amp;&amp; tmp &gt; 50) &#123;</span><br><span class="line">      if (lr &lt; 0) &#123;</span><br><span class="line">        $(&apos;.carousel&apos;).carousel(&apos;next&apos;)</span><br><span class="line">        console.log(&apos;next&apos;);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        $(&apos;.carousel&apos;).carousel(&apos;prev&apos;)</span><br><span class="line">        console.log(&apos;prev&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="关于模板引擎"><a href="#关于模板引擎" class="headerlink" title="关于模板引擎"></a>关于模板引擎</h1><p>模板引擎是个好东西，在获取到数据绑定到HTML页面上的时候，用DOM方式来操作确实有点难受，而且还弄的十分混乱，特别是当数据比较多的时候。这时候模板引擎能更友好的将数据渲染到页面上，甚至模板引擎本身提供了简单好用的一些方法</p><p>这里使用的模板引擎是 <a href="https://aui.github.io/art-template/zh-cn/docs/index.html" target="_blank" rel="noopener">Arttemplate</a><br>其他的模板引擎的使用方法都大同小异，基本的使用方法大概是这样：<br>js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 渲染html结构 ，放到 script 标签中--&gt;</span><br><span class="line">var html = template(&apos;arttemplate&apos;,&#123;value:data&#125;)</span><br><span class="line">&lt;!-- 把渲染好的HTML放到指定的容器中 --&gt;</span><br><span class="line">document.getEmementById(&apos;content&apos;).innerHTML(html)</span><br></pre></td></tr></table></figure><p>因为script 的 type 只要是不为 <strong>text/javascript</strong> 就不会别解析成js语法 所以很多时候方便存一些有结构型的数据到script标签中，模板引擎也是基于这个。 但是模板引擎 使用 { {  } } 里面的内容是 <strong>可以直接写 js 代码的</strong><br>html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;carousel-content&quot; type=&quot;text/x-arttemplate&quot;&gt;</span><br><span class="line">  &#123; &#123; if $data.type == &apos;m&apos; &#125; &#125;</span><br><span class="line">    &#123; &#123; each $data.content &#125; &#125;</span><br><span class="line">      &lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt;</span><br><span class="line">        &lt;a class=&quot;m_img hidden-lg hidden-md hidden-sm&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot;&gt;&lt;img src=&quot;&#123; &#123;$value&#125; &#125;&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;&lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#123; &#123; /each &#125; &#125;</span><br><span class="line">    &#123; &#123; else &#125; &#125;</span><br><span class="line">      &#123; &#123; each $data.content &#125; &#125;</span><br><span class="line">        &lt;div class=&quot;item &#123; &#123; $index ? &apos;&apos; : &apos;active&apos;&#125; &#125;&quot;&gt;</span><br><span class="line">          &lt;a class=&quot;pc_img hidden-xs&quot; alt=&quot;&#123; &#123;$index&#125; &#125; slide&quot; style=&quot;background-image: url(&apos;&#123; &#123;$value&#125; &#125;&apos;);&quot;&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#123; &#123; /each &#125; &#125;</span><br><span class="line">  &#123; &#123; /if &#125; &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script id=&quot;carousel-indicators&quot; type=&quot;text/x-arttemplate&quot;&gt;</span><br><span class="line">  &#123; &#123; each $data.content &#125; &#125;</span><br><span class="line">    &lt;li data-target=&quot;#carousel-id&quot; data-slide-to=&quot;&#123; &#123;$index&#125; &#125;&quot; class=&quot;active&quot;&gt;&lt;/li&gt;</span><br><span class="line">  &#123; &#123; /each &#125; &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样页面就能方便的处理数据了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;bootstrap 原生轮播图，因为轮播图是图片，所以为了做响应式就要麻烦一些，因为要涉及到图片的大小还有小屏幕的显示比例，把这次遇到的问题重新捋一下 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;两站单独设计&quot;&gt;&lt;a href=&quot;#两站
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="移动Web" scheme="https://summxu.github.io/tags/%E7%A7%BB%E5%8A%A8Web/"/>
    
      <category term="Bootstrap" scheme="https://summxu.github.io/tags/Bootstrap/"/>
    
      <category term="模板引擎" scheme="https://summxu.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Overflow实现圣杯布局</title>
    <link href="https://summxu.github.io/2018/grail-layout/"/>
    <id>https://summxu.github.io/2018/grail-layout/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工作过程中遇到了很多问题，也学到了很多知识，这次用Overflow来触发BFC以实现双飞翼布局，很简单的一件事。但中间却有点学问。</p></blockquote><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>所谓原理就是用Overflow来触发BFC（块级格式化范围）。</p><p>1.这是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。</p><p>2.另一个通俗点的解释是：在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 inline formatting context(行内格式化上下文) 里格式化。任何被渲染的元素都属于一个 box ，并且不是 block ，就是 inline 。即使是未被任何元素包裹的文本，根据不同的情况，也会属于匿名的 block boxes 或者 inline boxes。所以上面的描述，即是把所有的元素划分到对应的 formatting context 里。</p><p>总的来说BFC是和浮动划分开来，两者互不干扰，所以在center 中间的元素 宽度 100 % 不会铺满整个窗口</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>overflow<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">      float: left;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">      float: right;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">      overflow: hidden;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: pink;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.search</span> &#123;</span></span><br><span class="line">      height: 50%;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"search"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是要注意，left center 和 right 标签的位置顺序不能放错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;工作过程中遇到了很多问题，也学到了很多知识，这次用Overflow来触发BFC以实现双飞翼布局，很简单的一件事。但中间却有点学问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;hea
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Webpack CSS分类打包和html img不打包配置</title>
    <link href="https://summxu.github.io/2018/webpack-html-withimg/"/>
    <id>https://summxu.github.io/2018/webpack-html-withimg/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍两个webpack插件的使用</p></blockquote><h1 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h1><ol><li>在webpack打包之后的文件，往往都会打包到bundle.js中。但是为了目录的维护性，通常要把CSS单独分离出来这时需要</li></ol><h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><p><code>npm install extract-text-webpack-plugin --save-dev</code></p><p>配置上首先引入插件，然后再创建多个新的 extract 对象，并且在 plugins 引用他们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Extract = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">var</span> extractCss = <span class="keyword">new</span> Extract(<span class="string">'css/base.css'</span>)</span><br><span class="line"><span class="keyword">var</span> extractLess = <span class="keyword">new</span> Extract(<span class="string">'css/[name].css'</span>)</span><br><span class="line"><span class="keyword">var</span> extractScss = <span class="keyword">new</span> Extract(<span class="string">'css/[name].css'</span>)</span><br><span class="line"><span class="keyword">var</span> extractStyl = <span class="keyword">new</span> Extract(<span class="string">'css/[name].css'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  extractCss,</span><br><span class="line">  extractLess,</span><br><span class="line">  extractScss,</span><br><span class="line">  extractStyl</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>下一步就是修改原本的 rules loader规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: extractCss.extract( [<span class="string">'css-loader'</span>]) &#125;, <span class="comment">// 处理 CSS 文件的 loader</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: extractLess.extract([<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]) &#125;, <span class="comment">// 处理 less 文件的 loader</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: extractScss.extract([<span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]) &#125;, <span class="comment">// 处理 scss 文件的 loader</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>, <span class="attr">use</span>: extractStyl.extract([<span class="string">'css-loader'</span>, <span class="string">'stylus-loader'</span>]) &#125;, <span class="comment">// 处理 stylus 文件的 loader</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif|bmp|jpeg)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=1024&amp;name=[name].[ext]&amp;outputPath=./images&amp;publicPath=../images'</span>&#125;, <span class="comment">// 处理 图片路径的 loader</span></span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.com/package/extract-text-webpack-plugin" target="_blank" rel="noopener">https://www.npmjs.com/package/extract-text-webpack-plugin</a></p><p>虽然上面引入了 url-loader 来解析图片文件，但是html内的img：src图片并不能通过此方式正常解析，原因是因为，webpack不能正确找到引入的图片，解决方式有两种。、</p><ol><li>让webpack知道引入的图片路径<br><code>&lt;img src=&quot;${ require(&#39;..assets/logo.png&#39;) }&quot;&gt;</code></li><li>借助loader</li></ol><h2 id="html-withimg-loader"><a href="#html-withimg-loader" class="headerlink" title="html-withimg-loader"></a>html-withimg-loader</h2><p><code>npm install html-withimg-loader --save</code></p><p>在rule 中加入</p><p><code>{ test: /\.(htm|html)$/i, loader: &#39;html-withimg-loader&#39;} //处理html img 中的图片</code></p><p>完事！</p><p><a href="https://github.com/wzsxyz/html-withimg-loader" target="_blank" rel="noopener">https://github.com/wzsxyz/html-withimg-loader</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;介绍两个webpack插件的使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;问题还原&quot;&gt;&lt;a href=&quot;#问题还原&quot; class=&quot;headerlink&quot; title=&quot;问题还原&quot;&gt;&lt;/a&gt;问题还原&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在webp
      
    
    </summary>
    
    
    
      <category term="WebPack" scheme="https://summxu.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>Vue-loader版本遇到的坑</title>
    <link href="https://summxu.github.io/2018/vue-loader-version/"/>
    <id>https://summxu.github.io/2018/vue-loader-version/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习Vue.js和Webpack的路上遇到了不少问题,也找到了相对的解决办法, 这次记录下在vue-loader版本遇到的问题.</p></blockquote><h1 id="vue-loader简介"><a href="#vue-loader简介" class="headerlink" title="vue-loader简介"></a>vue-loader简介</h1><p>在webpack中加载第三方的文件支持,就要有第三方的文件解析工具,在vue的组件模板文件中,要有vue-loader的支持才可以.他可以将vue文件转换为JS模块；</p><h1 id="vue-loader特性"><a href="#vue-loader特性" class="headerlink" title="vue-loader特性"></a>vue-loader特性</h1><p>（1）ES2015默认支持<br>（2）允许对VUE组件的组成部分使用其他webpack loader;比如对&lt; style &gt;使用SASS（编译CSS语言），对&lt; template &gt;使用JADE（jade是一个高性能的模板引擎，用JS实现，也有其他语言的实现—php,scala,yuby,python,java，可以供给node使用）<br>（3）.vue文件中允许自定义节点，然后使用自定义的loader处理他们<br>（4）对&lt; style &gt;&lt; template &gt;中的静态资源当做模块来对待，并且使用webpack loaders进行处理<br>（5）对每个组件模拟出CSS作用域<br>（6）支持开发期组件的热重载<br>在编写vue应用程序时，组合使用webpack跟vue-loader能带来一个现代。灵活并且非常强大的前端工作流程；</p><h1 id="vue-loader-14-Version"><a href="#vue-loader-14-Version" class="headerlink" title="vue-loader@14 Version"></a>vue-loader@14 Version</h1><p>特性上面说了,<strong>允许对VUE组件的组成部分使用其他webpack loader;比如对&lt; style &gt;使用SASS（编译CSS语言），对&lt; template &gt;使用JADE</strong>，但是我在运行的过程中在vue组件模板文件下写stylus的样式一直报错</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-7-22/21405627.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-7-22/28336505.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>总是提示说需要装一个loader支持，但是我已经装了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-7-22/55563364.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>而且语法也有写错</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p5oqx8gut.bkt.clouddn.com/18-7-22/80861378.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这是我看到报错里提到了vue-loader，果然是vue-loader 的版本问题</p><h1 id="vue-loader-15-Version"><a href="#vue-loader-15-Version" class="headerlink" title="vue-loader@15 Version"></a>vue-loader@15 Version</h1><p>在最新的npm上装的是vue-loader 15.x 版本，但是现在直接npm装的最新版本的vue-loader 15 把这个功能给去除了,同时在vue-loader 15配置的时候还要引入一个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">15版本以上的vue-loader 需要插件支持 , 插件是个对象,这里引入的时候要转换成对象才行</span><br><span class="line">const &#123;VueLoaderPlugin&#125; = require(&apos;vue-loader&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  //15版本以上的vue-loader 需要插件支持</span><br><span class="line">  new VueLoaderPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>不仅如此，15版本的vue-loader还 <strong>去除了 对&lt; style &gt; 编译CSS预处理的支持</strong></p><p>现在暂时使用14版本的vue-loader，15版本的新特性和使用方法还需要进一步的学习。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在学习Vue.js和Webpack的路上遇到了不少问题,也找到了相对的解决办法, 这次记录下在vue-loader版本遇到的问题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;vue-loader简介&quot;&gt;&lt;a href=&quot;#vue-load
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
      <category term="WebPack" scheme="https://summxu.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>DIV的Height为什么不能100%</title>
    <link href="https://summxu.github.io/2018/div-height100/"/>
    <id>https://summxu.github.io/2018/div-height100/</id>
    <published>2018-05-29T16:00:00.000Z</published>
    <updated>2023-07-21T06:33:35.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>跟着百度IFE的基础做做，确实是遇到不少问题，在<strong><a href="http://ife.baidu.com/course/detail/id/40" target="_blank" rel="noopener">《三种简历》</a></strong>这一章，侧边导航就遇到了高度无法铺满的问题。</p></blockquote><h1 id="那为什么-height-100-不起作用"><a href="#那为什么-height-100-不起作用" class="headerlink" title="那为什么 height:100%; 不起作用"></a>那为什么 height:100%; 不起作用</h1><blockquote><p>在html布局中body内第一个div盒子对象设置100%高度height样式，是无法成功显示100%高度的。这个是因为body高度默认值为自适应的，所以及时设置body第一个布局div高度为百分比也是无效的，因为div解析上级高度为0，自然div height 100%实际高度也为0。</p></blockquote><blockquote><p>浏览器根本就不计算内容的高度，除非内容超出了视窗范围(导致滚动条出现)。或者你给整个页面设置一个绝对高度。否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑。</p></blockquote><blockquote><p>因为页面并没有缺省的高度值，所以，当你让一个元素的高度设定为百分比高度时，无法根据获取父元素的高度，也就无法计算自己的高度。换句话说，父元素的高度只是一个缺省值：height: auto;。当你要求浏览器根据这样一个缺省值来计算百分比高度时，只能得到undefined的结果。也就是一个null值，浏览器不会对这个值有任何的反应。</p></blockquote><blockquote><p>如果想让一个元素的百分比css高度height: 100%;起作用，你需要给这个元素的   <strong>所有父元素</strong>   的高度设定一个有效值。</p></blockquote><p><del>这里的  <strong>所有父元素</strong>  我发现其实是错误的，只要根元素 &lt; html &gt; 的高度设置好，其他子元素都是自动继承的。。而父元素块HTML本身是没有高度的</del></p><p>以上当我没说，还是必须要所有的父元素都要设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>为 根元素 &lt; html  &gt; 设置高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法二就是使用绝对定位，使div脱离标准流，也就是脱离了他的根元素 html</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: dodgerblue;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>Height:100%的方法，缺点缺非常显著，你在div内定义 padding 或者是 margin 就会把页面撑开，也就是说超过了 100%，就会出现一个非常不完美的滚动条。。 当然你可以用 <code>overflow: hidden;</code> 溢出隐藏，但是这样只是掩耳盗铃，滚动条是没了，页面的滚动却不受控制了。</p><p>神奇的CSS 。。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;跟着百度IFE的基础做做，确实是遇到不少问题，在&lt;strong&gt;&lt;a href=&quot;http://ife.baidu.com/course/detail/id/40&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《三种简历》&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>
