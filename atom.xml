<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小兵旭旭的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://summxu.github.io/"/>
  <updated>2023-12-25T09:35:30.926Z</updated>
  <id>https://summxu.github.io/</id>
  
  <author>
    <name>summxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试题</title>
    <link href="https://summxu.github.io/2023/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://summxu.github.io/2023/前端面试题/</id>
    <published>2023-12-21T01:49:38.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React组件为什么不能返回多个元素"><a href="#React组件为什么不能返回多个元素" class="headerlink" title="React组件为什么不能返回多个元素"></a>React组件为什么不能返回多个元素</h2><ol><li>React组件最后会编译为render函数，函数的返回值只能是1个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的</li><li>react的虚拟DOM是一个树状结构，树的根节点只能是1个，如果有多个根节点，无法确认是在哪棵树上进行更新</li></ol><ul><li>React组件怎样可以返回多个组件<ol><li>使用HOC（高阶函数）</li><li>使用React.Fragment，会创建一个虚拟节点，但不会渲染到真实DOM中</li><li>使用数组返回</li></ol></li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul><li>amd<br>浏览器的一种模块引用方式，define 定义模块（放大），使用 require 引入模块。</li><li>esm<br>esm 是 es6 的模块，通过 export、export default 导入，通过 import 引入</li><li>CommonJS<br>服务端（nodejs）中的引入方式，module.exports 导出 require 引入</li><li>umd<br>umd 是 amd 与 CommonJS 两种格式的兼容。既可以跑在浏览器，又可以跑在 Node 中</li></ul><h2 id="首屏优化策略"><a href="#首屏优化策略" class="headerlink" title="首屏优化策略"></a>首屏优化策略</h2><ul><li>减小入口文件积:<ol><li>webpack 开启压缩js 压缩css 压缩image 分离样式</li><li>路由组件动态加载</li></ol></li><li>静态资源http本地缓存,设置缓存响应头.</li><li>UI框架按需加载, 使用 import </li><li>开启GZip压缩</li><li>使用服务端渲染</li></ul><h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><ul><li>后端接口错误: 通过代码拦截接口,错误码判断</li><li>使用 try catch 捕获错误</li><li><code>Vue.config.errorHandler</code> 函数全局捕获错误</li><li>errorCaptured 生命周期捕获</li><li>getDerivedStateFromError 渲染备用UI, componentDidCatch 打印错误</li></ul><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="简单说一下-webpack-的构建流程"><a href="#简单说一下-webpack-的构建流程" class="headerlink" title="简单说一下 webpack 的构建流程"></a>简单说一下 webpack 的构建流程</h3><blockquote><p>webpack 从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从<strong>配置文件</strong>和<strong>shell</strong>语句中读取与合并参数，得到最终的参数。</li><li>开始编译：用得到的参数初始化 compiler 对象，加载所有配置的 plugin，执行 compiler 对象的 run 方法开始编译。</li><li>编译模块：根据配置中的 entry 找出所有的入口文件, 从入口文件出发，递归找出该模块依赖的模块，调用所有配置的 Loader 对模块进行编译，直到所有依赖文件都经过编译。</li><li>输出资源：编译完每个模块之后, 根据入口和模块之间的关系，组装成一个个包含多个模块的 chunk, 再把每个 chunk 转换成一个单独的文件加入到输出列表, 根据配置确定输出的路径和文件名，把文件内容写入到文件系统.</li></ol></blockquote><h3 id="Loader-和-Plugin-的区别"><a href="#Loader-和-Plugin-的区别" class="headerlink" title="Loader 和 Plugin 的区别"></a>Loader 和 Plugin 的区别</h3><ul><li>loader 本质上是一个函数, 在该函数对接收到的内容进行转换，返回转换后的结果。</li><li>编写loader的思路:<ol><li>开发规范: loader 支持链式调用,开发上遵循“单一职责.</li><li>loader 入参<code>content</code>是源文件的内容, 通过 <code>this.getOptions()</code> 拿到额外配置的参数.</li><li>loader 处理完之后的返回值可以通过<code>this.callback()</code>同步方式返回或者<code>this.async()</code>异步方式返回.</li><li>可以使用 schema-utils 来检验的我们的参数是否正确通过.</li></ol></li><li>plugin 可以扩展 webpack 的功能 ,webpack 实际上是一个微内核系统 (tapable), 在 Webpack 运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果. </li><li>编写plugin的思路:<ol><li>plugin 是一个构造函数, <code>consturctor</code> 能获取传入的配置参数</li><li>apply() 方法可以得到 compiler 对象, compiler 暴露了和 webpack 整个生命周期相关的 hooks </li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件hooks, 再使用相关的 API 对资源进行添加或者修改</li><li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并可以进行修改.</li></ol></li></ul><h3 id="tree-shaking-原理是什么"><a href="#tree-shaking-原理是什么" class="headerlink" title="tree shaking 原理是什么"></a>tree shaking 原理是什么</h3><blockquote><p>ES Module的静态语法分析更好优化, umd 引入更难优化</p><ul><li>先标记(添加注释)出模块导出值中哪些没有被动用过, .</li><li>使用 terser 删除掉这些没被用到的Dead Code。</li><li>package.json sideEffects 就是告知webpack可以安全的删除未用到的exports</li></ul></blockquote><h3 id="说一下-Babel-原理"><a href="#说一下-Babel-原理" class="headerlink" title="说一下 Babel 原理"></a>说一下 Babel 原理</h3><blockquote><p>babel 是一个代码转换工具, 在webpack中以loader 的形式存在, jsx es6 转 es5</p><ul><li>解析：将代码转换成 AST</li><li>转换：访问 AST 的节点进行变换操作生产新的 AST</li><li>生成：以新的 AST 为基础生成代码 详细参考 深入理解babel</li></ul></blockquote><h3 id="webpack-优化前端代码"><a href="#webpack-优化前端代码" class="headerlink" title="webpack 优化前端代码"></a>webpack 优化前端代码</h3><ul><li><p>loader</p><ol><li>url-loader：可以设置一个阈值，大于阈值会交给 file-loader，小于阈值时返回文件 base64 形式编码（处理图片）。</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5。</li></ol></li><li><p>plugin</p><ol><li>terser-webpack-plugin：压缩js文件</li><li>optimize-css-assets-webpack-plugin：压缩css代码。</li><li>mini-css-extract-plugin：分离样式文件，css 提取为单独文件，支持按需加载。</li><li>ModuleconcatenationPlugin：开启 Scope Hoisting。</li></ol></li><li><p>配置</p><ol><li>tree-shaking</li><li>splitChunks bundle 代码切割</li></ol></li></ul><h2 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h2><h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><h2 id="Nginx-amp-amp-Linux"><a href="#Nginx-amp-amp-Linux" class="headerlink" title="Nginx &amp;&amp; Linux"></a>Nginx &amp;&amp; Linux</h2><h2 id="mini-Vue"><a href="#mini-Vue" class="headerlink" title="mini Vue"></a>mini Vue</h2><h2 id="mini-React"><a href="#mini-React" class="headerlink" title="mini React"></a>mini React</h2><p>反思复盘，整理零散知识点，完善知识体系</p><h2 id="手写Promise（没有考虑链式调用）"><a href="#手写Promise（没有考虑链式调用）" class="headerlink" title="手写Promise（没有考虑链式调用）"></a>手写Promise（没有考虑链式调用）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建MyPromise类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数constructor，在执行这个类的时候需要传递一个执行器进去并立即调用</span></span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="comment">// 定义 fulfilled 情况下的返回值</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 定义 rejected 情况下的返回值</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 定义回调函数数组</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks = []</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">    executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义resolve函数，改变状态和调用回调</span></span><br><span class="line">  resolve = <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="comment">// 执行数组里的 回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(result))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义reject函数，改变状态和调用回调</span></span><br><span class="line">  reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>.reason = reason</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">    <span class="comment">// 执行数组里的 回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义then方法，接受两个回调函数</span></span><br><span class="line">  then = <span class="function">(<span class="params">onFulfilled, onRejected</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断接受的回调函数，并可以为空给默认值</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">result</span> =&gt;</span> result</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">      <span class="comment">// fulfilled状态，调用第一个 fulfilled回调函数</span></span><br><span class="line">      <span class="comment">// 添加到宏任务，尽量晚于执行器后</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; onFulfilled(<span class="keyword">this</span>.result) &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">      <span class="comment">// rejected状态，调用第二个 rejected回调函数</span></span><br><span class="line">      <span class="comment">// 添加到宏任务，尽量晚于执行器后</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; onRejected(<span class="keyword">this</span>.reason) &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果执行器中为异步（执行时机晚）不会立即改变状态，此时调用then一定是pending</span></span><br><span class="line">      <span class="comment">// 这个时候可以把回调函数保存到数组里，等待resolve/reject调用执行then</span></span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled)</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span> = <span class="function">(<span class="params">onRejected</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; onRejected(<span class="keyword">this</span>.reason) &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; resolve(<span class="string">'2秒之后执行then'</span>) &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res) &#125;)</span><br></pre></td></tr></table></figure><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><ol><li><h2 id="知识体系学习"><a href="#知识体系学习" class="headerlink" title="知识体系学习"></a>知识体系学习</h2></li><li><p>书籍</p></li><li><p>博客</p></li><li><p>开源社区</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React组件为什么不能返回多个元素&quot;&gt;&lt;a href=&quot;#React组件为什么不能返回多个元素&quot; class=&quot;headerlink&quot; title=&quot;React组件为什么不能返回多个元素&quot;&gt;&lt;/a&gt;React组件为什么不能返回多个元素&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>样式隔离与穿透</title>
    <link href="https://summxu.github.io/2023/%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB%E4%B8%8E%E7%A9%BF%E9%80%8F/"/>
    <id>https://summxu.github.io/2023/样式隔离与穿透/</id>
    <published>2023-11-23T06:49:38.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>css没有作用域，在书写的时候容易照成classname相同，产生样式污染、css规则层叠，单页面应用，多组件开发模式更容易出现此类问题，这就需要采用一些方法实现样式隔离。</p></blockquote><h3 id="BEM规范主动约束"><a href="#BEM规范主动约束" class="headerlink" title="BEM规范主动约束"></a>BEM规范主动约束</h3><p>  BEM 是 Block Element Modifiyer 的缩写，指块-元素-修饰符<code>.blockname-elementname-modifier</code></p><ul><li><p>Block 以元素本身所具备的功能为主</p></li><li><p>Element 以元素本身的位置、形状、描述为主</p></li><li><p>Modifier 以元素本身的状态、颜色为主</p><p>例如ElementUI中采用的BEM示例：<code>el-cascader-nodelabel</code>、<code>el-date-table-celltext</code></p><p>可以配合Less、Scss预处理器协同开发：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">  &amp;-item &#123;</span><br><span class="line">    &amp;<span class="selector-tag">-foucs</span>&#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="CSS-Moudle"><a href="#CSS-Moudle" class="headerlink" title="CSS Moudle"></a>CSS Moudle</h3><p>  css Moudle 是一种编译时的webpack插件，可以像js一样引入css，并且每一个css都是一个独立的模块，可以在使用的时候以变量的形式引入。在构建的过程中，通过映射关系把className生成唯一的hash，一般采用的css module插件是css-loader。</p><p>  在React中，css Module 默认（css-loader 文件名正则）需要对css文件命名做约束：以 <strong>.module.less/css/sass</strong> 结尾，不仅如此，css Module 还提供了一些特殊的伪类。</p><ul><li>:global，需要不对组件的类名进行哈希，保留原始类名，能起到样式覆盖的作用</li><li>:local，默认启用的伪类，需要不对组件的类名进行哈希</li></ul><h3 id="CSS-In-Js"><a href="#CSS-In-Js" class="headerlink" title="CSS In Js"></a>CSS In Js</h3><p>  其核心思想是将css直接写入到组件中，并不是通过引入的方式，而是通过js的形式去写css，然后在jsx中使用变量，ReactNative 默认采用的此方案。</p><h3 id="Vue-style-scoped"><a href="#Vue-style-scoped" class="headerlink" title="Vue style scoped"></a>Vue style scoped</h3><p>  使用 scoped 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。</p><p>  如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用一下深度作用选择器：<code>&gt;&gt;&gt;</code> <code>::v-deep</code> <code>::depp</code> <code>/deep/</code></p><h3 id="ShadowDOM"><a href="#ShadowDOM" class="headerlink" title="ShadowDOM"></a>ShadowDOM</h3><p>  ShandowDOM 是一组 JavaScript API ，用于封装影子DOM树附加到元素，与主文档分开呈现，并且能控制其关联的功能。这样可以保持元素的功能私有，也可以支持脚本化和样式化，不用担心与其他文档发生冲突，ShadowDOM可以用js创建：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const hostEle = document.querySelector(&quot;#host&quot;)</span><br><span class="line">const treeEle = document.createElement(&quot;span&quot;)</span><br><span class="line">treeEle.textContent = &quot;treeEle&quot;</span><br><span class="line">const rootEle = hostEle.attachShadow(&#123; mode: &apos;closed&apos; &#125;);// 不允许外部访问</span><br><span class="line">rootEle.appendChild(treeEle)</span><br></pre></td></tr></table></figure><p>  ShadowDOM是WebComponents的重要组成部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;css没有作用域，在书写的时候容易照成classname相同，产生样式污染、css规则层叠，单页面应用，多组件开发模式更容易出现此类问题，这就需要采用一些方法实现样式隔离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;BEM规范主动约束&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端八股文</title>
    <link href="https://summxu.github.io/2023/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>https://summxu.github.io/2023/前端八股文/</id>
    <published>2023-11-21T01:49:38.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传输协议-amp-amp-浏览器"><a href="#传输协议-amp-amp-浏览器" class="headerlink" title="传输协议&amp;&amp;浏览器"></a>传输协议&amp;&amp;浏览器</h2><h3 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h3><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li><li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li><li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器通过自己的私钥解密出会话密钥。</li><li>web 服务器通过会话密钥加密与客户端之间的通信。</li></ol><h3 id="从输入URL到页面加载的全过程"><a href="#从输入URL到页面加载的全过程" class="headerlink" title="从输入URL到页面加载的全过程"></a>从输入URL到页面加载的全过程</h3><ul><li>网络请求部分：<ol><li>检查是否有浏览器缓存结果或缓存标识。</li><li>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。</li><li>建立TCP连接：解析出IP地址后，根据IP地址和端口号，和服务器建立TCP连接。</li><li>发起HTTP请求：浏览器发起读取文档的HTTP请求，通过TCP三次握手请求数据。</li><li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器。</li><li>关闭TCP连接：通过四次挥手释放TCP连接。</li></ol></li><li>浏览器渲染部分：<ol><li>构建DOM树：文档分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li><li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li><li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置（计算的过程）</li><li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ol></li></ul><h3 id="浏览器的重绘与重排"><a href="#浏览器的重绘与重排" class="headerlink" title="浏览器的重绘与重排"></a>浏览器的重绘与重排</h3><ul><li>重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。</li><li>如何触发重排和重绘？<ol><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ol></li><li>如何避免重绘或者重排（性能优化）？<ol><li>集中改变样式，不要一条一条地修改 DOM 的样式。</li></ol></li></ul><h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><ul><li><p>浏览器会根据HTTP响应头的缓存标识，决定是否缓存结果,如果需要缓存则将该结果和缓存标识存入浏览器缓存中</p></li><li><p>浏览器每次发起请求前，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>缓存信息分为强缓存和协商缓存:</p><ol><li>控制强制缓存的字段分别是 Expires 和 Cache-Control。Cache-Control优先级高于Expires，一般控制的是强制缓存在什么时间之后失效。</li><li>控制协商缓存的字段分别有 Last-Modified 、Etag，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</li></ol></li><li><p>强制缓存判断过程：</p><ol><li>不存在该缓存结果和缓存标识，则直接向服务器发起请求.</li><li>存在该缓存结果和缓存标识，且结果尚未失效，直接返回缓存结果。</li><li>存在该缓存结果和缓存标识，但该结果已失效，则使用协商缓存。</li></ol></li><li><p>协商缓存时在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，</p></li><li><p>强制缓存判断结果：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果</li></ol></li></ul><h2 id="HTML-amp-amp-CSS"><a href="#HTML-amp-amp-CSS" class="headerlink" title="HTML&amp;&amp;CSS"></a>HTML&amp;&amp;CSS</h2><h3 id="script-标签中-defer-和-async的区别"><a href="#script-标签中-defer-和-async的区别" class="headerlink" title="script 标签中 defer 和 async的区别"></a>script 标签中 defer 和 async的区别</h3><p>  defer , async 都是异步加载</p><ul><li>如果是<code>&lt;script defer&gt;</code>标签，那么就会js脚本与html文档并行加载，并在html文档加载完后再执行js脚本。</li><li>如果是<code>&lt;script async&gt;</code>标签，那么js脚本与html文档并行加载，但是与前者不同的是，async在js脚本加载完后会立刻执行。（执行时不能加载html文档）</li></ul><h3 id="常见的-meta-标签有哪些？"><a href="#常见的-meta-标签有哪些？" class="headerlink" title="常见的 meta 标签有哪些？"></a>常见的 meta 标签有哪些？</h3><ul><li>charset 用来描述HTML文档的编码类型</li><li>keywords 页面关键字</li><li>description 页面描述</li><li>refresh 页面重定向和刷新</li><li>viewport 适配移动端，可以控制视口大小和比例</li><li>robots 搜索引擎索引方式</li></ul><h3 id="什么是盒模型？"><a href="#什么是盒模型？" class="headerlink" title="什么是盒模型？"></a>什么是盒模型？</h3><ul><li>在HTML中的所有的元素，都可以看作为一个盒子。</li><li>盒子的组成：margin、padding、border、content</li><li>盒模型的类型：<ul><li>标准盒模型(box-sizing:content-box)：<br>margin + padding + border + content</li><li>IE盒模型(box-sizing:border-box):<br>margin + content(padding + border)</li></ul></li></ul><h3 id="文档定位方案"><a href="#文档定位方案" class="headerlink" title="文档定位方案"></a>文档定位方案</h3><ol><li>普通流：<ul><li>元素按照HTML的先后位置上下布局</li><li>行内元素水平排列，当前行被占满之后换行，块级元素渲染为新的一行</li><li>所有元素的默认定位是普通流</li></ul></li><li>浮动：<ul><li>元素首先按照普通流的方式呈现，然后尽可能的向左或者向右偏移</li><li>浮动脱离了普通流元素</li></ul></li><li>绝对/相对定位<ul><li>绝对/相对脱离了普通流元素，不会影响兄弟元素</li></ul></li></ol><h3 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h3><ul><li>固定定位 fixed：元素相对于浏览器窗口的固定定位，定位元素脱离文档流，不占据空间。</li><li>绝对定位 absolute：元素相对于最近的<strong>已定位的父元素</strong>定位，定位元素脱离文档流，不占据空间。</li><li>相对定位 relative：元素出现在本来的位置上，但是可以设置left、top等定位属性，如果设置了定位属性，元素会进行移动，但是仍占据本来所在的空间，所以相对定位也可以层叠到其他元素上面。</li><li>默认定位 Static：默认值。没有定位，在文档流中，占据空间，不能使用定位属性和z-index。</li><li>粘性定位 sticky：依赖于用户的滚动，在 relative 与 fixed 定位之间切换，而当页面滚动超出目标区域时，它会使用fixed固定在目标位置，否则使用relative定位在本来的位置上。</li></ul><h3 id="浮动的解决办法"><a href="#浮动的解决办法" class="headerlink" title="浮动的解决办法"></a>浮动的解决办法</h3><blockquote><p>清除浮动解决的是浮动元素的父元素的高度问题。原因是父元素没有设置高度，原本的高度，是由子元素撑起来的。当子元素浮动的时候，子元素是脱离文档流的,而父元素还是文档流里，这个时候，父元素的content没有东西，所以父元素的height就变为原本没有设置的高度（为0）。</p></blockquote><ol><li><p>把父元素创建为BFC（<strong>计算BFC高度的时候，浮动元素也会参与计算</strong>）。</p></li><li><p>为<strong>下一个</strong>块级兄弟元素添加样式 clear:both</p></li><li><p>父元素使用after，创建块级子伪元素，设置属性 clear:both;</p><blockquote><p>clear:both;(告诉浏览器一直到这个元素都不需要浮动);</p></blockquote></li></ol><h3 id="BFC-Block-Formatting-Context-：块级格式化上下文"><a href="#BFC-Block-Formatting-Context-：块级格式化上下文" class="headerlink" title="BFC(Block Formatting Context)：块级格式化上下文"></a>BFC(Block Formatting Context)：块级格式化上下文</h3><ul><li>BFC是指<strong>块级元素</strong>区域在页面中的渲染（排版）规则：<ol><li>普通流的元素垂直方向的外边距会发生重叠。属于不同BFC的元素外边距不会发生重叠。</li><li>BFC元素是一个独立的容器，外面的元素不会影响里面的元素。</li><li>计算BFC高度的时候，BFC内部的浮动元素也会参与计算。</li></ol></li><li>BFC作用<ol><li>清除浮动（<strong>计算BFC高度的时候，浮动元素也会参与计算</strong>）</li><li>解决垂直外边距塌陷（<strong>属于不同BFC的元素外边距不会发生重叠</strong>）</li><li>防止兄弟float元素覆盖（<strong>BFC的区域不会与浮动元素的布局重叠,float也是BFC</strong>)</li></ol></li><li>BFC的创建（为元素添加属性触发BFC渲染）：<ol><li>overflow:hidden;</li><li>float:left;float:right;</li><li>position:absolute;position:fixed;</li><li>display属性为inline-block,table,table-cell,table-caption,flex,inline-flex,grid;</li></ol></li></ul><h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h3><blockquote><p>css选择器冲突（多个选择器选择了相同的元素）导致出现选择器优先级问题</p></blockquote><ul><li>选择器类型：!important &gt; 行内 &gt; ID &gt; 类\伪类\属性 &gt; 标签 &gt; 全局（*）</li><li>选择器层级：（兄弟、子、后代）选择器，层级多的覆盖层级少的</li><li>代码先后顺序：后出现的代码覆盖先出现的</li></ul><h3 id="CSS继承"><a href="#CSS继承" class="headerlink" title="CSS继承"></a>CSS继承</h3><blockquote><p>css三大特性：继承、层叠、优先级</p></blockquote><ul><li>字体属性：font</li><li>文本属性：line-height、color、text-align</li><li>元素可见性：visibility: hidden</li><li>表格布局：border-spacing</li><li>列表属性：list-style</li></ul><h3 id="隐藏元素的方法"><a href="#隐藏元素的方法" class="headerlink" title="隐藏元素的方法"></a>隐藏元素的方法</h3><ul><li>display: none 隐藏元素，不占据页面位置</li><li>opactiy: 0 设置元素完全透明，占据页面位置</li><li>visibility: hidden 隐藏元素，占据页面位置</li></ul><h3 id="CSS-单位"><a href="#CSS-单位" class="headerlink" title="CSS 单位"></a>CSS 单位</h3><ul><li>px 在屏幕上显示出的绝对像素</li><li>em 相对与父级元素font-size比例的长度/大小（1em = 父级元素的font-size(px))</li><li>rem 相对与HTML元素font-size比例的长度/大小（1em = HTML元素的font-size(px))</li><li>% 相对于父级长度/大小的百分比</li><li>vw 把屏幕的宽度切成100份，每一份就是1vw</li><li>vh 把屏幕的高度切成100份，每一份就是1vh</li></ul><h3 id="响应式布局方案"><a href="#响应式布局方案" class="headerlink" title="响应式布局方案"></a>响应式布局方案</h3><ol><li>媒体查询：一套代码针对电脑、pad和移动设备，屏幕宽度相差悬殊的时候，使用@media(min-width) and (max-width)方法划分区域，单独做适应不同屏幕宽度的样式适配。</li><li>rem 计算屏幕宽度，动态设置html字体大小，等比缩放整体页面。</li><li>postcss 通过设计稿比例，在编译过程中把px转换成 vm/rem 单位。</li></ol><h3 id="用CSS实现三角符号"><a href="#用CSS实现三角符号" class="headerlink" title="用CSS实现三角符号"></a>用CSS实现三角符号</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过元素border的渲染机制实现的 */</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><ol><li><code>typeof &#39;123&#39;</code> 可以区分基本数据类型，但引用数据类型都返回Object</li><li><code>&#39;123&#39; instanceof String</code> 可以区分引用数据类型，但不能区分基本数据类型</li><li><code>Object.prototype.toString.call(&#39;123&#39;)</code> 返回 <code>[Object Array]</code> 可以判断所有数据类型</li></ol><h3 id="作用域-amp-amp-闭包"><a href="#作用域-amp-amp-闭包" class="headerlink" title="作用域 &amp;&amp; 闭包"></a>作用域 &amp;&amp; 闭包</h3><ul><li>作用域<ol><li>全局作用域，在js中的任何地方都可以访问。</li><li>函数作用域，只能在函数内部或子函数中访问。</li><li>块级作用域 { }，if for…</li></ol></li><li>变量提升<ol><li>var 的变量声明会提升到<strong>当前作用域（无视块级作用域）</strong>最顶部在进行赋值。</li><li>function的声明会提升到<strong>当前作用域（无视块级作用域）</strong>最顶部，function 的提升优先级大于 var。</li><li>const 和 let 不会提升，并且之在块级作用域生效，他们在作用域内只能被声明一次</li><li>const 声明的时候必须赋值，let 可以只声明不赋值，默认是 undefind</li><li>const 的值不可修改，但引用类型的赋值，可以修改其属性。</li></ol></li><li>闭包<ul><li>函数在执行时会形成属于函数的作用域，在函数执行完后，作用域就会被清理，内存也会被回收。但是在函数嵌套的时候，内部函数可以访问上级函数的变量，导致即使上级函数执行完，也不会被销毁，这时的内部函数就是闭包。</li><li>特点：</li></ul><ol><li>保护外部函数的变量不受污染</li><li>延长局部变量的生命周期（不会被回收）</li><li>会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</li></ol><ul><li>用途：</li></ul><ol><li>节流、防抖记录timer</li><li>模仿块级作用域创建模块</li></ol></li></ul><h3 id="对象-amp-amp-原型-amp-amp-原型链"><a href="#对象-amp-amp-原型-amp-amp-原型链" class="headerlink" title="对象 &amp;&amp; 原型 &amp;&amp; 原型链"></a>对象 &amp;&amp; 原型 &amp;&amp; 原型链</h3><ul><li>创建对象：<ol><li>字面量 <code>const obj = {}</code></li><li>Object.create(prototype, descriptors)</li><li>构造函数 <code>function Person() { this.name = &#39;张三&#39; };new Person()</code>，构造函数拥有<strong>constructor</strong>属性，也有原型的概念。</li></ol></li><li>原型：<br>在 JS 中，每创建一个对象时，对象中都会包含一些预定义的属性。其中每个构造函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。</li><li>原型链：<br>构造函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现对象的继承，还有一个<strong>原型链指针<strong>proto</strong></strong>，该指针指向的是上层原型对象，因此可以利用<strong>proto</strong>一直向上引用到 Object 再到 null 。这样就形成了原型链的概念。</li><li>特点：<br>JavaScript对象是通过引用来传递的，创建的每个新对象实例中并没有一份属于自己的原型副本，所以修改原型时，与之相关的对象也会继承这一改变。 </li></ul><h3 id="new-的实现步骤"><a href="#new-的实现步骤" class="headerlink" title="new 的实现步骤"></a>new 的实现步骤</h3><ol><li>创建一个新的空对象。</li><li>把对象的原型<code>__proto__</code>指向传入的构造函数的原型链<code>prototype</code>.</li><li>把构造函数的this，绑定到新对象上（对象添加了构造函数的新属性）。</li><li>判断构造函数的返回值，如果是值类型则返回这个对象，如果是引用类型，就返回这个引用类型的对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newFun = <span class="function">(<span class="params">Fun, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = &#123;&#125;</span><br><span class="line">    newObj.__proto__ = Fun.prototype</span><br><span class="line">    <span class="keyword">const</span> result = Fun.apply(newObj, args)</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : newObj</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="this-amp-amp-apply-amp-amp-call-amp-amp-bind"><a href="#this-amp-amp-apply-amp-amp-call-amp-amp-bind" class="headerlink" title="this &amp;&amp; apply &amp;&amp; call &amp;&amp; bind"></a>this &amp;&amp; apply &amp;&amp; call &amp;&amp; bind</h3><ul><li>apply 接受参数的是数组<code>Function.apply(this,[arg1,arg2])</code></li><li>call 接受参数的是参数列表<code>Function.call(this,arg1,arg2)</code></li><li>bind 返回一个改变了this的新函数<code>Function.bind(this)(arg1,arg2)</code></li><li>this</li></ul><ol><li>全局作用域下或者作为普通函数执行时，this指向window。</li><li>当函数作为对象的方法被调用时，this就会指向该对象。</li><li>new 会改变函数的this指向，构造函数中的this指向的是实例对象。</li><li>箭头函数的this指向当前函数在哪个对象下面。</li><li>Function原型上的apply、call、bind改变this指向到指定的调用函数。</li></ol><h3 id="事件循环-EventLoop"><a href="#事件循环-EventLoop" class="headerlink" title="事件循环 EventLoop"></a>事件循环 EventLoop</h3><p>  JS是单线程的，为了防止一个<strong>函数</strong>执行时间过长阻塞后面的代码，所以区分了同步代码和异步队列，异步队列又分为宏任务队列和微任务队列，通过先后顺序反复将不同任务压入执行栈中执行的过程就形成了事件循环。因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列，事件循环是由浏览器来实现的。</p><ol><li>函数入执行栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把<strong>回调函数</strong>放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>当同步代码执行栈执行完毕，Event Loop开始找微任务队列，并把微任务放到执行栈中执行。</li><li>微任务执行栈执行完毕后，进入宏任务队列。在一轮循环里，<strong>先执行一个宏任务</strong>，执行完成后查看微任务队列是否有任务，有的话，清空微任务队列，在执行下一个红任务，再继续查找微任务队列，如此循环，清空微任务队列，直至清空所有的任务。</li></ol><ul><li>宏任务（浏览器提供的）：<ol><li>setTimeout</li><li>setInterval</li><li>ajax</li><li>onClick</li></ol></li><li>微任务（语言本身提供的）<ol><li>Promise.then</li><li>async await</li></ol></li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><p>  vue.js是MVVM框架，数据变化的时候，视图也会自动更新。采用数据劫持+发布者-观察者模式的方式，在数据变动时触发相应的监听回调，从而使视图更新。</p><ul><li><p><strong>Observer（数据监听器）</strong> : Observer的核心是遍历data对象里的属性，通过Object.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。在被遍历到的每一个属性中，都会添加一个Dep的实例，它内部有个subscribes队列，保存着依赖本数据的观察者，当本数据发生变化时，调用dep.notify()通知观察者watcher。</p></li><li><p><strong>Watcher（观察者）</strong> : Watcher的实例有很多，它可以是视图模板中使用的变量、计算属性、侦听器。</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己。</li><li>自身必须有一个update()方法。</li><li>待属性变动dep.notice()通知时，调用自身的update()方法，并触发Compile中绑定的回调.</li></ol></li><li><p><strong>Compile（模板解析器）</strong> : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，每个指令对应的节点绑定更新函数，一旦数据有变动，收到通知，更新视图。</p></li></ul><h3 id="Vue-diff-的详细过程"><a href="#Vue-diff-的详细过程" class="headerlink" title="Vue diff 的详细过程"></a>Vue diff 的详细过程</h3><p>  diff 算法是一种树节点差异比对的高效算法,其有两个特点, 遍历的整体策略为：深度优先遍历，同层比较<br>  在vue中作用于<code>虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较</code>.</p><ul><li>vue中diff的步骤分析<ol><li>在 update() 方法的内部,执行 ptach 方法<code>给真实的DOM打补丁</code>,接受两个参数,oldvnode和newvnode</li><li>如果节点是同类标签直接替换, 否则继续执行 patchVnode 方法</li><li>如果oldVnode 没有子节点,newVnode有子节点,直接增加新的子节点.</li><li>如果oldVnode 有子节点,newVnode没有子节点,直接删除旧的子节点.</li><li>如果都有子节点调用 updateChild() 方法进行diff比对.</li></ol></li><li><code>首位指针法</code>比对过程<ol><li>依次比较(oldStart==newStart、oldStart==newEnd、oldEnd==newStart、oldEnd==newEnd)</li><li><code>都比对成功后</code>以newVnode的渲染结果为准</li><li><code>每次比对成功后</code>首节点和尾节点向中间移动靠拢</li><li>当新节点中有一个首节点移动到尾节点的右侧时终止比较</li></ol></li><li>首位指针法匹配失败,说明没有节点可以复用<ol><li>比对节点的key值,如果相同则复用</li><li>创建一个新的 dom 节点放到当前首节点的位置</li></ol></li></ul><h3 id="React-Vue-项目中-key-的作用"><a href="#React-Vue-项目中-key-的作用" class="headerlink" title="React/Vue 项目中 key 的作用"></a>React/Vue 项目中 key 的作用</h3><ol><li>是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM;在vue的diff函数中，会根据key去数组中对比新旧节点，而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找，map映射的速度更快。</li><li>在v-for的时候，vue采用了“就地复用”的更新策略，如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是使用key作为索引来显示已被渲染过的每个元素，重复的key会造成渲染错误。</li></ol><h3 id="nextTick的作用和实现原理"><a href="#nextTick的作用和实现原理" class="headerlink" title="nextTick的作用和实现原理"></a>nextTick的作用和实现原理</h3><p>  nextTick是解决vue在数据变化操作之后，立即获取DOM元素而取不到的问题。nextTick接受一个回调函数作为参数，同时在vue3中，nextTick会返回一个Promise。</p><p>  Vue在更新DOM时是异步执行的，更改响应式状态时，Vue将开启一个缓存队列，<strong>同一事件循环</strong>如果一个watcher被多次触发，只会被推入到队列中一次，直到下一个“tick”才一起执行，这样避免不必要的计算。</p><ul><li>vue2中的DOM异步更新和nextTick主要使用了宏任务和微任务执行回调的时机来实现，根据执行环境分别尝试采用Promise、MutationObserver、setTimeout。nextTick的任务队列在DOM更新的后面。</li><li>vue3中的nextTick默认采用了Pormise来实现，并且他默认返回一个Promise，这样同时也能使用 await 在事件循环结束之后操作DOM。</li></ul><h3 id="Vue3的新特性"><a href="#Vue3的新特性" class="headerlink" title="Vue3的新特性"></a>Vue3的新特性</h3><ol><li>响应式原理改变，数据劫持由Object.defineProperty改为Proxy/Reflect。<ul><li>defineProperty只能劫持对象里某个属性的getter/setter，需要对vueData里的对象进行遍历递归，后添加的属性也无法实现响应式拦截，还需要重写大量的js原型实现完美响应式。</li><li>而Porxy利用ES6原生实现可以劫持整个对象的增删改查操作，配合上Reflect，提升了响应式实现的性能。</li><li>Reflect是为了操作对象而提供的API，他能把对象的操作都变成函数的行为，配合Proxy它能起到的作用是:<ol><li>触发代理对象的劫持时保证正确的 this 上下文指向</li><li>能使框架避免在操作对象时更健壮，避免一些报错。</li></ol></li></ul></li><li>Composition API的引入能更加灵活地组织代码和重用组件逻辑，不像Options API那样需要写在特定的代码块内，常见的新API有：<ul><li>createApp 创建应用实例，相当于 new Vue</li><li>provide、inject 局部范围内组件的传值，类似React useContext</li><li>ref、reactive 定义响应式数据。ref 定义基本结构数据，reactive 定义复杂结构数据<br>(Proxy只能<strong>代理对象</strong>，而ref又可以定义一个响应式的基本属性，vue在ref内部把基本属性包装成了对象，对象里只有一个属性是 <strong>value</strong>)</li><li>computed 计算属性，有返回值，依赖数据发生改变就会重新计算</li><li>watch、watchEffect watch 是监听一个值的变化，watchEffect是收集依赖数据发生变化就执行</li><li>toRef、toRefs 解构单个reactive中的数据和解构整个reactive中的数据 </li><li>getCurrentInstance 获取当前vue组件的实例</li></ul></li><li>teleport、Suspense、Fragment组件<ul><li>teleport 控制渲染位置，组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去，多用于modal弹出控制位置</li><li>Suspense 当要加载的组件都满足条件时，才会进行渲染。</li><li>Fragment 组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中。</li></ul></li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React是一个网页UI库，它主要通过组件化的方式解决视图层开发复用的问题。</p><ol><li>数据驱动视图：如果要渲染界面，不应该直接操作DOM，而是通过修改数据(state或prop)，数据驱动视图更新</li><li>组件化：每个组件都符合开放-封闭原则，封闭是针对渲染工作流来说的，指的是组件内部的状态都由自身维护，只处理内部的渲染逻辑。开放是针对组件通信来说的，指的是不同组件可以通过props（单项数据流）进行数据交互。</li><li>虚拟DOM：浏览器的DOM操作是一个昂贵的操作，很耗性能，因此产生了虚拟DOM。虚拟DOM是对真实DOM的映射，React通过新旧虚拟DOM对比，得到需要更新的部分，实现数据的增量更新。同时React因为虚拟DOM带来了很强的通用性，一次学习随处编写，比如ReactNative。这使得React的范围足够广，web、native都可以开发，这也是React的优势。</li></ol><p>React的灵活性诞生出了很多优秀的设计模式，类组件和函数组件，hooks，hoc这些概念。</p><p>React作为视图层的框架，他并没有提供一揽子的解决方案，在开发大型应用时需要在社区寻找、整合解决方案，在技术选型和学习上造成了一些成本。</p><h3 id="React18有哪些更新？"><a href="#React18有哪些更新？" class="headerlink" title="React18有哪些更新？"></a>React18有哪些更新？</h3><ol><li>setState自动批处理</li><li>引入了新的root API，支持new concurrent renderer(并发模式的渲染)</li><li>去掉了对IE浏览器的支持，react18引入的新特性全部基于现代浏览器，如需支持需要退回到react17版本</li><li>flushSync</li><li>react组件返回值更新，支持null和undefined</li><li>Suspense不再需要fallback捕获</li><li>Concurrent Mode</li><li>hooks增加：useSyncExternalStore、usId、useInsertionEffect</li></ol><h3 id="jsx-转换过程"><a href="#jsx-转换过程" class="headerlink" title="jsx 转换过程"></a>jsx 转换过程</h3><ul><li>jsx的解析和转换主要依靠Babel来实现，通过Babel转换成React.createElement对节点的描述</li><li>React.createElement函数，它接收三个参数，分别是type元素类型，props元素属性，children子元素</li><li>babel转换是通过元素的首字母大小写来判断是原生元素还是自定义组件。</li><li>React.createElement生成虚拟DOM树，通过几种不同的节点类型来判断虚拟DOM生成：<ol><li>原生标签节点</li><li>文本节点</li><li>函数组件</li><li>类组件</li></ol></li><li>最后通过 ReactDom.render() 根据不同类型挂载成真实DOM.</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期指的是组件实例从创建到销毁的流程，函数组件没有生命周期，只有类组件才有，因为只有class组件会创建组件实例<br>组件的生命周期可以分为挂载、更新、卸载阶段</p><ul><li>挂载：<ol><li>constructor 可以进行state和props的初始化</li><li>static getDerivedStateFromProps</li><li>render</li><li>componentDidMount 第一次渲染后调用，可以访问DOM，进行异步请求和定时器、消息订阅</li></ol></li><li>更新（当组件的props或state变化会触发更新）<ol><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate 返回一个布尔值，默认返回true，可以通过这个生命周期钩子进行性能优化，确认不需要更新组件时调用</li><li>render</li><li>getSnapShotBeforeUpdate</li><li>componentDidUpdate 在组件完成更新后调用</li></ol></li><li>卸载<ol><li>componentWillUnmount 组件从DOM中被移除的时候调用</li></ol></li><li>错误捕获<ol><li>static getDerivedStateFromError 在errorBoundary中使用</li><li>componentDidCatch</li></ol></li></ul><h3 id="React事件机制"><a href="#React事件机制" class="headerlink" title="React事件机制"></a>React事件机制</h3><p>React基于浏览器的事件机制实现了一套自身的事件机制，它符合W3C规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等<br>这么设计的目的：</p><ol><li>在底层磨平不同浏览器的差异，React实现了统一的事件机制，我们不再需要处理浏览器事件机制方面的兼容问题</li><li>React把握了事件机制的主动权，实现了对所有事件的中心化管控</li><li>React引入事件池避免垃圾回收，在事件池中获取或释放事件对象，避免频繁的创建和销毁</li></ol><ul><li>DOM事件流<br>事件在目标元素和祖先元素间的触发顺序。</li></ul><ol><li>捕获阶段：事件从最顶层元素 window 一直传递到目标元素的父元素。</li><li>目标阶段：事件到达目标元素，如果事件指定不冒泡，那就会在这里中止。</li><li>冒泡阶段：事件从目标元素父元素向上逐级传递直到最顶层元素 window。<ul><li>事件绑定方式：<ol><li>在html 中使用 onclick，或者在js中使用 btn.onclick()</li><li>使用addEventListener</li></ol></li></ul></li></ol><ul><li><p>React实现事件的过程</p><ol><li><p>绑定（建立合成事件与原生事件的对应关系）</p><ul><li><p><strong>registrationNameModule</strong>, 它建立了React事件到plugin的映射，它包含React支持的所有事件的类型，用于判断一个组件的prop是否是事件类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onBlur:SimpleEventPlugin,</span><br><span class="line">  onClick:SimpleEventPlugin,</span><br><span class="line">  onClickCapture:SimpleEventPlugin,</span><br><span class="line">  onChange:ChangeEventPlugin,</span><br><span class="line">  onChangeCapture:ChangeEventPlugin,</span><br><span class="line">  onMouseEnter:EnterLeaveEventPlugin,</span><br><span class="line">  onMouseLeave:EnterLeaveEventPlugin,</span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>registrationNameDependencies</strong>， 这个对象记录了React事件到原生事件的映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onBlur: [&apos;blur&apos;],</span><br><span class="line">  onClick: [&apos;click&apos;],</span><br><span class="line">  onClickCapture: [&apos;click&apos;],</span><br><span class="line">  onChange: [&apos;blur&apos;, &apos;change&apos;, &apos;click&apos;, &apos;focus&apos;, &apos;input&apos;, &apos;keydown&apos;, &apos;keyup&apos;, &apos;selectionchange&apos;],</span><br><span class="line">  onMouseEnter: [&apos;mouseout&apos;, &apos;mouseover&apos;],</span><br><span class="line">  onMouseLeave: [&apos;mouseout&apos;, &apos;mouseover&apos;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>plugins对象, 记录了所有注册的插件列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>派发(针对同一个事件，即使可能存在多次回调，document（container）也只需要注册一次监听)</p><ul><li>React注册到document(container)上的并不是一个某个DOM节点具体的回调逻辑，而是一个统一的事件分发函数dispatchEvent - &gt; 事件委托思想</li><li>事件触发的本质是对dispatchEvent函数的调用</li></ul></li></ol></li><li><p>事件工作流程</p><ol><li>事件触发，冒泡至document(container)</li><li>执行dispatchEvent</li><li>创建事件对应的合成事件对象（SyntheticEvent）</li><li>收集事件在<strong>捕获阶段</strong>所波及的<strong>回调函数</strong>和<strong>节点实例</strong></li><li>收集事件在<strong>冒泡阶段</strong>所波及的<strong>回调函数</strong>和<strong>节点实例</strong></li><li>将<strong>前两步收集来的回调</strong>按顺序执行，执行时（SyntheticEvent）会作为参数传进去。</li></ol></li><li><p>React怎么阻止事件冒泡</p><ol><li>阻止合成事件间的冒泡，用e.stopPropagation()</li><li>阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()</li><li>阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免</li></ol></li></ul><h3 id="函数组件，hooks和类class"><a href="#函数组件，hooks和类class" class="headerlink" title="函数组件，hooks和类class"></a>函数组件，hooks和类class</h3><ol><li>类组件需要声明constructor，函数组件不需要</li><li>类组件需要手动绑定this，函数组件不需要</li><li>类组件有生命周期钩子，函数组件没有</li><li>类组件可以定义并维护<strong>自己的state</strong>，属于<strong>有状态组件</strong>，函数组件是<strong>无状态组件</strong></li><li>类组件需要继承class，函数组件不需要</li><li>类组件使用的是面向对象的方法:<br> 封装：组件属性和方法都封装在组件内部<br> 继承:通过extends React.Component继承;<br> 函数组件使用的是函数式编程思想</li></ol><ul><li>React hooks <a href="https://juejin.cn/post/7118937685653192735" target="_blank" rel="noopener">https://juejin.cn/post/7118937685653192735</a><ul><li>优点：<ol><li>告别难以理解的class组件</li><li>解决业务逻辑难以拆分的问题</li><li>使状态逻辑复用变的简单可行</li><li>函数组件从设计理念来看，更适合react</li></ol></li><li>局限性：<ol><li>hooks还不能完整的为函数组件提供类组件的能力</li><li>函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求</li><li>Hooks 在使用层面有着严格的规则约束</li></ol></li></ul></li></ul><h3 id="组件的设计模式-https-juejin-cn-post-7007214462813863950"><a href="#组件的设计模式-https-juejin-cn-post-7007214462813863950" class="headerlink" title="组件的设计模式 https://juejin.cn/post/7007214462813863950"></a>组件的设计模式 <a href="https://juejin.cn/post/7007214462813863950" target="_blank" rel="noopener">https://juejin.cn/post/7007214462813863950</a></h3><ul><li><p>组合模式<br>组合模式适合一些容器组件场景，通过外层组件包裹内层组件，外层组件可以轻松的获取内层组件的 props 状态，还可以控制内层组件的渲染，组合模式能够直观反映出 父 -&gt; 子组件的包含关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">type</span>)=&gt;</span> console.log(type)  &#125; &gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">name</span>=<span class="string">"react"</span>  <span class="attr">label</span>=<span class="string">"react"</span> &gt;</span>React<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">name</span>=<span class="string">"vue"</span> <span class="attr">label</span>=<span class="string">"vue"</span> &gt;</span>Vue<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">name</span>=<span class="string">"angular"</span> <span class="attr">label</span>=<span class="string">"angular"</span>  &gt;</span>Angular<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>render props 模式<br>render props 模式和组合模式类似。区别不同的是，用函数的形式代替 children。函数的参数，由容器组件提供，这样的好处，将容器组件的状态，提升到当前外层组件中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> aProps = &#123;</span><br><span class="line">    name:<span class="string">'《React进阶实践指南》'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line">    &#123;(cProps) =&gt; &lt;Children &#123;...cProps&#125; &#123; ...aProps &#125;  /&gt;&#125;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>HOC<br>hoc 高阶组件模式，高阶函数是接收一个函数，返回一个函数，而所谓高阶组件，就是接收一个组件，返回一个组件，返回的组件是根据需要对原始组件的强化。</p><ol><li>HOC 本质是一个函数，传入 <strong>Component</strong> ，也就是原始组件本身。</li><li>返回一个新的包装的组件 Wrap ，我们可以在 Wrap 中做一些强化原始组件的事。</li><li>Wrap 中挂载原始组件本身 Component。<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hoc</span> (<span class="params">Component</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">//---------</span></span><br><span class="line">    <span class="comment">// 强化操作</span></span><br><span class="line">    <span class="comment">//---------</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123; <span class="attr">...this.props</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>提供者模式(Provider)<br>React组件树 Root 节点，用 Provider 提供者注入 theme，然后在需要 theme的 地方，用 Consumer 消费者形式取出theme，供给组件渲染使用即可，这样减少很多无用功。用官网上的一句话形容就是Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><ol><li>通过 Consumer 订阅 context 变化，context 变化， render children 函数重新执行。 render children 函数中第一个参数就是保存的 context 信息。<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeProvider</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = &#123; <span class="attr">color</span>:<span class="string">'pink'</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">theme</span> &#125; &gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>类组件继承<br>继承模式的应用前提是，你需要知道被继承的组件是什么，内部都有什么状态和方法，对继承的组件内部的运转是透明的。接下来用一幅图表示继承模式原理。</p></li></ul><h3 id="React渲染流程和fiber"><a href="#React渲染流程和fiber" class="headerlink" title="React渲染流程和fiber"></a>React渲染流程和fiber</h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li>shouldComponentUpdate、pureComponent</li><li>useMemo useCallback</li><li>getDerviedStateFromProps</li><li>使用Fragment</li><li>v-for/map使用正确的key</li><li>拆分尽可能小的可复用组件，ErrorBoundary</li><li>使用React.lazy和React.Suspense延迟加载不需要立马使用的组件</li></ol><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>  Typescript是js的超集，为js提供了静态类型检查，在js的基础上引入了面向对象的一些概念：类、接口、继承、范型。ts提供了类型注解、类型推断，在编译时就能保证类型的正确。</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>  泛型是提供创建可重用组件的方法的工具，使用传参的形式将类型传递给函数或者接口，并在使用时指定具体的类型。</p><h3 id="联合类型和交叉类型"><a href="#联合类型和交叉类型" class="headerlink" title="联合类型和交叉类型"></a>联合类型和交叉类型</h3><ul><li>交叉类型：将多个类型合并成一个类型，新类型将具有多个类型的所有特性。&amp;</li><li>联合类型：表示一个值可以有多种类型的之一。｜</li></ul><h3 id="type-amp-amp-interface"><a href="#type-amp-amp-interface" class="headerlink" title="type&amp;&amp;interface"></a>type&amp;&amp;interface</h3><ul><li>相同点：<ol><li>都可以描述一个对象或者函数类型</li><li>都允许extends，并且可以互相扩展</li></ol></li><li>不同点：<ol><li>type 可以声明基本类型别名、联合类型、元组类型</li><li>type 支持typeof获取实例的类型进行赋值</li><li>interface 可以声明合并（交叉）</li></ol></li></ul><h3 id="any-和-unknown-有什么区别"><a href="#any-和-unknown-有什么区别" class="headerlink" title="any 和 unknown 有什么区别"></a>any 和 unknown 有什么区别</h3><p>  any和unknown都能在不能确定变量类型的时候使用，unknown更加严格，any直接不做类型检查。</p><ul><li>任何类型的数据都可以赋给 unknown 类型，unknown 类型的值也不能将值赋给 any 和 unknown 之外的类型变量</li><li>unknown类型的值不能确定内部属性。</li></ul><h3 id="never和void的区别"><a href="#never和void的区别" class="headerlink" title="never和void的区别"></a>never和void的区别</h3><ul><li>void表示没有任何类型（可以赋值为null和undefind）</li><li>never表示一个不包含值的类型，never类型的变量永远不存在值</li><li>拥有void返回值的函数可以正常运行，拥有never返回值的函数无法正常返回。</li></ul><h3 id="断言和类型推断"><a href="#断言和类型推断" class="headerlink" title="断言和类型推断"></a>断言和类型推断</h3><ul><li>类型推断：Typescript允许编译器根据上下文自动推断出变量的类型，从而减少手动类型输入的工作量。</li><li>类型断言：类似于类型强制转换，它建议编译器忽略自动推断，将变量强制视为某种类型。</li></ul><h3 id="常用内置函数及手动实现"><a href="#常用内置函数及手动实现" class="headerlink" title="常用内置函数及手动实现"></a>常用内置函数及手动实现</h3><ul><li><p>keyof关键字，用于获取对象类型的所有键的联合类型</p></li><li><p>Partial<t> 生成一个新的对象类型，属性全部变成可选的</t></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Required<t> 将一个对象类型中的所有属性变为必需的。</t></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Readonly<t> 将类型中的所有属性都变成只读的</t></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Record&lt;K, T&gt; 创建一个新的对象类型，指定对象属性名类型和属性值类型。其属性名类型为 K，属性值类型为 T</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Pick&lt;T, K&gt; 从类型中选择指定的属性，并返回一个新的对象类型：Pick&lt;Person, ‘name’ | ‘age’&gt;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;SourceType, KeysType <span class="keyword">extends</span> keyof SourceType&gt; = &#123;</span><br><span class="line">  [KeyType <span class="keyword">in</span> KeysType]: SourceType[KeyType];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Omit&lt;T, K&gt; 创建新的类型，可以从一个类型中省略指定的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> omit = &lt;T, K <span class="keyword">extends</span> keyof T&gt;(obj: T, ...keys: K[]): Omit&lt;T, K&gt; =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> result = &#123; ...obj &#125;;</span><br><span class="line">keys.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> result[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><ul><li>装饰类<br>接受 constructor 构造器，constructor.prototype.xxx 可以修改实例化对象的值</li><li>装饰参数<br>接受 target、propertyKey、index 可以直接修改参数的值</li><li>装饰方法<br>接受 target、propertyKey、descriptor Object.defineProperty 劫持修改方法</li></ul><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><p>微前端是借鉴了微服务的理念，将一个庞大的应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发，独立运行，独立部署，还可以随意组合，这样就降低了耦合度，从而更加灵活。</p><ul><li><p>微前端特性</p><ol><li>技术栈无关 主框架不限制接入应用的技术栈，子应用可自主选择技术栈（vue，react，jq，ng等）</li><li>独立开发/部署 各个团队之间仓库独立，单独部署，互不依赖</li><li>增量升级 当一个应用庞大之后，技术升级或重构相当麻烦，而微应用具备渐进式升级的特性</li><li>独立运行时 微应用之间运行时互不依赖，有独立的状态管理</li></ol></li><li><p>微前端解决方案</p><ol><li>webComponents</li><li>qiankun &amp;&amp; single-spa</li><li>iframe</li><li>webpack5 moudle-federation</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;传输协议-amp-amp-浏览器&quot;&gt;&lt;a href=&quot;#传输协议-amp-amp-浏览器&quot; class=&quot;headerlink&quot; title=&quot;传输协议&amp;amp;&amp;amp;浏览器&quot;&gt;&lt;/a&gt;传输协议&amp;amp;&amp;amp;浏览器&lt;/h2&gt;&lt;h3 id=&quot;https-协
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>现代CSS解决方案：原生支持的三角函数</title>
    <link href="https://summxu.github.io/2023/%E7%8E%B0%E4%BB%A3CSS%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
    <id>https://summxu.github.io/2023/现代CSS解决方案：原生支持的三角函数/</id>
    <published>2023-08-25T06:11:48.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-三角函数语法介绍"><a href="#CSS-三角函数语法介绍" class="headerlink" title="CSS 三角函数语法介绍"></a>CSS 三角函数语法介绍</h2><p>首先看看 CSS 三角函数的使用方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置元素的宽度为 sin(30deg) 的值 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(sin(30deg) * <span class="number">100px</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 反正弦 根据弧度值返回对应的角度值 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(asin(-0.2));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置元素的高度为 cos(45deg) 的值 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>(cos(45deg) * <span class="number">100%</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置元素的透明度为 tan(60deg) 的值 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="built_in">calc</span>(tan(60deg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，使用了 calc() 函数进行了计算，然后通过 sin()、cos() 和 tan() 函数对计算结果进行了进一步的处理，从而实现了不同的效果。</p><p>三角函数在 CSS3 中仅对弧度（radian）单位进行支持。如果想要在开发中使用三角函数，可以借助转换函数 deg() 和 rad() 将角度（degree）和弧度进行转换。</p><p>CSS3 的这些函数使得开发者可以更加方便处理一些复杂的数学问题，增强了 CSS 的表现力。</p><h2 id="三角函数的运动轨迹"><a href="#三角函数的运动轨迹" class="headerlink" title="三角函数的运动轨迹"></a>三角函数的运动轨迹</h2><p>三角函数的运用，可以体现在动画当中。以正弦、余弦函数为例，代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span> --angle &#123;</span><br><span class="line">  syntax: '&lt;angle&gt;';</span><br><span class="line">  <span class="selector-tag">inherits</span>: <span class="selector-tag">false</span>;</span><br><span class="line">  <span class="selector-tag">initial-value</span>: 0<span class="selector-tag">deg</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">property</span> --dis &#123;</span><br><span class="line">  syntax: '&lt;length&gt;';</span><br><span class="line">  <span class="selector-tag">inherits</span>: <span class="selector-tag">false</span>;</span><br><span class="line">  <span class="selector-tag">initial-value</span>: 0<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-single</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation</span>: move <span class="number">5s</span> infinite ease-in-out;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(calc(var(--dis) - <span class="number">40vw</span>),</span><br><span class="line">      <span class="built_in">calc</span>(5 * sin(var(--angle)) * <span class="number">1em</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> move &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">--dis</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">--angle</span>: <span class="number">0deg</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">--dis</span>: <span class="number">80vw</span>;</span><br><span class="line">    <span class="attribute">--angle</span>: <span class="number">1080deg</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的核心在于这一段代码 <code>-- transform: translate(calc(var(--dis) - 40vw), calc(5 * sin(var(--angle)) * 1em))</code><br>内部使用了两个 CSS @property 变量：</p><ol><li>x 轴方向是 <code>0px</code> 到 <code>80vw</code> 的水平位移动画</li><li>y 轴方向是 <code>5 * sin(0deg) * 1em</code> 到 <code>5 * sin(1080deg) * 1em</code> 的竖直动画</li></ol><p>通过动画，动态的修改这两个变量的值，就可以得到一个三角函数曲线动画图形：</p><iframe src="../../html/sinAnimation.html" scrolling="no" width="100%" height="200px" frameborder="0"></iframe><h2 id="CSS-钟表"><a href="#CSS-钟表" class="headerlink" title="CSS 钟表"></a>CSS 钟表</h2><p>钟表上1-12折12个数字按照圆形等间距排布，也是CSS三角函数的典型应用。</p><p>排版定位的相关代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span> &#123;</span><br><span class="line">  <span class="attribute">--x</span>: <span class="built_in">calc</span>(var(--radius) + (<span class="built_in">var</span>(--radius) * <span class="built_in">cos</span>(var(--index) * <span class="number">30deg</span>)));</span><br><span class="line">  <span class="attribute">--y</span>: <span class="built_in">calc</span>(var(--radius) + (<span class="built_in">var</span>(--radius) * <span class="built_in">sin</span>(var(--index) * <span class="number">30deg</span>)));</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">place-content</span>: center;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>; <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">var</span>(--x);</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">var</span>(--y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(1)</span> &#123; <span class="attribute">--index</span>: <span class="number">9</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(2)</span> &#123; <span class="attribute">--index</span>: <span class="number">10</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(3)</span> &#123; <span class="attribute">--index</span>: <span class="number">11</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(4)</span> &#123; <span class="attribute">--index</span>: <span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(5)</span> &#123; <span class="attribute">--index</span>: <span class="number">1</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(6)</span> &#123; <span class="attribute">--index</span>: <span class="number">2</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(7)</span> &#123; <span class="attribute">--index</span>: <span class="number">3</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(8)</span> &#123; <span class="attribute">--index</span>: <span class="number">4</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(9)</span> &#123; <span class="attribute">--index</span>: <span class="number">5</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(10)</span> &#123; <span class="attribute">--index</span>: <span class="number">6</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(11)</span> &#123; <span class="attribute">--index</span>: <span class="number">7</span>; &#125;</span><br><span class="line"><span class="selector-class">.clock-face</span> <span class="selector-tag">time</span><span class="selector-pseudo">:nth-child(12)</span> &#123; <span class="attribute">--index</span>: <span class="number">8</span>; &#125;</span><br></pre></td></tr></table></figure><p>实现的效果（完整的代码可以查看一下iframe的源代码信息）：</p><iframe src="../../html/cssClock.html" width="100%" height="340px" scrolling="no" frameborder="0"></iframe><h2 id="CSS-数学函数"><a href="#CSS-数学函数" class="headerlink" title="CSS 数学函数"></a>CSS 数学函数</h2><ul><li>sqrt() 求平方根</li><li>pow() 幂指数</li><li>exp() 自然常数e为底的指数函数</li><li>log() 对数函数</li><li>abs() 绝对值</li><li>round() 四舍五入</li><li>sign() 正负零判断</li><li>….</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSS 原生支持的三角函数，给 CSS 打开了更多的可能性，这也导致 CSS 的复杂度也是愈来愈高，CSS 已经不再是非常纯粹的负责样式了，很多时候，很多计算也可以直接在 CSS 当中完成。至于好坏，或许已经成了一个哲学问题。</p><p>记录两个css项目，第二个相当炸裂：</p><p><a href="https://css-doodle.com/" target="_blank" rel="noopener">css-doodle</a></p><p><a href="https://keithclark.co.uk/labs/css-fps/" target="_blank" rel="noopener">css-fps-demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS-三角函数语法介绍&quot;&gt;&lt;a href=&quot;#CSS-三角函数语法介绍&quot; class=&quot;headerlink&quot; title=&quot;CSS 三角函数语法介绍&quot;&gt;&lt;/a&gt;CSS 三角函数语法介绍&lt;/h2&gt;&lt;p&gt;首先看看 CSS 三角函数的使用方式：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Pinia使用和源码解析</title>
    <link href="https://summxu.github.io/2023/Pinia%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://summxu.github.io/2023/Pinia使用和源码解析/</id>
    <published>2023-06-26T01:36:37.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建pinia"><a href="#创建pinia" class="headerlink" title="创建pinia"></a>创建pinia</h2><p>基本使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pinia = createPinia()</span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">app.use(pinia)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">//vue2 使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia, PiniaVuePlugin &#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line">Vue.use(PiniaVuePlugin)</span><br><span class="line"><span class="keyword">const</span> pinia = createPinia()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>, </span><br><span class="line">  pinia,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="createPinia"><a href="#createPinia" class="headerlink" title="createPinia"></a>createPinia</h2><ul><li>将pinia绑定到实例上</li><li>创建一个scope用来保存之后创建的每一个store的state，也可以直接通过pinia.state.value[storeId]直接设置state</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ceatePinia.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPinia</span>(<span class="params"></span>): <span class="title">Pinia</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建个scope effct来单独管理state</span></span><br><span class="line">  <span class="keyword">const</span> scope = effectScope(<span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 通过pinia.state.value[storeId]会保存之后创建的store的state</span></span><br><span class="line">  <span class="keyword">const</span> state = scope.run&lt;Ref&lt;Record&lt;<span class="built_in">string</span>, StateTree&gt;&gt;&gt;<span class="function">(<span class="params">(<span class="params"></span>) =&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    ref&lt;Record&lt;<span class="built_in">string</span>, StateTree&gt;&gt;(<span class="params">&#123;&#125;</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>)!</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  // 插件相关</span></span><br><span class="line"><span class="function">  <span class="params">let</span> _<span class="params">p</span>: <span class="params">Pinia</span>['_<span class="params">p</span>'] = []</span></span><br><span class="line"><span class="function">  // <span class="params">plugins</span> <span class="params">added</span> <span class="params">before</span> <span class="params">calling</span> <span class="params">app</span>.<span class="params">use</span>(<span class="params">pinia</span>)</span></span><br><span class="line"><span class="function">  <span class="params">let</span> <span class="params">toBeInstalled</span>: <span class="params">PiniaPlugin</span>[] = []</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  // <span class="params">markRaw</span>标记<span class="params">pinia</span>不可被代理,避免存在用户将其响应式化影响性能的情况</span></span><br><span class="line"><span class="function">  <span class="params">const</span> <span class="params">pinia</span>: <span class="params">Pinia</span> = <span class="params">markRaw</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    install(<span class="params">app: App</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 设置当前活跃的pinia，方便其他地方获取</span></span></span></span><br><span class="line"><span class="function"><span class="params">      setActivePinia(<span class="params">pinia</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span> (<span class="params">!isVue2</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        pinia._a = app</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 内部通过inject获取pinia,因为piniaSymbol没有导出，所以开发者无法通过inject获取pinia</span></span></span></span><br><span class="line"><span class="function"><span class="params">        app.provide(<span class="params">piniaSymbol, pinia</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 通过app.config.globalProperties将pinia挂载到组件实例上</span></span></span></span><br><span class="line"><span class="function"><span class="params">        app.config.globalProperties.$pinia = pinia</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (<span class="params">USE_DEVTOOLS</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">          registerPiniaDevtools(<span class="params">app, pinia</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        toBeInstalled.forEach(<span class="params">(<span class="params">plugin</span>) =&gt; _p.push(<span class="params">plugin</span>)</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">        toBeInstalled = []</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// pinia插件相关，暂不分析</span></span></span></span><br><span class="line"><span class="function"><span class="params">    use(<span class="params">plugin</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span> (<span class="params">!<span class="keyword">this</span>._a &amp;&amp; !isVue2</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        toBeInstalled.push(<span class="params">plugin</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        _p.push(<span class="params">plugin</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">return</span> <span class="keyword">this</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    _p,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// it's actually undefined here</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// @ts-expect-error</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _a: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    _e: scope,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 每个创建的store都会放在这个Map里</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _s: <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, StoreGeneric&gt;(<span class="params"></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    state,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  //...</span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">pinia</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="设置、获取pinia"><a href="#设置、获取pinia" class="headerlink" title="设置、获取pinia"></a>设置、获取pinia</h2><ul><li>pinia会被保存到一个全局变量上，内部可以通过setActivePinia、getActivePinia快速获取到pinia，然后使用上一步挂在pinia上的属性或方法</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rootStore.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> activePinia: Pinia | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setActivePinia = <span class="function">(<span class="params">pinia: Pinia | <span class="literal">undefined</span></span>) =&gt;</span></span><br><span class="line">  (activePinia = pinia)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果在vue组件中，通过inject获取（在createPinia中导出）、否则直接取全局变量 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getActivePinia = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  (getCurrentInstance() &amp;&amp; inject(piniaSymbol)) || activePinia</span><br></pre></td></tr></table></figure><h2 id="兼容vue2"><a href="#兼容vue2" class="headerlink" title="兼容vue2"></a>兼容vue2</h2><ul><li>看过vuex的这段应该很熟悉</li><li>通过Object.defineProperty仿造了个Provide功能</li><li>通过mixins将pinia注入到每一个组件中</li></ul><p>PiniaVuePlugin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue2-plugin.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PiniaVuePlugin: Plugin = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  _Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="keyword">if</span> (options.pinia) &#123;</span><br><span class="line">      <span class="comment">// 获取注册到根组件上的pinia</span></span><br><span class="line">        <span class="keyword">const</span> pinia = options.pinia <span class="keyword">as</span> Pinia</span><br><span class="line">        <span class="comment">// 通过Object.defineProperty实现的hack版provid、inject...</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)._provided) &#123;</span><br><span class="line">          <span class="keyword">const</span> provideCache = &#123;&#125;</span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'_provided'</span>, &#123;</span><br><span class="line">            <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> provideCache,</span><br><span class="line">            <span class="keyword">set</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">Object</span>.assign(provideCache, v),</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        ;(<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>)._provided[piniaSymbol <span class="keyword">as</span> <span class="built_in">any</span>] = pinia</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.$pinia) &#123;</span><br><span class="line">          <span class="keyword">this</span>.$pinia = pinia</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinia._a = <span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">        <span class="keyword">if</span> (IS_CLIENT) &#123;</span><br><span class="line">          <span class="comment">// this allows calling useStore() outside of a component setup after</span></span><br><span class="line">          <span class="comment">// installing pinia's plugin</span></span><br><span class="line">          setActivePinia(pinia)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (USE_DEVTOOLS) &#123;</span><br><span class="line">          registerPiniaDevtools(pinia._a, pinia)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.$pinia &amp;&amp; options.parent &amp;&amp; options.parent.$pinia) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$pinia = options.parent.$pinia</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._pStores</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h2><p>创建store的三种方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUserStore = defineStore(<span class="string">'counter'</span>, &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> useUserStore = defineStore(&#123;</span><br><span class="line">  id: <span class="string">'counter'</span>,</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> useUserStore = defineStore(<span class="string">'counter'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count.value++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="defineStore"><a href="#defineStore" class="headerlink" title="defineStore"></a>defineStore</h2><ul><li>主要根据defineStore的不同方式选择调用函数式createSetupStore还是选项式createOptionsStore</li><li>创建好的store会根据defineStore时传入的id，挂载到pinia._s这个map上</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// <span class="doctag">TODO:</span> add proper types from above</span></span></span></span><br><span class="line"><span class="function"><span class="params">  idOrOptions: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup?: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  setupOptions?: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">StoreDefinition</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">let</span> options</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> isSetupStore = <span class="keyword">typeof</span> setup === <span class="string">'function'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 抹平不同格式参数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> idOrOptions === <span class="string">'string'</span>) &#123;</span><br><span class="line">    id = idOrOptions</span><br><span class="line">    options = isSetupStore ? setupOptions : setup</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    options = idOrOptions</span><br><span class="line">    id = idOrOptions.id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终交给开发者获取store的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">useStore</span>(<span class="params">pinia?: Pinia | <span class="literal">null</span>, hot?: StoreGeneric</span>): <span class="title">StoreGeneric</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> currentInstance = getCurrentInstance()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果存在currentInstance说明在vue组件中，通过inject获取到pinia</span></span><br><span class="line">    pinia =</span><br><span class="line">      (__TEST__ &amp;&amp; activePinia &amp;&amp; activePinia._testing ? <span class="literal">null</span> : pinia) ||</span><br><span class="line">      (currentInstance &amp;&amp; inject(piniaSymbol, <span class="literal">null</span>))</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//设置当前活跃的pinia对象，如果存在多个pinia对象，方便快速获取当前pinia对象</span></span><br><span class="line">    <span class="keyword">if</span> (pinia) setActivePinia(pinia)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !activePinia) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\n`</span> +</span><br><span class="line">          <span class="string">`\tconst pinia = createPinia()\n`</span> +</span><br><span class="line">          <span class="string">`\tapp.use(pinia)\n`</span> +</span><br><span class="line">          <span class="string">`This will fail in production.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从rootStore文件中取的全局变量</span></span><br><span class="line">    pinia = activePinia!</span><br><span class="line">    <span class="comment">// 如果没有创建过id对应的store,则会调用createSetupStore或createOptionsStore进行创建</span></span><br><span class="line">    <span class="keyword">if</span> (!pinia._s.has(id)) &#123;</span><br><span class="line">      <span class="comment">// 区分第二个参数是函数还是options对象</span></span><br><span class="line">      <span class="keyword">if</span> (isSetupStore) &#123;</span><br><span class="line">        createSetupStore(id, setup, options, pinia)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createOptionsStore(id, options <span class="keyword">as</span> <span class="built_in">any</span>, pinia)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error: not the right inferred type</span></span><br><span class="line">        useStore._pinia = pinia</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取上面创建好的store，pinia._s是一个Map结构</span></span><br><span class="line">    <span class="keyword">const</span> store: StoreGeneric = pinia._s.get(id)!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 热更新相关,重新创建更新store</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; hot) &#123;</span><br><span class="line">      <span class="keyword">const</span> hotId = <span class="string">'__hot:'</span> + id</span><br><span class="line">      <span class="keyword">const</span> newStore = isSetupStore</span><br><span class="line">        ? createSetupStore(hotId, setup, options, pinia, <span class="literal">true</span>)</span><br><span class="line">        : createOptionsStore(hotId, assign(&#123;&#125;, options) <span class="keyword">as</span> <span class="built_in">any</span>, pinia, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">      hot._hotUpdate(newStore)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// cleanup the state properties and the store from the cache</span></span><br><span class="line">      <span class="keyword">delete</span> pinia.state.value[hotId]</span><br><span class="line">      pinia._s.delete(hotId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往当前组件实例上缓存store，主要是给devtools使用</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      IS_CLIENT &amp;&amp;</span><br><span class="line">      currentInstance &amp;&amp;</span><br><span class="line">      currentInstance.proxy &amp;&amp;</span><br><span class="line">      <span class="comment">// avoid adding stores that are just built for hot module replacement</span></span><br><span class="line">      !hot</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> vm = currentInstance.proxy</span><br><span class="line">      <span class="keyword">const</span> cache = <span class="string">'_pStores'</span> <span class="keyword">in</span> vm ? vm._pStores! : (vm._pStores = &#123;&#125;)</span><br><span class="line">      cache[id] = store</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StoreGeneric cannot be casted towards Store</span></span><br><span class="line">    <span class="keyword">return</span> store <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useStore.$id = id</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createSetupStore"><a href="#createSetupStore" class="headerlink" title="createSetupStore"></a>createSetupStore</h2><p>如果defineStore传入的是一个setup函数，则会调用此方法创建store</p><ul><li><h3 id="响应式处理store"><a href="#响应式处理store" class="headerlink" title="响应式处理store"></a>响应式处理store</h3><ul><li>store -&gt; reactive(store)</li><li>pinia.state.value[storeId]初始化，state会往pinia上存一份和在store上存一份</li><li>将store注册到pinia._s这个Map上</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> scope!: EffectScope  <span class="comment">//为setup函数返回的内容单独建立一个scope</span></span><br><span class="line"><span class="keyword">if</span> (__DEV__ &amp;&amp; !pinia._e.active) &#123; <span class="comment">//pinia._e为创建pinia时建立的scope</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Pinia destroyed'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt; | <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 如果pinia.state.value[storeId]未初始化，进行初始化</span></span><br><span class="line"><span class="keyword">if</span> (!isOptionsStore &amp;&amp; !initialState &amp;&amp; (!__DEV__ || !hot)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">    <span class="keyword">set</span>(pinia.state.value, $id, &#123;&#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pinia.state.value[$id] = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露的store内容</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"> _p: pinia,</span><br><span class="line"> <span class="comment">// _s: scope,</span></span><br><span class="line"> $id,</span><br><span class="line"> <span class="comment">// 调用$onAction会将回调加入到actionSubscriptions中,wrapAction内会触发回调</span></span><br><span class="line"> $onAction: addSubscription.bind(<span class="literal">null</span>, actionSubscriptions),</span><br><span class="line"> $patch,</span><br><span class="line"> $reset,</span><br><span class="line"> $subscribe(callback, options = &#123;&#125;) &#123;</span><br><span class="line">   <span class="keyword">const</span> removeSubscription = addSubscription(</span><br><span class="line">     subscriptions,</span><br><span class="line">     callback,</span><br><span class="line">     options.detached,</span><br><span class="line">     () =&gt; stopWatcher()</span><br><span class="line">   )</span><br><span class="line">   <span class="comment">// 监听state直接修改</span></span><br><span class="line">   <span class="keyword">const</span> stopWatcher = scope.run(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">     watch(</span><br><span class="line">       () =&gt; pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;,</span><br><span class="line">       (state) =&gt; &#123;</span><br><span class="line">         <span class="comment">// flush默认为'pre',而在调用$patch时isListening会被设置为false,所以不会触发$patch修改state的监听回调</span></span><br><span class="line">         <span class="keyword">if</span> (options.flush === <span class="string">'sync'</span> ? isSyncListening : isListening) &#123;</span><br><span class="line">           callback(</span><br><span class="line">             &#123;</span><br><span class="line">               storeId: $id,</span><br><span class="line">               <span class="keyword">type</span>: MutationType.direct,</span><br><span class="line">               events: debuggerEvents <span class="keyword">as</span> DebuggerEvent,</span><br><span class="line">             &#125;,</span><br><span class="line">             state</span><br><span class="line">           )</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       assign(&#123;&#125;, $subscribeOptions, options)</span><br><span class="line">     )</span><br><span class="line">   )!</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> removeSubscription</span><br><span class="line"> &#125;,</span><br><span class="line"> $dispose,</span><br><span class="line">&#125; <span class="keyword">as</span> _StoreWithState&lt;Id, S, G, A&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的store是个reactive对象</span></span><br><span class="line"><span class="keyword">const</span> store: Store&lt;Id, S, G, A&gt; = reactive(</span><br><span class="line">  __DEV__ || USE_DEVTOOLS</span><br><span class="line">    ? assign(</span><br><span class="line">        &#123;</span><br><span class="line">          _hmrPayload,</span><br><span class="line">          _customProperties: markRaw(<span class="keyword">new</span> Set&lt;<span class="built_in">string</span>&gt;()), <span class="comment">// devtools custom properties</span></span><br><span class="line">        &#125;,</span><br><span class="line">        partialStore</span><br><span class="line">        <span class="comment">// must be added later</span></span><br><span class="line">        <span class="comment">// setupStore</span></span><br><span class="line">      )</span><br><span class="line">    : partialStore</span><br><span class="line">) <span class="keyword">as</span> unknown <span class="keyword">as</span> Store&lt;Id, S, G, A&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将store注册到pinia上</span></span><br><span class="line">pinia._s.set($id, store)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="处理setup返回的内容"><a href="#处理setup返回的内容" class="headerlink" title="处理setup返回的内容"></a>处理setup返回的内容</h3></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"> <span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   scope = effectScope()</span><br><span class="line">   <span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line"> &#125;)!</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="同步setup返回内容和pinia-state"><a href="#同步setup返回内容和pinia-state" class="headerlink" title="同步setup返回内容和pinia.state"></a>同步setup返回内容和pinia.state</h3><ul><li>因为state会在store上存一份，也会在pinia.state.value[storeId]上存一份，所以为了保证两边都是同一个代理对象，需要进行同步</li><li>使用者可以直接通过pinia.state.value设置store内容，所以直接设置的内容也需要同步</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"><span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  scope = effectScope()</span><br><span class="line">  <span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line">&#125;)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> setupStore) &#123;</span><br><span class="line"> <span class="keyword">const</span> prop = setupStore[key]</span><br><span class="line"> <span class="comment">// 只处理ref、reactive对象，computed等不处理</span></span><br><span class="line"> <span class="keyword">if</span> ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123;</span><br><span class="line">   <span class="comment">// mark it as a piece of state to be serialized</span></span><br><span class="line">   <span class="keyword">if</span> (__DEV__ &amp;&amp; hot) &#123;</span><br><span class="line">     <span class="comment">// 热更新相关，忽略</span></span><br><span class="line">     <span class="keyword">set</span>(hotState.value, key, toRef(setupStore <span class="keyword">as</span> <span class="built_in">any</span>, key))</span><br><span class="line">     <span class="comment">// option结构已经在createOptionsStore将其加入pinia</span></span><br><span class="line">     </span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isOptionsStore) &#123;<span class="comment">// 同步pinia.state -&gt; store</span></span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 将用户可能直接调用pinia.state.value[$id]设置的ref、reactive对象设置到setup返回的结果上,让二者的响应式都代理一个对象</span></span><br><span class="line">     <span class="comment">// 使得store、pinia能同步更改</span></span><br><span class="line">     <span class="keyword">if</span> (initialState &amp;&amp; shouldHydrate(prop)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (isRef(prop)) &#123;</span><br><span class="line">         prop.value = initialState[key]</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// probably a reactive object, lets recursively assign</span></span><br><span class="line">         <span class="comment">// 同步其他类型</span></span><br><span class="line">         mergeReactiveObjects(prop, initialState[key])</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// transfer the ref to the pinia state to keep everything in sync</span></span><br><span class="line">     <span class="comment">// 将setup返回的ref、reactive对象同步到pinia.state上，使得store、pinia能同步更改</span></span><br><span class="line">     <span class="keyword">if</span> (isVue2) &#123; <span class="comment">//同步 store -&gt; pinia.state</span></span><br><span class="line">       <span class="keyword">set</span>(pinia.state.value[$id], key, prop)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       pinia.state.value[$id][key] = prop</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeReactiveObjects</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">T</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt; | <span class="title">Map</span>&lt;<span class="title">unknown</span>, <span class="title">unknown</span>&gt; | <span class="title">Set</span>&lt;<span class="title">unknown</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params">target: T, patchToApply: _DeepPartial&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 合并Map类型</span></span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Map &amp;&amp; patchToApply <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    patchToApply.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> target.set(key, value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并Set类型</span></span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Set &amp;&amp; patchToApply <span class="keyword">instanceof</span> Set) &#123;</span><br><span class="line">    patchToApply.forEach(target.add, target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> patchToApply) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!patchToApply.hasOwnProperty(key)) <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">const</span> subPatch = patchToApply[key]</span><br><span class="line">    <span class="keyword">const</span> targetValue = target[key]</span><br><span class="line">    <span class="comment">// 只有普通对象才会进入递归</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isPlainObject(targetValue) &amp;&amp;</span><br><span class="line">      isPlainObject(subPatch) &amp;&amp;</span><br><span class="line">      target.hasOwnProperty(key) &amp;&amp;</span><br><span class="line">      !isRef(subPatch) &amp;&amp;</span><br><span class="line">      !isReactive(subPatch)</span><br><span class="line">    ) &#123;</span><br><span class="line">      target[key] = mergeReactiveObjects(targetValue, subPatch)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = subPatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="处理action"><a href="#处理action" class="headerlink" title="处理action"></a>处理action</h3><ul><li>将action替换成wrapAction，wrapAction添加了订阅发布相关的功能</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"><span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  scope = effectScope()</span><br><span class="line">  <span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line">&#125;)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> setupStore) &#123;</span><br><span class="line"> <span class="keyword">const</span> prop = setupStore[key]</span><br><span class="line"> <span class="comment">// 只处理ref、reactive对象，computed等不处理</span></span><br><span class="line"> <span class="keyword">if</span> ((isRef(prop) &amp;&amp; !isComputed(prop)) || isReactive(prop)) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> prop === <span class="string">'function'</span>) &#123; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 将setup中的方法替换成wrapAction包装的方法，wrapAction在订阅发布章节解析</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">const</span> actionValue = __DEV__ &amp;&amp; hot ? prop : wrapAction(key, prop)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">        <span class="keyword">set</span>(setupStore, key, actionValue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error</span></span><br><span class="line">        setupStore[key] = actionValue</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        _hmrPayload.actions[key] = prop</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// list actions so they can be used in plugins</span></span><br><span class="line">      <span class="comment">// @ts-expect-error</span></span><br><span class="line">      optionsForPlugin.actions[key] = prop</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="处理store合并setup"><a href="#处理store合并setup" class="headerlink" title="处理store合并setup"></a>处理store合并setup</h3></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 对外暴露的store API</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store: Store&lt;Id, S, G, A&gt; = reactive(</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">partialStore</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 将defineStore使用者定义的返回内容放进scope中,在组件卸载时回收effect</span></span><br><span class="line"><span class="keyword">const</span> setupStore = pinia._e.run(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">scope = effectScope()</span><br><span class="line"><span class="keyword">return</span> scope.run(<span class="function"><span class="params">()</span> =&gt;</span> setup())</span><br><span class="line">&#125;)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> setupStore) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将最同步后的结果，合并进store上</span></span><br><span class="line"> <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">   <span class="built_in">Object</span>.keys(setupStore).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">set</span>(store, key, setupStore[key])</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 将store的reactive对象、原始对象都进行合并</span></span><br><span class="line">   assign(store, setupStore)</span><br><span class="line">   assign(toRaw(store), setupStore)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createOptionsStore"><a href="#createOptionsStore" class="headerlink" title="createOptionsStore"></a>createOptionsStore</h2><p>当传入的是option配置时，则会调用此方法创建store</p><ul><li>createSetupStore内部会将option转换成setup方法，然后实际调用createSetupStore进行创建</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createOptionsStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">_GettersTree</span>&lt;<span class="title">S</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: DefineStoreOptions&lt;Id, S, G, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; state, actions, getters &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> initialState: StateTree | <span class="literal">undefined</span> = pinia.state.value[id]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> store: Store&lt;Id, S, G, A&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将options转化成setup函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化pinia.state</span></span><br><span class="line">    <span class="keyword">if</span> (!initialState &amp;&amp; (!__DEV__ || !hot)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">        <span class="keyword">set</span>(pinia.state.value, id, state ? state() : &#123;&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pinia.state.value[id] = state ? state() : &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将pinia.state全部转换成ref，和setup中返回ref效果一致</span></span><br><span class="line">    <span class="keyword">const</span> localState =</span><br><span class="line">      __DEV__ &amp;&amp; hot</span><br><span class="line">        ? <span class="comment">// use ref() to unwrap refs inside state <span class="doctag">TODO:</span> check if this is still necessary</span></span><br><span class="line">          toRefs(ref(state ? state() : &#123;&#125;).value)</span><br><span class="line">        : toRefs(pinia.state.value[id])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终options store返回的内容格式和setup store返回的内容格式一致</span></span><br><span class="line">    <span class="keyword">return</span> assign(</span><br><span class="line">      localState,</span><br><span class="line">      actions,</span><br><span class="line">      <span class="comment">// 将 getter 转换成 computed</span></span><br><span class="line">      <span class="built_in">Object</span>.keys(getters || &#123;&#125;).reduce(<span class="function">(<span class="params">computedGetters, name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; name <span class="keyword">in</span> localState) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(</span><br><span class="line">            <span class="string">`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "<span class="subst">$&#123;name&#125;</span>" in store "<span class="subst">$&#123;id&#125;</span>".`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// getter函数不可代理，及不对computed做额外处理，和setup中一致</span></span><br><span class="line">        computedGetters[name] = markRaw(</span><br><span class="line">          computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setActivePinia(pinia)</span><br><span class="line">            <span class="comment">// it was created just before</span></span><br><span class="line">            <span class="keyword">const</span> store = pinia._s.get(id)!</span><br><span class="line"></span><br><span class="line">            <span class="comment">// allow cross using stores</span></span><br><span class="line">            <span class="keyword">if</span> (isVue2 &amp;&amp; !store._r) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// @ts-expect-error</span></span><br><span class="line">            <span class="comment">// return getters![name].call(context, context)</span></span><br><span class="line">            <span class="keyword">return</span> getters![name].call(store, store)</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> computedGetters</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> Record&lt;<span class="built_in">string</span>, ComputedRef&gt;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// option选项注册的pinia会被转换成setup函数形式</span></span><br><span class="line">  store = createSetupStore(id, setup, options, pinia, hot, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  store.$reset = <span class="function"><span class="keyword">function</span> <span class="title">$reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newState = state ? state() : &#123;&#125;</span><br><span class="line">    <span class="comment">// we use a patch to group all changes into one single subscription</span></span><br><span class="line">    <span class="keyword">this</span>.$patch(<span class="function">(<span class="params">$state</span>) =&gt;</span> &#123;</span><br><span class="line">      assign($state, newState)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> store <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h2><p>pinia能够对修改state、action进行监听，内部通过发布订阅模式、watch API实现</p><ul><li><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><ul><li>将存储订阅器的功能和整个设计解藕，交给外部来传入，好处是能够处理不同类型的发布订阅</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscriptions.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addSubscription</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">_Method</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subscriptions: T[], <span class="comment">//外部传入存储器</span></span></span></span><br><span class="line"><span class="function"><span class="params">  callback: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  detached?: <span class="built_in">boolean</span>, <span class="comment">// 是否在组件卸载时清除订阅</span></span></span></span><br><span class="line"><span class="function"><span class="params">  onCleanup: () =&gt; <span class="built_in">void</span> = noop</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  subscriptions.push(callback)</span><br><span class="line">  <span class="comment">// 清除订阅</span></span><br><span class="line">  <span class="keyword">const</span> removeSubscription = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> idx = subscriptions.indexOf(callback)</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      subscriptions.splice(idx, <span class="number">1</span>)</span><br><span class="line">      onCleanup()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没传detached,则会自动在组件卸载时清除订阅</span></span><br><span class="line">  <span class="keyword">if</span> (!detached &amp;&amp; getCurrentScope()) &#123;</span><br><span class="line">    onScopeDispose(removeSubscription)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> removeSubscription</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">triggerSubscriptions</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">_Method</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  subscriptions: T[],</span></span></span><br><span class="line"><span class="function"><span class="params">  ...args: Parameters&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  subscriptions.slice().forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    callback(...args)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="监听action"><a href="#监听action" class="headerlink" title="监听action"></a>监听action</h2></li></ul><p>基本使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unsubscribe = someStore.$onAction(</span><br><span class="line">  (&#123;</span><br><span class="line">    name, <span class="comment">// action 名称</span></span><br><span class="line">    store, <span class="comment">// store 实例，类似 `someStore`</span></span><br><span class="line">    args, <span class="comment">// 传递给 action 的参数数组</span></span><br><span class="line">    after, <span class="comment">// 在 action 返回或解决后的钩子</span></span><br><span class="line">    onError, <span class="comment">// action 抛出或拒绝的钩子</span></span><br><span class="line">  &#125;) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这将在执行 "store "的 action 之前触发。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`xx`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这将在 action 成功并完全运行后触发。它等待着任何返回的 promise</span></span><br><span class="line">    after(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Finished "<span class="subst">$&#123;name&#125;</span>" after <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="built_in">Date</span>.now() - startTime</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>ms.\nResult: <span class="subst">$&#123;result&#125;</span>.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 action 抛出或返回一个拒绝的 promise，这将触发</span></span><br><span class="line">    onError(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(</span><br><span class="line">        <span class="string">`Failed "<span class="subst">$&#123;name&#125;</span>" after <span class="subst">$&#123;<span class="built_in">Date</span>.now() - startTime&#125;</span>ms.\nError: <span class="subst">$&#123;error&#125;</span>.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动删除监听器</span></span><br><span class="line">unsubscribe()</span><br></pre></td></tr></table></figure><h3 id="通过-onAction添加订阅"><a href="#通过-onAction添加订阅" class="headerlink" title="通过$onAction添加订阅"></a>通过$onAction添加订阅</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 对外暴露的store内容</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"> _p: pinia,</span><br><span class="line"> <span class="comment">// _s: scope,</span></span><br><span class="line"> $id,</span><br><span class="line"> <span class="comment">// 调用$onAction会将回调加入到actionSubscriptions中,调用wrapAction内会触发回调</span></span><br><span class="line"> $onAction: addSubscription.bind(<span class="literal">null</span>, actionSubscriptions),</span><br><span class="line"> $patch,</span><br><span class="line"> $reset,</span><br><span class="line"> $subscribe(callback, options = &#123;&#125;) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;,</span><br><span class="line"> $dispose,</span><br><span class="line">&#125; <span class="keyword">as</span> _StoreWithState&lt;Id, S, G, A&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过wrapAction进行发布"><a href="#通过wrapAction进行发布" class="headerlink" title="通过wrapAction进行发布"></a>通过wrapAction进行发布</h3><ul><li>setup、option中的方法，会被替换成wrapAction</li><li>当调用wrapAction时，会触发actionSubscriptions、afterCallbackList或onErrorCallbackList中的回调</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal state</span></span><br><span class="line"><span class="keyword">let</span> isListening: <span class="built_in">boolean</span> <span class="comment">// 异步监听</span></span><br><span class="line"><span class="keyword">let</span> isSyncListening: <span class="built_in">boolean</span> <span class="comment">// 同步监听</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subscriptions: SubscriptionCallback&lt;S&gt;[] = markRaw([])  <span class="comment">// 监听state的订阅集合</span></span><br><span class="line"><span class="keyword">let</span> actionSubscriptions: StoreOnActionListener&lt;Id, S, G, A&gt;[] = markRaw([]) <span class="comment">// 监听action的订阅集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装action调用，追加发布订阅功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapAction</span>(<span class="params">name: <span class="built_in">string</span>, action: _Method</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 根据闭包上下文，调用时设置当前活跃的pinia</span></span><br><span class="line">   setActivePinia(pinia)</span><br><span class="line">   <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">   <span class="comment">// 调用action后回调集合</span></span><br><span class="line">   <span class="keyword">const</span> afterCallbackList: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">resolvedReturn: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>&gt; = []</span><br><span class="line">   <span class="keyword">const</span> onErrorCallbackList: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">error: unknown</span>) =&gt;</span> unknown&gt; = []</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">callback: _ArrayType&lt;<span class="keyword">typeof</span> afterCallbackList&gt;</span>) </span>&#123;</span><br><span class="line">     afterCallbackList.push(callback)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">callback: _ArrayType&lt;<span class="keyword">typeof</span> onErrorCallbackList&gt;</span>) </span>&#123;</span><br><span class="line">     onErrorCallbackList.push(callback)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 触发action时的回调，同时将after等方法通过参数传入</span></span><br><span class="line">   triggerSubscriptions(actionSubscriptions, &#123;</span><br><span class="line">     args,</span><br><span class="line">     name,</span><br><span class="line">     store,</span><br><span class="line">     after,</span><br><span class="line">     onError,</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> ret: <span class="built_in">any</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ret = action.apply(<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.$id === $id ? <span class="keyword">this</span> : store, args)</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     <span class="comment">// 处理同步错误</span></span><br><span class="line">     triggerSubscriptions(onErrorCallbackList, error)</span><br><span class="line">     <span class="keyword">throw</span> error</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果是异步方法</span></span><br><span class="line">   <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ret</span><br><span class="line">       .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">// 获取到action调用结果后触发</span></span><br><span class="line">         triggerSubscriptions(afterCallbackList, value)</span><br><span class="line">         <span class="keyword">return</span> value</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">         triggerSubscriptions(onErrorCallbackList, error)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// allow the afterCallback to override the return value</span></span><br><span class="line">   triggerSubscriptions(afterCallbackList, ret)</span><br><span class="line">   <span class="keyword">return</span> ret</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听修改state"><a href="#监听修改state" class="headerlink" title="监听修改state"></a>监听修改state</h2><p>修改state有两种方式，一种通过store.state直接修改然后通过watch API进行监听，另一种通过$patch进行<a href="https://so.csdn.net/so/search?q=%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9&spm=1001.2101.3001.7020" target="_blank" rel="noopener">批量修改</a>，通过$patch进行批量修改时，为了只触发一次回调需要手动触发</p><ul><li>基本使用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cartStore.$subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// import &#123; MutationType &#125; from 'pinia'</span></span><br><span class="line">  mutation.type <span class="comment">// 'direct' | 'patch object' | 'patch function'</span></span><br><span class="line">  <span class="comment">// 和 cartStore.$id 一样</span></span><br><span class="line">  mutation.storeId <span class="comment">// 'cart'</span></span><br><span class="line">  <span class="comment">// 只有 mutation.type === 'patch object'的情况下才可用</span></span><br><span class="line">  mutation.payload <span class="comment">// 传递给 cartStore.$patch() 的补丁对象。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><h3 id="直接修改state"><a href="#直接修改state" class="headerlink" title="直接修改state"></a>直接修改state</h3></li></ul><p>$subscribe监听state直接修改，内部通过watch API实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// internal state</span></span><br><span class="line"><span class="keyword">let</span> isListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"><span class="keyword">let</span> isSyncListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 对外暴露的store内容</span></span><br><span class="line"><span class="keyword">const</span> partialStore = &#123;</span><br><span class="line"> _p: pinia,</span><br><span class="line"> <span class="comment">// _s: scope,</span></span><br><span class="line"> $id,</span><br><span class="line"> <span class="comment">// 调用$onAction会将回调加入到actionSubscriptions中,调用wrapAction内会触发回调</span></span><br><span class="line"> $onAction: addSubscription.bind(<span class="literal">null</span>, actionSubscriptions),</span><br><span class="line"> $patch,</span><br><span class="line"> $reset,</span><br><span class="line"> $subscribe(callback, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 使用者调用后将订阅回调添加进subscriptions</span></span><br><span class="line"><span class="keyword">const</span> removeSubscription = addSubscription(</span><br><span class="line">  subscriptions,</span><br><span class="line">  callback,</span><br><span class="line">  options.detached,</span><br><span class="line">  () =&gt; stopWatcher()</span><br><span class="line">)</span><br><span class="line">      <span class="comment">// 通过watch监听store.state直接修改</span></span><br><span class="line"><span class="keyword">const</span> stopWatcher = scope.run(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line"> watch(</span><br><span class="line">   () =&gt; pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;,</span><br><span class="line">   (state) =&gt; &#123;</span><br><span class="line">     <span class="comment">// flush默认为'pre',而在调用$patch时isListening会被设置为false,所以不会触发$patch修改state的监听回调</span></span><br><span class="line">     <span class="comment">// 但对于store.state直接修改的情况，store在创建完成后isSyncListening和isListening都会变成true，所以能够监听</span></span><br><span class="line">     <span class="keyword">if</span> (options.flush === <span class="string">'sync'</span> ? isSyncListening : isListening) &#123;</span><br><span class="line">       callback(</span><br><span class="line">         &#123;</span><br><span class="line">           storeId: $id,</span><br><span class="line">           <span class="keyword">type</span>: MutationType.direct, <span class="comment">// type为direct直接修改</span></span><br><span class="line">           events: debuggerEvents <span class="keyword">as</span> DebuggerEvent,</span><br><span class="line">         &#125;,</span><br><span class="line">         state</span><br><span class="line">       )</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   assign(&#123;&#125;, $subscribeOptions, options)</span><br><span class="line"> )</span><br><span class="line">)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> removeSubscription</span><br><span class="line"> &#125;,</span><br><span class="line"> $dispose,</span><br><span class="line">&#125; <span class="keyword">as</span> _StoreWithState&lt;Id, S, G, A&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个store创建结束后将两个监听标识为true,意味着store创建完成,可以进行监听订阅操作</span></span><br><span class="line">isListening = <span class="literal">true</span></span><br><span class="line">isSyncListening = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="patch修改"><a href="#patch修改" class="headerlink" title="$patch修改"></a>$patch修改</h3></li></ul><p>$patch用于批量修改state，内部主要通过两个标识位的修改，不触发<a href="https://so.csdn.net/so/search?q=watch%E7%9B%91%E5%90%AC&spm=1001.2101.3001.7020" target="_blank" rel="noopener">watch监听</a>回调</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupStore</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">SS</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">any</span>, <span class="title">unknown</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">_Method</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span> <span class="title">extends</span> <span class="title">_ActionsTree</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  $id: Id,</span></span></span><br><span class="line"><span class="function"><span class="params">  setup: () =&gt; SS,</span></span></span><br><span class="line"><span class="function"><span class="params">  options:</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineSetupStoreOptions&lt;Id, S, G, A&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    | DefineStoreOptions&lt;Id, S, G, A&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pinia: Pinia,</span></span></span><br><span class="line"><span class="function"><span class="params">  hot?: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isOptionsStore?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Store</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// internal state</span></span><br><span class="line"><span class="keyword">let</span> isListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"><span class="keyword">let</span> isSyncListening: <span class="built_in">boolean</span> <span class="comment">// set to true at the end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$patch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> partialStateOrMutator:</span></span></span><br><span class="line"><span class="function"><span class="params">   | _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">   | ((state: UnwrapRef&lt;S&gt;) =&gt; <span class="built_in">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 订阅$patch操作type</span></span><br><span class="line"> <span class="keyword">let</span> subscriptionMutation: SubscriptionCallbackMutation&lt;S&gt;</span><br><span class="line"> <span class="comment">// 避免批量修改触发$subscribe</span></span><br><span class="line"> isListening = isSyncListening = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">   debuggerEvents = []</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 兼容$patch传递函数、对象调用的两种调用方式</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> partialStateOrMutator === <span class="string">'function'</span>) &#123;</span><br><span class="line">   partialStateOrMutator(pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;)</span><br><span class="line">   subscriptionMutation = &#123;</span><br><span class="line">     <span class="keyword">type</span>: MutationType.patchFunction,  <span class="comment">// type类型</span></span><br><span class="line">     storeId: $id,</span><br><span class="line">     events: debuggerEvents <span class="keyword">as</span> DebuggerEvent[],</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// $patch传递对象走合并流程</span></span><br><span class="line">   mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator)</span><br><span class="line">   subscriptionMutation = &#123;</span><br><span class="line">     <span class="keyword">type</span>: MutationType.patchObject, <span class="comment">// type类型</span></span><br><span class="line">     payload: partialStateOrMutator,</span><br><span class="line">     storeId: $id,</span><br><span class="line">     events: debuggerEvents <span class="keyword">as</span> DebuggerEvent[],</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> myListenerId = (activeListener = Symbol())</span><br><span class="line"> <span class="comment">// 对于异步修改情况，异步还原isListening,让$subscribe不会监听通过$patch修改state</span></span><br><span class="line"> nextTick().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (activeListener === myListenerId) &#123;</span><br><span class="line">     isListening = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> isSyncListening = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 手动触发订阅,实现通过$patch批量修改state只触发一次订阅回调</span></span><br><span class="line"> triggerSubscriptions(</span><br><span class="line">   subscriptions,</span><br><span class="line">   subscriptionMutation,</span><br><span class="line">   pinia.state.value[$id] <span class="keyword">as</span> UnwrapRef&lt;S&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个store创建结束后将两个监听标识为true,意味着store创建完成,可以进行监听订阅操作</span></span><br><span class="line">isListening = <span class="literal">true</span></span><br><span class="line">isSyncListening = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="store-API"><a href="#store-API" class="headerlink" title="store API"></a>store API</h2><ul><li><h2 id="reset"><a href="#reset" class="headerlink" title="$reset"></a>$reset</h2></li></ul><p>对于options store提供的还原初始状态的API</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options store</span></span><br><span class="line">store.$reset = <span class="function"><span class="keyword">function</span> <span class="title">$reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newState = state ? state() : &#123;&#125;  <span class="comment">// state为options中的state</span></span><br><span class="line">  <span class="comment">// 通过$patch批量修改</span></span><br><span class="line">  <span class="keyword">this</span>.$patch(<span class="function">(<span class="params">$state</span>) =&gt;</span> &#123;</span><br><span class="line">    assign($state, newState)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup store</span></span><br><span class="line"><span class="keyword">const</span> $reset = __DEV__ <span class="comment">// 开发环境下会报错</span></span><br><span class="line">  ? <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`🍍: Store "<span class="subst">$&#123;$id&#125;</span>" is built using the setup syntax and does not implement $reset().`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  : noop</span><br></pre></td></tr></table></figure><ul><li><h2 id="dispose"><a href="#dispose" class="headerlink" title="$dispose"></a>$dispose</h2></li></ul><p>卸载store的API</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 卸载store</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  scope.stop() <span class="comment">//卸载store的scope effect</span></span><br><span class="line">  subscriptions = []</span><br><span class="line">  actionSubscriptions = []</span><br><span class="line">  pinia._s.delete($id) <span class="comment">// 从pinia上删除掉对应的store</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="storeToRefs解构store"><a href="#storeToRefs解构store" class="headerlink" title="storeToRefs解构store"></a>storeToRefs解构store</h2><p>通过storeToRefs使得解构store也不会丢失响应式</p><ul><li>基本使用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> store = useCounterStore()</span><br><span class="line">    <span class="comment">// ❌ 这将无法生效，因为它破坏了响应性</span></span><br><span class="line">    <span class="comment">// 这与从 `props` 中解构是一样的。</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, doubleCount &#125; = store</span><br><span class="line"></span><br><span class="line">    name <span class="comment">// "eduardo"</span></span><br><span class="line">    doubleCount <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 始终是 "eduardo"</span></span><br><span class="line">      name,</span><br><span class="line">      <span class="comment">// 始终是 2</span></span><br><span class="line">      doubleCount,</span><br><span class="line">      <span class="comment">// 这个将是响应式的</span></span><br><span class="line">      doubleValue: computed(<span class="function"><span class="params">()</span> =&gt;</span> store.doubleCount),</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过storeToRefs调用</span></span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> store = useCounterStore()</span><br><span class="line">    <span class="comment">// `name` and `doubleCount` 都是响应式 refs</span></span><br><span class="line">    <span class="comment">// 这也将为由插件添加的属性创建 refs</span></span><br><span class="line">    <span class="comment">// 同时会跳过任何 action 或非响应式(非 ref/响应式)属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, doubleCount &#125; = storeToRefs(store)</span><br><span class="line">    <span class="comment">// 名为 increment 的 action 可以直接提取</span></span><br><span class="line">    <span class="keyword">const</span> &#123; increment &#125; = store</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">      doubleCount,</span><br><span class="line">      increment,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>storeToRefs<ul><li>类似toRefs，但会跳过方法和非响应式属性</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// storeToRefs.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">storeToRefs</span>&lt;<span class="title">SS</span> <span class="title">extends</span> <span class="title">StoreGeneric</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  store: SS</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ToRefs</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">StoreState</span>&lt;<span class="title">SS</span>&gt; &amp; <span class="title">StoreGetters</span>&lt;<span class="title">SS</span>&gt; &amp; <span class="title">PiniaCustomStateProperties</span>&lt;<span class="title">StoreState</span>&lt;<span class="title">SS</span>&gt;&gt;</span></span><br><span class="line"><span class="function">&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isVue2) &#123;</span><br><span class="line">    <span class="comment">// @ts-expect-error: toRefs include methods and others</span></span><br><span class="line">    <span class="keyword">return</span> toRefs(store) <span class="comment">// vue2 版本直接all in ref</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">    store = toRaw(store) <span class="comment">// 拿到store原始对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> refs = &#123;&#125; <span class="keyword">as</span> ToRefs&lt;</span><br><span class="line">      StoreState&lt;SS&gt; &amp;</span><br><span class="line">        StoreGetters&lt;SS&gt; &amp;</span><br><span class="line">        PiniaCustomStateProperties&lt;StoreState&lt;SS&gt;&gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> store) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = store[key]</span><br><span class="line">      <span class="comment">// 只转换ref、reactive属性</span></span><br><span class="line">      <span class="keyword">if</span> (isRef(value) || isReactive(value)) &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error: the key is state or getter</span></span><br><span class="line">        refs[key] =</span><br><span class="line">          <span class="comment">// ---</span></span><br><span class="line">          toRef(store, key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> refs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map系列辅助函数"><a href="#map系列辅助函数" class="headerlink" title="map系列辅助函数"></a>map系列辅助函数</h2><ul><li><h2 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h2></li></ul><p>基本使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 可以访问组件中的 this.count</span></span><br><span class="line">    <span class="comment">// 与从 store.count 中读取的数据相同</span></span><br><span class="line">    ...mapState(useCounterStore, [<span class="string">'count'</span>])</span><br><span class="line">    <span class="comment">// 与上述相同，但将其注册为 this.myOwnName</span></span><br><span class="line">    ...mapState(useCounterStore, &#123;</span><br><span class="line">      myOwnName: <span class="string">'count'</span>,</span><br><span class="line">      <span class="comment">// 你也可以写一个函数来获得对 store 的访问权</span></span><br><span class="line">      double: <span class="function"><span class="params">store</span> =&gt;</span> store.count * <span class="number">2</span>,</span><br><span class="line">      <span class="comment">// 它可以访问 `this`，但它没有标注类型...</span></span><br><span class="line">      magicValue(store) &#123;</span><br><span class="line">        <span class="keyword">return</span> store.someGetter + <span class="keyword">this</span>.count + <span class="keyword">this</span>.double</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapState</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapHelpers.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapState</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">_GettersTree</span>&lt;<span class="title">S</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  useStore: StoreDefinition&lt;Id, S, G, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  keysOrMapper: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">_MapStateReturn</span>&lt;<span class="title">S</span>, <span class="title">G</span>&gt; | <span class="title">_MapStateObjectReturn</span>&lt;<span class="title">Id</span>, <span class="title">S</span>, <span class="title">G</span>, <span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个对象使得能够放到组件的computed属性上</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(keysOrMapper)</span><br><span class="line">    ? keysOrMapper.reduce(<span class="function">(<span class="params">reduced, key</span>) =&gt;</span> &#123;</span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: ComponentPublicInstance</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 通过useStore，因为store已经创建，所以内部会直接通过pinia._s.get(id)直接返回store而不会重新创建</span></span><br><span class="line">          <span class="keyword">return</span> useStore(<span class="keyword">this</span>.$pinia)[key]</span><br><span class="line">        &#125; <span class="keyword">as</span> () =&gt; <span class="built_in">any</span></span><br><span class="line">        <span class="keyword">return</span> reduced</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> _MapStateReturn&lt;S, G&gt;)</span><br><span class="line">    : <span class="built_in">Object</span>.keys(keysOrMapper).reduce(<span class="function">(<span class="params">reduced, key: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error</span></span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: ComponentPublicInstance</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">const</span> store = useStore(<span class="keyword">this</span>.$pinia)</span><br><span class="line">          <span class="keyword">const</span> storeKey = keysOrMapper[key]</span><br><span class="line">          <span class="comment">// for some reason TS is unable to infer the type of storeKey to be a</span></span><br><span class="line">          <span class="comment">// function</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">typeof</span> storeKey === <span class="string">'function'</span></span><br><span class="line">            ? <span class="function">(<span class="params">storeKey <span class="keyword">as</span> (<span class="params">store: Store&lt;Id, S, G, A&gt;</span>) =&gt; <span class="built_in">any</span></span>).<span class="params">call</span>(<span class="params"><span class="keyword">this</span>, store</span>)</span></span><br><span class="line"><span class="function">            : <span class="params">store</span>[<span class="params">storeKey</span>]</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="params">return</span> <span class="params">reduced</span></span></span><br><span class="line"><span class="function">      &#125;, &#123;&#125; <span class="params">as</span> _<span class="params">MapStateObjectReturn</span>&lt;<span class="params">Id</span>, <span class="params">S</span>, <span class="params">G</span>, <span class="params">A</span>&gt;)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><h2 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h2></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = mapState <span class="comment">//👍</span></span><br></pre></td></tr></table></figure><ul><li><h2 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h2></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mapActions</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">Id</span> <span class="title">extends</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">  <span class="title">S</span> <span class="title">extends</span> <span class="title">StateTree</span>,</span></span><br><span class="line"><span class="function">  <span class="title">G</span> <span class="title">extends</span> <span class="title">_GettersTree</span>&lt;<span class="title">S</span>&gt;,</span></span><br><span class="line"><span class="function">  <span class="title">A</span>,</span></span><br><span class="line"><span class="function">  <span class="title">KeyMapper</span> <span class="title">extends</span> <span class="title">Record</span>&lt;<span class="title">string</span>, <span class="title">keyof</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  useStore: StoreDefinition&lt;Id, S, G, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  keysOrMapper: <span class="built_in">Array</span>&lt;keyof A&gt; | KeyMapper</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">_MapActionsReturn</span>&lt;<span class="title">A</span>&gt; | <span class="title">_MapActionsObjectReturn</span>&lt;<span class="title">A</span>, <span class="title">KeyMapper</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(keysOrMapper)</span><br><span class="line">    ? keysOrMapper.reduce(<span class="function">(<span class="params">reduced, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 和mapState类似,闭包存了下this和其他参数</span></span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">this</span>: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">          ...args: <span class="built_in">any</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> useStore(<span class="keyword">this</span>.$pinia)[key](...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduced</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> _MapActionsReturn&lt;A&gt;)</span><br><span class="line">    : <span class="built_in">Object</span>.keys(keysOrMapper).reduce(<span class="function">(<span class="params">reduced, key: keyof KeyMapper</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// @ts-expect-error</span></span><br><span class="line">        reduced[key] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">this</span>: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">          ...args: <span class="built_in">any</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> useStore(<span class="keyword">this</span>.$pinia)[keysOrMapper[key]](...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduced</span><br><span class="line">      &#125;, &#123;&#125; <span class="keyword">as</span> _MapActionsObjectReturn&lt;A, KeyMapper&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和vuex区别"><a href="#和vuex区别" class="headerlink" title="和vuex区别"></a>和vuex区别</h2><ul><li><h2 id="不再有嵌套结构的模块"><a href="#不再有嵌套结构的模块" class="headerlink" title="不再有嵌套结构的模块"></a>不再有嵌套结构的模块</h2><ul><li>看过vuex的应该知道，整个vuex就是个嵌套的大对象，会根据命名空间一步一步从对象中取出内容，不过内部会帮你拼接命名空间路径，实际调用时也还好</li><li>而pinia不再通过命名空间来嵌套对象，通过pinia._s这个Map结构来存储创建的store，通过pinia.state.value[storeId]来存储state，整个就是一平级的结构</li></ul></li><li><h2 id="创建非常方便，和写一个hook函数一样轻松"><a href="#创建非常方便，和写一个hook函数一样轻松" class="headerlink" title="创建非常方便，和写一个hook函数一样轻松"></a>创建非常方便，和写一个hook函数一样轻松</h2><ul><li>虽然但是，总觉得vue越来越像React，用过hox的应该知道，Pinia的使用方式几乎和hox一模一样。。。</li></ul></li><li><h2 id="无需mutation"><a href="#无需mutation" class="headerlink" title="无需mutation"></a>无需mutation</h2><ul><li>见仁见智吧，有个mutation调用流程更规范，没有就是函数调用，无学习成本</li></ul></li><li><p>总结一下，虽然单项数据流类型的状态管理库（redux、vuex）具有十分严谨的调用步骤，但这种函数式的方式才是未来（主要是开发爽了。。。）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建pinia&quot;&gt;&lt;a href=&quot;#创建pinia&quot; class=&quot;headerlink&quot; title=&quot;创建pinia&quot;&gt;&lt;/a&gt;创建pinia&lt;/h2&gt;&lt;p&gt;基本使用&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;tab
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3响应式属性Reactive和Ref</title>
    <link href="https://summxu.github.io/2023/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B1%9E%E6%80%A7Reactive%E5%92%8CRef/"/>
    <id>https://summxu.github.io/2023/Vue3响应式属性Reactive和Ref/</id>
    <published>2023-02-27T00:49:38.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ref-的基本使用"><a href="#ref-的基本使用" class="headerlink" title="ref 的基本使用"></a>ref 的基本使用</h2><p>1.ref:接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象仅有一个 <code>.value</code> property，指向该内部值。</p><p><strong>注意</strong>：被ref包装之后需要.value 来进行赋值，因为使用ref包装，返回的是一个对象，Ref TS对应的接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, Ref &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">const message: Ref&lt;string&gt; = ref('ref响应式数据');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = '修改后的数据';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>ts的另外一种方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">const message = ref&lt;string | number&gt;('ref响应式数据');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = '修改后的数据';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>3.shallowRef创建一个跟踪自身 <code>.value</code> 变化的 ref，但不会使其值也变成响应式的。&lt;template&gt;</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, shallowRef &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">type Obj = &#123;</span></span><br><span class="line"><span class="regexp">  name: string;</span></span><br><span class="line"><span class="regexp">  num: number;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">const message = shallowRef&lt;Obj&gt;(&#123;</span></span><br><span class="line"><span class="regexp">  name: 'vue3',</span></span><br><span class="line"><span class="regexp">  num: 100</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/修改的值无法显示在页面上</span></span><br><span class="line"><span class="regexp">  message.value.name = '修改了name';</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/修改的值可以显示在页面上</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/message.value = &#123; name: '修改了name', num: 123 &#125;;　</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/triggerRef强制修改，修改的值可以在页面显示  </span></span><br><span class="line"><span class="regexp">  triggerRef(message);</span></span><br><span class="line"><span class="regexp">  console.log(message, 'message');</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>4.customRef 是个工厂函数要求我们返回一个对象 并且实现 get 和 set：</p><p>应用场景：实现防抖函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, shallowRef, triggerRef, customRef &#125; from 'vue';</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">let message = MycustomRef('我是原始数据');</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = '修改了数据';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">function MycustomRef&lt;T&gt;(value: T) &#123;</span></span><br><span class="line"><span class="regexp">  return customRef((track, trigger) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      get: () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        track();/</span><span class="regexp">/通知vue，跟踪数据的变化</span></span><br><span class="line"><span class="regexp">        return value;</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      set: (newVal: T) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        value = newVal;</span></span><br><span class="line"><span class="regexp">        trigger();/</span><span class="regexp">/通知vue重新解析模版，挂载数据</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="ref-为何要用-value"><a href="#ref-为何要用-value" class="headerlink" title="ref 为何要用.value"></a>ref 为何要用.value</h2><blockquote><p>在Vue2中，所有的数据都通过一个Data进行统一的返回，并且在data中对某个组件要用的数据进行统一的管理，常见的使用形式是这样的：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">"div"</span>&gt;</span><br><span class="line">    &lt;todos :Obj=<span class="string">"tos"</span> :removeObj=<span class="string">"removeObj"</span>&gt;&lt;<span class="regexp">/todos&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import search from '@/</span>components/search<span class="string">'</span></span><br><span class="line"><span class="string">import todos from '</span>@/components/todos<span class="string">'</span></span><br><span class="line"><span class="string">import all from '</span>@/components/all<span class="string">'</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  name: '</span>App<span class="string">',</span></span><br><span class="line"><span class="string">  data () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      tos: [</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">001</span><span class="string">', value: '</span>第一个<span class="string">', done: true &#125;,</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">002</span><span class="string">', value: '</span>第二个<span class="string">', done: true &#125;,</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">003</span><span class="string">', value: '</span>第三个<span class="string">', done: false &#125;,</span></span><br><span class="line"><span class="string">        &#123; id: '</span><span class="number">004</span><span class="string">', value: '</span>第四个<span class="string">', done: true &#125;,</span></span><br><span class="line"><span class="string">      ],</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  computed: &#123; &#125;,</span></span><br><span class="line"><span class="string">  components: &#123;</span></span><br><span class="line"><span class="string">    search, todos, all,</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    removeObj (obj) &#123;</span></span><br><span class="line"><span class="string">      console.log(obj.id)</span></span><br><span class="line"><span class="string">      this.tos = this.tos.filter(item =&gt; item.id !== obj.id)</span></span><br><span class="line"><span class="string">      console.log(this.tos)</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出来这里定义的内容都在一个数组中进行，或者是一个函数，将要使用的数据返回出来，这里无论怎么进行操作处理，最终进行数据代理的时候得到的都是一个对象，Vue2中直接通过defineProperty进行处理，并绑定对应的监听事件进行响应式的处理。</p><p>而Vue3中，数据的定义可以是单独的，Vue可以让随时需要随时定义，这也就带来了另一个问题，我需要的一个数据可能不是对象</p><p><strong>如果要定义的数据不是对象，还需要代理会怎么样？</strong></p><ul><li><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</li></ul><p>通过这个可以明确看出，只能进行对象的代理，不能进行普通数据的代理</p><p>在Vue3中数据代理可以使用单一数据了，并且也改进了数据代理的方式，使用的是<code>Proxy</code>完成了数据代理，而MDN中对<code>Proxy</code>也进行了定义：</p><ul><li><code>Proxy</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</li></ul><p>即使是Vue3中使用的<code>Proxy</code>的代理方式也不能进行普通数据的代理，所以当调用Ref的时候其实仍然创建了一个<code>Proxy</code>对象，并且Vue帮你给这个对象了一个value属性，属性值就是你定义的内容，改变的时候监视的改变依然是通过<code>Proxy</code>的数据劫持来进行响应式的处理，而模板中使用的时候Vue会默认调用对应的value属性，从而完成模板中的内容的直接调用 </p><h2 id="Reactive-的基本使用"><a href="#Reactive-的基本使用" class="headerlink" title="Reactive 的基本使用"></a>Reactive 的基本使用</h2><p>1.reactive:用来绑定复杂的数据类型：数组，对象等。</p><p><strong>注意</strong>:reactive如果绑定的是基础类型数据会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; reactive &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">let obj = reactive(&#123;</span></span><br><span class="line"><span class="regexp">  name: '张三',</span></span><br><span class="line"><span class="regexp">  age: 18,</span></span><br><span class="line"><span class="regexp">  boj: &#123;</span></span><br><span class="line"><span class="regexp">    namespaced: true</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  obj.name = '异步赋值无效';</span></span><br><span class="line"><span class="regexp">&#125;, 2000);</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  obj.name = '李四';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>2.readonly:拷贝一份proxy对象并设置为只读属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; reactive, readonly &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">let obj = reactive(&#123;</span></span><br><span class="line"><span class="regexp">  name: '张三',</span></span><br><span class="line"><span class="regexp">  age: 18,</span></span><br><span class="line"><span class="regexp">  boj: &#123;</span></span><br><span class="line"><span class="regexp">    namespaced: true</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">let CopyObj = readonly(obj);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '异步赋值无效';</span></span><br><span class="line"><span class="regexp">&#125;, 2000);</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '李四';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>3.shallowReactive:拷贝一份对象，可以修改浅层数据，无法修改深层数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"onChangeMsg"</span>&gt;修改数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;&#123;&#123; obj.name &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; reactive, shallowReactive &#125; from 'vue';</span></span><br><span class="line"><span class="regexp">let obj = reactive(&#123;</span></span><br><span class="line"><span class="regexp">  name: '张三',</span></span><br><span class="line"><span class="regexp">  age: 18,</span></span><br><span class="line"><span class="regexp">  boj: &#123;</span></span><br><span class="line"><span class="regexp">    namespaced: true</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">let CopyObj = shallowReactive(obj);</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/可以修改</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '异步赋值';</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/无法修改</span></span><br><span class="line"><span class="regexp">  CopyObj.boj.namespaced = false;</span></span><br><span class="line"><span class="regexp">&#125;, 2000);</span></span><br><span class="line"><span class="regexp">console.log(CopyObj.boj.namespaced);</span></span><br><span class="line"><span class="regexp">const onChangeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  CopyObj.name = '李四';</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ref-的基本使用&quot;&gt;&lt;a href=&quot;#ref-的基本使用&quot; class=&quot;headerlink&quot; title=&quot;ref 的基本使用&quot;&gt;&lt;/a&gt;ref 的基本使用&lt;/h2&gt;&lt;p&gt;1.ref:接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象仅有一
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3中watch和watchEffect的用法和区别</title>
    <link href="https://summxu.github.io/2022/Vue3%E4%B8%ADwatch%E5%92%8CwatchEffect%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://summxu.github.io/2022/Vue3中watch和watchEffect的用法和区别/</id>
    <published>2022-10-12T09:13:34.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-watch-基本使用"><a href="#1-1-watch-基本使用" class="headerlink" title="1.1 watch 基本使用"></a>1.1 watch 基本使用</h3><p>在 Vue3 中的组合式 API 中，watch 的作用和 Vue2 中的 watch 作用是一样的，他们都是用来监听响应式状态发生变化的，当响应式状态发生变化时，都会触发一个回调函数。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">"Vue logo"</span> src=<span class="string">"./assets/logo.png"</span> /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button @click="changeMsg"&gt;更改 message&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; ref, watch &#125; from "vue";</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const message = ref("李四");</span></span><br><span class="line"><span class="regexp">watch(message, (newValue, oldValue) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log("新的值:", newValue);</span></span><br><span class="line"><span class="regexp">  console.log("旧的值:", oldValue);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">const changeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = "张三";</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>上段代码中点击按钮就会更改响应式变量 message 的值。又使用 watch 监听器监听了 message 变量，当它发生变化时，就会触发 watch 监听函数中的回调函数，并且回调函数默认接收两个参数：新值和旧值。</p><p><strong>注意：当第一进入页面时，watch 监听函数的回调函数是不会执行的。</strong></p><h3 id="1-2-watch-监听类型"><a href="#1-2-watch-监听类型" class="headerlink" title="1.2 watch 监听类型"></a>1.2 watch 监听类型</h3><p>前面一直强调 watch 监听的是响应式数据，如果监听的数据不是响应式的，那么可能会抛出警告。</p><p><strong>（1）ref 和计算属性</strong></p><p>ref 定义的数据是可以监听到的，因为前面的代码以及证明了。除此之外，计算属性也是可以监听到的，比如下列代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = ref(<span class="string">"李四"</span>);</span><br><span class="line"><span class="keyword">const</span> newMessage = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> message.value;</span><br><span class="line">&#125;);</span><br><span class="line">watch(newMessage, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 message 发生变化时，计算属性 newMessage 也会重新计算得出新的结果， watch 监听函数是可以监听到计算属性变化的。</p><p><strong>（2）getter 函数</strong></p><p>这里的 getter 函数可以简单的理解为获取数据的一个函数，说白了该函数就是一个返回值的操作，有点类似与计算属性。</p><p><strong>示例代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">"Vue logo"</span> src=<span class="string">"./assets/logo.png"</span> /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&#123;&#123; x1 + x2 &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">"changeMsg"</span>&gt;更改 message&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script setup lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = ref(<span class="string">"李四"</span>);</span><br><span class="line"><span class="keyword">const</span> x1 = ref(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">const</span> x2 = ref(<span class="number">13</span>);</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; x1.value + x2.value,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> changeMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  message.value = <span class="string">"张三"</span>;</span><br><span class="line">  x1.value = <span class="number">14</span>;</span><br><span class="line">  x2.value = <span class="number">23</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上段代码中 watch 监听器中的第一个参数是一个箭头函数，也就是 getter 函数，getter 函数返回的是响应式数据 x1 和 x2 相加的值，当这两个中中有一个变化，都会执行 watch 中的回调函数。有点像是直接把计算属性写到监听器里面去了。</p><p><strong>（3）监听响应式对象</strong></p><p>前面监听的都是值类型的响应式数据，同样也可以监听响应式的对象。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(<span class="built_in">number</span>, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 watch 监听的是一个响应式对象时，会隐式地创建一个深层侦听器，即该响应式对象里面的任何属性发生变化，都会触发监听函数中的回调函数。</p><p>需要注意的，watch 不能直接监听响应式对象的属性，即下面的写法是错误的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(<span class="built_in">number</span>.count, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上段代码中相当于你直接向 watch 传递了一个非响应式的数字，然而 watch 只能监听响应式数据。</p><p><strong>但是：</strong></p><p>如果非要监听响应式对象中的某个属性，可以使用 getter 函数的形式，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>.count,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上段代码也是可以监听到 count 变化的。</p><p><strong>（4）监听多个来源的数组</strong></p><p>watch 还可以监听数组，前提是这个数组内部含有响应式数据。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x1 = ref(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch([x1, <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">number</span>.count], <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-3-深度监听"><a href="#1-3-深度监听" class="headerlink" title="1.3 深度监听"></a>1.3 深度监听</h3><p>在前面的代码中，如果将一个响应式对象传递给 watch 监听器时，只要对象里面的某个属性发生了变化，那么就会执行监听器回调函数。</p><p>究其原因，因为传入响应对象给 watch 时，隐式的添加一个深度监听器，这就让造成了牵一发而至全身的效果。</p><p>但是，如果是使用的 getter 函数返回响应式对象的形式，那么响应式对象的属性值发生变化，是不会触发 watch 的回调函数的。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上段代码中使用 getter 函数返回了响应式对象，当更改 number 中 count 的值时，watch 的回调函数是不会执行的。</p><p>为了实现上述代码的监听，可以手动给监听器加上深度监听的效果。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; deep: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加深度监听很简单，只需要给 watch 添加第三个参数即可：{ deep: true }。</p><p><strong>注意：</strong>上段代码中的 newValue 和 oldValue 的值是一样的，除非把响应式对象即 number 整个替换掉，那么这两个值才会变得不一样。除此之外，深度监听会遍历响应式对象的所有属性，开销较大，当对象体很大时，需要慎用<strong>。</strong></p><p><strong>所以推荐 getter 函数只返回相应是对象中的某一个属性！！</strong></p><h2 id="2-watchEffect"><a href="#2-watchEffect" class="headerlink" title="2.watchEffect"></a>2.watchEffect</h2><p>前面使用 watch 监听数据状态时，不知道有没有发现这样一个问题：只有当监听的数据源发生了变化，监听函数的回调函数才会执行。但是需求总是多变的，有些场景下可能需要刚进页面，或者说第一次渲染页面的时候，watch 监听器里面的回调函数就执行一遍。</p><p>面对这种需求怎样处理呢？一般有两种方式：</p><p><strong>方式一：</strong></p><p>这种方式也是通过 watch 实现的，确切的说是巧妙的实现，而不是依赖于 watch 监听器。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="comment">// 进入页面先执行一遍</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, <span class="built_in">number</span>.count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, <span class="built_in">number</span>.count);</span><br><span class="line">&#125;;</span><br><span class="line">callback();</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; <span class="built_in">number</span>.count,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; deep: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>既然想要第一次进入页面的时候就执行一遍回调函数，那么不妨把回调函数直接提取出来，进入页面执行一遍即可，这也算是巧妙的实现了的需求。</p><p>但是这种方式似乎不太优雅，而且有些繁琐。所以 Vue 推出了更加优雅的方法：watchEffect 监听器。</p><p><strong>方式二：</strong></p><p>watchEffect 也是一个监听器，只不过它不会像 watch 那样接收一个明确的数据源，它只接收一个回调函数。而在这个回调函数当中，它会自动监听响应数据，当回调函数里面的响应数据发生变化，回调函数就会立即执行。</p><p>所以可以将方式一中的代码使用 watchEffect 优雅的实现。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = reactive(&#123; count: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> countAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">number</span>.count++;</span><br><span class="line">&#125;;</span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, <span class="built_in">number</span>.count);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上段代码中，当第一次进入页面时，number 响应数据从无到有，这个时候就会触发 watchEffect 的回调函数，因为在 watchEffect 回调函数中使用了 number 响应数据，所以它会自动跟踪 number 数据的变化。当点击按钮更改 count 的值时，watchEffect 中的回调函数便会再次执行。</p><p>这样代码是不是简单很多呀！</p><h2 id="3-watch-和-watchEffect-区别"><a href="#3-watch-和-watchEffect-区别" class="headerlink" title="3.watch 和 watchEffect 区别"></a>3.watch 和 watchEffect 区别</h2><p>已经大概知道了 watch 和 watchEffect 的用法，那么它们之间的区别相信也了解了一些，这里总结一下它们之间的区别。</p><ul><li>watch 和 watchEffect 都能监听响应式数据的变化，不同的是它们监听数据变化的方式不同。</li><li>watch 会明确监听某一个响应数据，而 watchEffect 则是隐式的监听回调函数中响应数据。</li><li>watch 在响应数据初始化时是不会执行回调函数的，watchEffect 在响应数据初始化时就会立即执行回调函数。</li></ul><h2 id="4-回调中的-DOM"><a href="#4-回调中的-DOM" class="headerlink" title="4.回调中的 DOM"></a>4.回调中的 DOM</h2><p>如果在监听器的回调函数中或取 DOM，这个时候的 DOM 是更新前的还是更新后的？</p><p>不妨实验一下。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=<span class="string">"Vue logo"</span> src=<span class="string">"./assets/logo.png"</span> /&gt;</span><br><span class="line">  &lt;p ref=<span class="string">"msgRef"</span>&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button @click="changeMsg"&gt;更改 message&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script setup lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; computed, reactive, ref, watch, watchEffect &#125; from "vue";</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const message = ref("李四");</span></span><br><span class="line"><span class="regexp">const msgRef = ref&lt;any&gt;(null);</span></span><br><span class="line"><span class="regexp">const changeMsg = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  message.value = "张三";</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">watch(message, (newValue, oldValue) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log("DOM 节点", msgRef.value.innerHTML);</span></span><br><span class="line"><span class="regexp">  console.log("新的值:", newValue);</span></span><br><span class="line"><span class="regexp">  console.log("旧的值:", oldValue);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>通过点击按钮更改 message 的值，从“李四”变为“张三”。但是发现在监听器的回调函数里面获取到的 DOM 元素还是“李四”，说明 DOM 还没有更新。</p><p><strong>解决方法：</strong></p><p>如果想要在回调函数里面获取更新后的 DOM，非常简单，只需要再给监听器多传递一个参数选项即可：flush: ‘post’。watch 和 watchEffect 同理。</p><p><strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, &#123;</span><br><span class="line">  flush: <span class="string">'post'</span></span><br><span class="line">&#125;)</span><br><span class="line">watchEffect(callback, &#123;</span><br><span class="line">  flush: <span class="string">'post'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>修改后的代码：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  message,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"DOM 节点"</span>, msgRef.value.innerHTML);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新的值:"</span>, newValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"旧的值:"</span>, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    flush: <span class="string">"post"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个时候在回调函数中获取到的已经是更新后的 DOM 节点了。</p><p><strong>补充：</strong></p><p>虽然 watch 和 watchEffect 都可以用上述方法解决 DOM 问题，但是 Vue3 单独给 watchEffect 提供了一个更方便的方法，也可以叫做 watchEffect 的别名，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watchPostEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 在 Vue 更新后执行 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-手动停止监听器"><a href="#5-手动停止监听器" class="headerlink" title="5.手动停止监听器"></a>5.手动停止监听器</h2><p>通常来说，的一个组件被销毁或者卸载后，监听器也会跟着被停止，并不需要手动去关闭监听器。但是总是有一些特殊情况，即使组件卸载了，但是监听器依然存在，这个时候其实式需要手动关闭它的，否则容易造成内存泄漏。</p><p>比如下面这中写法，就需要手动停止监听器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; watchEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// 它会自动停止</span></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// ...这个则不会！</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上段代码中采用异步的方式创建了一个监听器，这个时候监听器没有与当前组件绑定，所以即使组件销毁了，监听器依然存在。</p><p>关闭方法很简单，<strong>代码如下：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// ...当该侦听器不再需要时</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure><p>需要用一个变量接收监听器函数的返回值，其实就是返回的一个函数，然后调用该函数，即可关闭当前监听器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-1-watch-基本使用&quot;&gt;&lt;a href=&quot;#1-1-watch-基本使用&quot; class=&quot;headerlink&quot; title=&quot;1.1 watch 基本使用&quot;&gt;&lt;/a&gt;1.1 watch 基本使用&lt;/h3&gt;&lt;p&gt;在 Vue3 中的组合式 API 中，wat
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>React实现原理及Fiber架构</title>
    <link href="https://summxu.github.io/2022/React%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8AFiber%E6%9E%B6%E6%9E%84/"/>
    <id>https://summxu.github.io/2022/React实现原理及Fiber架构/</id>
    <published>2022-05-12T01:36:14.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h2><p><strong>定义</strong>：vdom 就是根据真实dom的属性使用js重新按照原有结构模拟出一份dom对象，dom api 对真实 dom 做增删改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'div'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        id: <span class="string">'aaa'</span>,</span><br><span class="line">        className: [<span class="string">'bbb'</span>, <span class="string">'ccc'</span>],</span><br><span class="line">        onClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 vdom 的好处，就没有和 dom 强绑定了，可以跨平台渲染，比如 native、canvas 等等。</p><p>但是要让开发去写这样的 vdom 么？</p><p>那肯定不行，这样太麻烦了，大家熟悉的是 html 那种方式，所以要引入一些编译的手段。</p><h2 id="dsl-的编译"><a href="#dsl-的编译" class="headerlink" title="dsl 的编译"></a>dsl 的编译</h2><p>dsl 是 domain specific language，领域特定语言的意思，html、css 都是 web 领域的 dsl。</p><p>直接写 vdom 太麻烦了，所以前端框架都会设计一套 dsl，然后编译成 render function，执行后产生 vdom。</p><p>vue 和 react 都是这样：</p><blockquote><p>jsx -&gt; render function -&gt; vdom</p></blockquote><p>这套 dsl 怎么设计呢？</p><p>前端领域大家熟悉的描述 dom 的方式是 html，最好的方式自然是也设计成那样。</p><p>所以 vue 的 template，react 的 jsx 就都是这么设计的。</p><p>vue 的 template compiler 是自己实现的，而 react 的 jsx 的编译器是 babel 实现的，是两个团队合作的结果。</p><h2 id="渲染-vdom"><a href="#渲染-vdom" class="headerlink" title="渲染 vdom"></a>渲染 vdom</h2><p>渲染 vdom 也就是通过 dom api 增删改 dom。</p><p>比如一个 div，那就要 document.createElement 创建元素，然后 setAttribute 设置属性，addEventListener 设置事件监听器。</p><p>如果是文本，那就要 document.createTextNode 来创建。</p><p>所以说根据 vdom 类型的不同，写个 if else，分别做不同的处理就行了。</p><p>没错，不管 vue 还是 react，渲染器里这段 if else 是少不了的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (vdom.tag) &#123;</span><br><span class="line">  <span class="keyword">case</span> HostComponent:</span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">  <span class="keyword">case</span> HostText:</span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">  <span class="keyword">case</span> FunctionComponent: </span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">  <span class="keyword">case</span> ClassComponent: </span><br><span class="line">    <span class="comment">// 创建或更新 dom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react 里是通过 tag 来区分 vdom 类型的，比如 <code>HostComponent</code> 就是元素，<code>HostText</code> 就是文本，<code>FunctionComponent</code>、<code>ClassComponent</code> 就分别是函数组件和类组件。</p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>react <strong>没有响应式系统</strong>，是通过 <code>setState</code> 的 api 触发状态更新的，更新以后就<strong>重新渲染整个 vdom</strong>。</p><blockquote><p>vue 是通过对状态做代理，get 的时候收集以来，然后修改状态的时候就可以触发对应组件的 render 了，不管是子组件、父组件、还是其他位置的组件，只要用到了对应的状态，那就会被作为依赖收集起来，状态变化的时候就可以触发它们的 render，不管是组件是在哪里的。</p></blockquote><p>这就是为什么 react 需要重新渲染整个 vdom，而 vue 不用。</p><p>react 的 <code>setState</code> 会渲染整个 vdom，而一个应用的所有 vdom 可能是很庞大的，计算量就可能很大。</p><p>浏览器里 js 计算时间太长是会阻塞渲染的，会占用每一帧的动画、重绘重排的时间，这样动画就会卡顿。</p><p>作为一个有追求的前端框架，动画卡顿肯定是不行的。但是因为 <code>setState</code> 的方式只能渲染整个 vdom，所以计算量大是不可避免的。</p><p>那能不能把计算量拆分一下，每一帧计算一部分，不要阻塞动画的渲染呢？</p><p>顺着这个思路，react 就改造为了 fiber 架构。</p><h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><h3 id="一：Fiber的概念"><a href="#一：Fiber的概念" class="headerlink" title="一：Fiber的概念"></a>一：Fiber的概念</h3><p>React Fiber是react执行渲染时的一种新的调度策略，JavaScript是单线程的，一旦组件开始更新，主线程就一直被React控制，这个时候如果再次执行交互操作，就会卡顿。</p><p>  React Fiber就是通过对象记录组件上需要做或者已经完成的更新，一个组件可以对应多个Fiber。</p><p>  在render函数中创建的React Element树在第一次渲染的时候会创建一颗结构一模一样的的Fiber节点树。不同的React Element类型对应不同的Fiber节点类型。一个React Element的工作就由它对应的Fiber节点来负责。</p><p>  一个React Element可以对应不止一个Fiber，因为Fiber在update的时候，会从原来的Fiber(我们称为current)clone出一个新的Fiber(我们称之为alternate)。俩个Fiber diff出的变化(side effect)记录在alternate上。所以一个组件在更新时最多会有俩个Fiber与其对应，在更新结束后alternate会取代之前的current称为新的current节点。</p><p>  React Fiber重构这种方式，渲染过程采用切片的方式，每执行一会儿，就歇一会儿。如果有优先级更高的任务到来以后呢，就会先去执行，降低页面发生卡顿的可能性，使得React对动画等实时性要求较高的场景体验更好。</p><h3 id="二：什么是Fiber？"><a href="#二：什么是Fiber？" class="headerlink" title="二：什么是Fiber？"></a>二：什么是Fiber？</h3><p>  当js在处理大型计算的时候会导致页面出现卡帧的现象，更严重的会出现页面“假死”。所以在这些情况下，必然会导致动画丢帧、不连贯，用户体验就特别差。为了解决这个问题，我们可以将大型的计算拆分成一个个小型计算，然后按照执行顺序异步调用，这样就不会长时间霸占线程，UI也能在俩次小型计算的执行间隙进行更新，从而给与用户及时的反馈，Fiber就是这样做的，并且以一种更高逼格的方式实现了。<br><strong>Driving Idea</strong><br>  如果说v16.0之前的React解决了HOW(如何用最少的DOM操作成本来update视图)的问题，那么这一次Fiber的出现，在这个基础上还解决了WHEN(何时update视图的哪一部分)的问题。<br>   <strong>分片优先级！！！</strong></p><p>  基于上述这些原因，Fiber实现了一个虚拟调用栈，并给所有的update进行优先级排序，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"> </span><br><span class="line">NoWork: 0, // No work is pending.</span><br><span class="line"> </span><br><span class="line">SynchronousPriority: 1, // 用于控制文本输入。同步的副作用.</span><br><span class="line"></span><br><span class="line">AnimationPriority: 2, //需要在下一帧之前完成.</span><br><span class="line"> </span><br><span class="line">HighPriority: 3, // 需要很快完成的互动才能产生反应.</span><br><span class="line"> </span><br><span class="line">LowPriority: 4, // 数据获取，或更新存储的结果.</span><br><span class="line"> </span><br><span class="line">OffscreenPriority: 5, // 将不可见，但做的工作，以防它成为可见.</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  然后根据这些update的优先级，来决定执行的顺序。<br>  我们可以看到动画和页面交互都是优先级比较高的，这也是Fiber能够使得动画、布局和页面交互变得更加的流畅的原因之一。<br>  可以把Priority分为同步和异步两个类别，同步优先级的任务会在当前帧完成，包括SynchronousPriority和TaskPriority。异步优先级的任务则可能在接下来的几个帧中被完成，包括HighPriority、LowPriority以及OffscreenPriority。<br>  React v16.3.2的优先级，不再这么划分，分为三类：NoWork、sync、async，前两类可以认为是同步任务，需要在当前tick完成，过期时间为null，最后一类异步任务会计算一个。<br>  expirationTime，在workLoop中，根据过期时间来判断是否进行下一个分片任务，scheduleWork中更新任务优先级，也就是更新这个expirationTime。至于这个时间怎么计算，可以查看源码。</p><h3 id="三：Fiber的基本原则："><a href="#三：Fiber的基本原则：" class="headerlink" title="三：Fiber的基本原则："></a>三：Fiber的基本原则：</h3><p>  更新任务分成俩个阶段，Reconcilition Phase(调和阶段)和Commit Phase(交付阶段)。Reconciliation Phase的任务干的事情是，找出要做的更新工作(Diff Fiber Tree),就是一个计算阶段，计算结果可以被缓存，也就可以被打断；Commit Phase需要提交所有更新并渲染，为了防止页面抖动，被设置为不能打断。<br>  <strong>PS：componentWillMount</strong><br>  omponentWillReceiveProps componentWillUpdate 几个生命周期方法，在Reconciliation Phase被调用，有被打断的可能（时间用尽等情况），所以可能被多次调用。其实shouldComponentUpdate 也可能被多次调用，只是它只返回true或者false，没有副作用，可以暂时忽略。</p><h3 id="四：Fiber的数据结构"><a href="#四：Fiber的数据结构" class="headerlink" title="四：Fiber的数据结构"></a>四：Fiber的数据结构</h3><p>  fiber是个链表，有child和sibing属性，指向第一个子节点和相邻的兄弟节点，从而构成fiber tree。return 属性指向其父节点。<br>  更新队列，updateQueue，是一个链表，有first和last俩个属性，指向第一个和最后一个update对象。<br>  每个fiber有一个属性updateQueue指向其对应的更新队列。<br>  每个fiber(当前fiber可以称为current)有一个属性alternate，开始时指向一个自己的clone体，update的变化会先更新到alternate上，当更新完毕，alternate替换current。</p><h3 id="五：Fiber的执行流程"><a href="#五：Fiber的执行流程" class="headerlink" title="五：Fiber的执行流程"></a>五：Fiber的执行流程</h3><ol><li>用户操作引起setState被调用以后，先调用enqueueSetState方法，该方法可以划分成俩个阶段（个人理解），第一阶段Data Preparation，是初始化一些数据结构，比如fiber，updateQueue，update。</li><li>新的update会通过insertUpdateIntoQueue方法，根据优先级插入到队列的对应位置，ensureUpdateQueues方法初始化俩个更新队列，queue1和current.updateQueue对应，queue2和current.alternate.updateQueue对应。</li><li>第二阶段，Fiber Reconciler，就开始进行任务分片调度，scheduleWork首先更新每个fiber的优先级，这里并没有updatePriority这个方法，但是干了这件事。当fiber.return === null，找到父节点，把所有diff出的变化(side effect)归结到root上。</li><li>requestWork，首先把当前的更新添加到schedule list中(addRootToSchedule),然后根据当前是否为异步渲染(isAsync参数)，异步渲染调用。scheduleCallbackWithExpriation方法，下一步高能！！</li><li>scheduleCallbackWithExpriation这个方法在不同环境，实现不一样，chrome等浏览器中使用requestIdleCallback API，没有这个API的浏览器中，通过requestAnimationFrame模拟一个requestIdCallback，来在浏览器空闲时，完成下一个分片的工作，注意，这个函数会传入一个expirationTime，超过这个时间活没干完，就放弃了。</li><li>执行到performWorkOnRoot，就是fiber文档中提到的Commit Phase和Reconciliation Phase俩阶段。</li><li>第一阶段Reconciliation Phase,在workLoop中，通过一个while循环，完成每个分片任务。</li><li>performUnitOfWork也可以分成俩阶段，蓝色框表示。beginWork是一个入口函数，根据workInProgress的类型去实例化不同的react element class。workInProgress是通过alternate挂载一些新属性获得的。</li><li>实例化不同的react element class时候会调用和will有关的生命周期方法。</li><li>completeUnitOfWork是进行一些收尾工作，diff完一个节点以后，更新props和调用生命周期方法等。</li><li>然后进入Commit Phase阶段，这个阶段不能被打断。</li></ol><h3 id="六：Fiber对开发者有什么影响？"><a href="#六：Fiber对开发者有什么影响？" class="headerlink" title="六：Fiber对开发者有什么影响？"></a>六：Fiber对开发者有什么影响？</h3><ol><li>componentWillMount,componentWillReceiveProps,componentWillUpdate几个生命周期方法不再安全，由于任务执行过程可以被打断，这几个生命周期可能会执行多次，如果它们包含副作用(比如Ajax)，会有意想不到的bug。React团队提供了替换的生命周期方法。建议如果使用以上方法，尽量使用纯函数，避免以后踩坑。</li><li>需要关注react为任务片设置的优先级，特别是页面用动画的情况。</li><li>如果一直有更高的级别任务，那么fiber算法会先执行级别更高的任务，执行完毕后再通过callback回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是react确实是这么干的）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vdom&quot;&gt;&lt;a href=&quot;#vdom&quot; class=&quot;headerlink&quot; title=&quot;vdom&quot;&gt;&lt;/a&gt;vdom&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：vdom 就是根据真实dom的属性使用js重新按照原有结构模拟出一份dom对象，do
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://summxu.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Redux源码全面解析</title>
    <link href="https://summxu.github.io/2022/Redux%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <id>https://summxu.github.io/2022/Redux源码全面解析/</id>
    <published>2022-02-26T01:36:37.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<p>Redux使用中的几个点：</p><ol><li>Redux三大设计原则</li><li>Create Store</li><li>Redux middleware</li><li>combineReducer</li><li>Provider与Connect</li><li>Redux流程梳理</li><li>Redux设计特点</li></ol><h4 id="1-单一数据源"><a href="#1-单一数据源" class="headerlink" title="1. 单一数据源"></a>1. 单一数据源</h4><p>在传统的 MVC 架构中，可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。因为在 Redux 的思想里，一个应用永远只有唯一的数据源。实际上，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样随时可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）。此外，这样的设计也为服务端渲染提供了可能。</p><h4 id="2-状态是只读的"><a href="#2-状态是只读的" class="headerlink" title="2. 状态是只读的"></a>2. 状态是只读的</h4><p>在 Redux 中，并不会自己用代码来定义一个 store。取而代之的是，定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里并没有直接修改应用的状态，而是返回了一份全新的状态。</p><p>Redux 提供的 createStore 方法会根据 reducer 生成 store。最后，可以利用 store. dispatch方法来达到修改状态的目的。</p><h4 id="3-状态修改均由纯函数完成"><a href="#3-状态修改均由纯函数完成" class="headerlink" title="3.状态修改均由纯函数完成"></a>3.状态修改均由纯函数完成</h4><p>在 Redux 里，通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。</p><p>这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux 利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发 action 而改变状态的结果成为了可能。</p><h2 id="2-Create-Store"><a href="#2-Create-Store" class="headerlink" title="2.Create Store"></a>2.Create Store</h2><p>从store的诞生开始说起。create store函数API文档如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createStore(reducer, [initialState], enhancer)</span><br></pre></td></tr></table></figure><p>可以看出，它接受三个参数：reducer、initialState 和 enhancer 。Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。</p><p>再来看看他的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    dispatch: f (action),</span><br><span class="line">    getState: f (),</span><br><span class="line">    replaceReducer: f (nextReducer),</span><br><span class="line">    subscribe: f (listener),</span><br><span class="line">    <span class="built_in">Symbol</span>(observable): f ()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>store的返回值就是一个普通对象，里面有几个常用的方法：</p><ul><li>dispatch：就是最常用的dispatch方法，派发action。</li><li>getState：通过该方法，可以拿到当前状态树state。</li><li>replaceReducer：这个方法主要用于 reducer 的热替换，下面介绍该方法。</li><li>subscribe：添加一个变化监听器。每当 dispatch（action）的时候就会执行，state 树中的一部分可能已经变化。</li><li>observable：观察者模式，用于处理订阅关系。</li></ul><p>这里挑几个方法介绍：</p><h3 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h3><p>在完成基本的参数校验之后，在 createStore 中声明如下变量及 getState 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentReducer = reducer</span><br><span class="line"><span class="keyword">var</span> currentState = initialState</span><br><span class="line"><span class="keyword">var</span> listeners = [] <span class="comment">// 当前监听 store 变化的监听器</span></span><br><span class="line"><span class="keyword">var</span> isDispatching = <span class="literal">false</span> <span class="comment">// 某个 action 是否处于分发的处理过程中</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Reads the state tree managed by the store.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">* @returns &#123;any&#125; The current state tree of your application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> currentState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getState方法就是简单返回当前state，如果state没有被reducer处理过，他就是initialState。</p><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p>在 getState 之后，定义了 store 的另一个方法 subscribe：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line"> listeners.push(listener)</span><br><span class="line"> <span class="keyword">var</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> isSubscribed = <span class="literal">false</span></span><br><span class="line"> <span class="keyword">var</span> index = listeners.indexOf(listener)</span><br><span class="line"> listeners.splice(index, <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Store 允许使用<code>store.subscribe</code>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p><p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入<code>listen</code>，就会实现 View 的自动渲染。你可能会感到奇怪，好像在 Redux 应用中并没有使用 store.subscribe 方法？事实上，</p><p>React Redux 中的 connect 方法隐式地帮完成了这个工作。</p><p><code>store.subscribe</code>方法返回一个函数，调用这个函数就可以解除监听。</p><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>dispatch是redux的核心方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">            <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">            <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        isDispatching = <span class="literal">true</span></span><br><span class="line">        currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    listeners.slice().forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前是否处于某个 action 的分发过程中，这个检查主要是为了避免在 reducer 中分发 action 的情况，因为这样做可能导致分发死循环，同时也增加了数据流动的复杂度。</p><p>确认当前不属于分发过程中后，先设定标志位，然后将当前的状态和 action 传给当前的reducer，用于生成最新的 state。这看起来一点都不复杂，这也是反复强调的 reducer 工作过程——纯函数、接受状态和 action 作为参数，返回一个新的状态。</p><p>在得到新的状态后，依次调用所有的监听器，通知状态的变更。需要注意的是，在通知监听器变更发生时，并没有将最新的状态作为参数传递给这些监听器。这是因为在监听器中，可以直接调用 store.getState() 方法拿到最新的状态。</p><p>最终，处理之后的 action 会被 dispatch 方法返回。</p><h3 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    currentReducer = nextReducer;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是为了拿到所有 reducer 中的初始状态（你是否还记得在定义 reducer 时，第一个参数为previousState，如果该参数为空，提供默认的 initialState）。只有所有的初始状态都成功获取后，Redux 应用才能有条不紊地开始运作。</p><h2 id="3-Redux-middleware"><a href="#3-Redux-middleware" class="headerlink" title="3.Redux middleware"></a>3.Redux middleware</h2><blockquote><p>It provides a third-party extension point between dispatching an action, and the moment it reachesthe reducer</p></blockquote><p>它提供了一个分类处理 action 的机会。在middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的action 进行相应操作，给你一次改变 action 的机会。</p><p>常规的同步数据流模式的流程图如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://sslstatic.ktanx.com/images/release/201811/Tr2gHBdB9tYoeS97.png" alt="f2BVgyd4bOqmbmPx.png](https://sslstatic.ktanx.com/images/release/201811/f2BVgyd4bOqmbmPx.png)不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：![Tr2gHBdB9tYoeS97.png" title>                </div>                <div class="image-caption">f2BVgyd4bOqmbmPx.png](https://sslstatic.ktanx.com/images/release/201811/f2BVgyd4bOqmbmPx.png)不同业务需求下，比如执行action之前和之后都要打log；action触发一个异步的请求，请求回来之后渲染view等。需要为这一类的action添加公共的方法或者处理，使用redux middleware流程图如下：![Tr2gHBdB9tYoeS97.png</div>            </figure>每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware 实现变化多样的功能。比如上面的业务，把处理log的代码封装成一个middleware，处理异步的也是一个middleware，两者串联，却又相互独立。</p><p>使用middleware之后，action触发的dispatch并不是原来的dispatch，而是经过封装的new dispatch，在这个new dispatch中，按照顺序依次执行每个middleware，最后调用原生的dispatch。</p><p>来看下logger middleware如何实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action); </span><br><span class="line">    next(action);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里代码十分简洁，就是在next调用下一个middleware之前和之后，分别打印两次。</p><p>Redux 提供了 applyMiddleware 方法来加载 middleware，该方法的源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, initialState</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> store = next(reducer, initialState);</span><br><span class="line">            <span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">            <span class="keyword">let</span> chain = [];</span><br><span class="line">            <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">                getState: store.getState,</span><br><span class="line">                dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action),</span><br><span class="line">            &#125;;</span><br><span class="line">            chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">            dispatch = compose(...chain)(store.dispatch);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...store,</span><br><span class="line">                dispatch,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中compose源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> funcs.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newStore = applyMiddleware([mid1, mid2, mid3, ...])(createStore)(reducer, initialState);</span><br></pre></td></tr></table></figure><p>ok，相关源码已就位，来详细解析一波。</p><p><strong>函数式编程思想设计</strong> ：middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的currying，它是一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个middleware 进行层层调用，动态地将 store 和 next 参数赋值。currying 的 middleware 结构的好处主要有以下两点。</p><ul><li>易串联：currying 函数具有延迟执行的特性，通过不断 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeline 来处理数据流。</li><li> 共享 store: 在 applyMiddleware 执行的过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。</li></ul><p><strong>给 middleware 分发 store</strong>：newStore创建完成之后，applyMiddleware 方法陆续获得了3个参数，第一个是 middlewares 数组[mid1, mid2, mid3, …]，第二个是 Redux 原生的 createStore ，最后一个是 reducer。然后，可以看到 applyMiddleware 利用 createStore 和 reducer 创建了一个 store。而 store 的 getState方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量 store：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line"> getState: store.getState,</span><br><span class="line"> dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action),</span><br><span class="line">&#125;;</span><br><span class="line">chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br></pre></td></tr></table></figure><p>然后，让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍。执行完后，获得 chain数组 [f1, f2, … , fx, …, fn]，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数都可以访问相同的 store，即 middlewareAPI。</p><blockquote><p>middlewareAPI 中的 dispatch 为什么要用匿名函数包裹呢？</p><p>用 applyMiddleware 是为了改造 dispatch，所以 applyMiddleware 执行完后，dispatch 是变化了的，而 middlewareAPI 是 applyMiddleware 执行中分发到各个 middleware 的，所以必须用匿名函数包裹 dispatch，这样只要 dispatch 更新了，middlewareAPI 中的 dispatch 应用也会发生变化。</p></blockquote><p><strong>组合串联 middleware</strong>：这一层只有一行代码，却是 applyMiddleware 精华之所在<code>dispatch = compose(...chain)(store.dispatch);</code>，其中 compose 是函数式编程中的组合，它将 chain 中的所有匿名函数 [f1, f2, … , fx, …, fn]组装成一个新的函数，即新的 dispatch。当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行。</p><p>compose(…funcs) 返回的是一个匿名函数，其中 funcs 就是 chain 数组。当调用 reduceRight时，依次从 funcs 数组的右端取一个函数 fx 拿来执行，fx 的参数 composed 就是前一次 fx+1 执行的结果，而第一次执行的 fn（n 代表 chain 的长度）的参数 arg 就是 store.dispatch。所以，当 compose 执行完后，得到的 dispatch 是这样的，假设 n = 3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch = f1(f2(f3(store.dispatch))));</span><br></pre></td></tr></table></figure><p>这时调用新 dispatch，每一个 middleware 就依次执行了。</p><p><strong>在 middleware 中调用 dispatch 会发生什么</strong>：经过 compose 后，所有的 middleware 算是串联起来了。可是还有一个问题，在分发 store 时，提到过每个 middleware 都可以访问 store，即 middlewareAPI 这个变量，也可以拿到 store 的dispatch 属性。那么，在 middleware 中调用 store.dispatch() 会发生什么，和调用 next() 有区别吗？现在来说明两者的不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action);</span><br><span class="line"> next(action);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'dispatch:'</span>, action);</span><br><span class="line"> store.dispatch(action);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'finish:'</span>, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在分发 store 时解释过，middleware 中 store 的 dispatch 通过匿名函数的方式和最终compose 结束后的新 dispatch 保持一致，所以，在 middleware 中调用 store.dispatch() 和在其他任何地方调用的效果一样。而在 middleware 中调用 next()，效果是进入下一个 middleware，下图就是redux middleware最著名的洋葱模型图。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://sslstatic.ktanx.com/images/release/201811/IArjf9kjKecPhnFF.png" alt="IArjf9kjKecPhnFF.png" title>                </div>                <div class="image-caption">IArjf9kjKecPhnFF.png</div>            </figure></p><h2 id="4-combineReducer"><a href="#4-combineReducer" class="headerlink" title="4.combineReducer"></a>4.combineReducer</h2><p>如果一个项目过大，通常按模块来写reducer，但是redux create store只接受一个reducer参数，所以需要合并reducer。这里就用到了redux提供的<code>combineReducer</code>辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">combineReducers(&#123;</span><br><span class="line">      layout,</span><br><span class="line">      home,</span><br><span class="line">      ...asyncReducers</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>这个函数用起来很简单，就是传入一个对象，key是模块reducer对应的名字， 值是对应reducer。值是一个function，相当于是一个新的reducer，源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">var</span> finalReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = reducerKeys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        warning(<span class="string">`No reducer provided for key "<span class="subst">$&#123;key&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> unexpectedKeyCache = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> sanityError</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    assertReducerSanity(finalReducers)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    sanityError = e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sanityError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> sanityError</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)</span><br><span class="line">      <span class="keyword">if</span> (warningMessage) &#123;</span><br><span class="line">        warning(warningMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">var</span> reducer = finalReducers[key]</span><br><span class="line">      <span class="keyword">var</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码不是很多，除去一些验证代码，剩下的就是说：return一个function，暂时称呼他combination，就相当于是与一个总的reducer，每次action都会走到combination中，combination会遍历输入的reducer，将action放到每个reducer中执行一下，计算出返回结果就是nextState，nextState于previousState如果!==说明改变了，返回nextState，否则返回执行之前的state。</p><p>这也解释了不同模块actionType如果相同的话，两个模块的reducer都会走一遍的问题，在actionType名称前面加上模块前缀即可解决问题。</p><h2 id="5-Provider与Connect"><a href="#5-Provider与Connect" class="headerlink" title="5. Provider与Connect"></a>5. Provider与Connect</h2><p>Provider与Connet组件都是React-Redux提供的核心组件，两者看起来功能一样，都是帮助容器组件获取store中的数据，但是原理与功能却不同。</p><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider组件在所有组件的最外层，其接受store作为参数，将store里的state使用context属性向下传递。部分源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> getChildContext() &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line"> <span class="keyword">super</span>(props, context)</span><br><span class="line"> <span class="keyword">this</span>.store = props.store</span><br><span class="line"> &#125;</span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props</span><br><span class="line"> <span class="keyword">return</span> Children.only(children)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用context这个属性，Provider所有子组件均可以拿到这个属性。</p><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>connect实现的功能是将需要关联store的组件和store的dispatch等数据混合到一块，这块就是一个高阶组件典型的应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">if</span> (withRef) &#123;</span><br><span class="line"> <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent, &#123;</span><br><span class="line"> ...this.mergedProps,</span><br><span class="line"> ref: <span class="string">'wrappedInstance'</span></span><br><span class="line"> &#125;)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent,</span><br><span class="line"> <span class="keyword">this</span>.mergedProps</span><br><span class="line"> )</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.renderedElement</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">return</span> hoistStatcis(Connect, WrappedComponent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是先从他的四个参数说起：</p><h4 id="1-mapStateToProps"><a href="#1-mapStateToProps" class="headerlink" title="1.mapStateToProps"></a>1.mapStateToProps</h4><p>connect 的第一个参数定义了需要从 Redux 状态树中提取哪些部分当作 props 传给当前组件。一般来说，这也是使用 connect 时经常传入的参数。事实上，如果不传入这个参数，React 组件将永远不会和 Redux 的状态树产生任何关系。具体在源代码中的表现为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> shouldSubscribe = <span class="built_in">Boolean</span>(mapStateToProps)</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> trySubscribe() &#123;</span><br><span class="line"> <span class="keyword">if</span> (shouldSubscribe &amp;&amp; !<span class="keyword">this</span>.unsubscribe) &#123;</span><br><span class="line"> <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>))</span><br><span class="line"> <span class="keyword">this</span>.handleChange()</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p><p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p><p>这块的源码相对较简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapState = mapStateToProps || defaultMapStateToProps </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line">    computeStateProps(store, props) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.finalMapStateToProps) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.configureFinalMapState(store, props)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> state = store.getState()</span><br><span class="line">        <span class="keyword">const</span> stateProps = <span class="keyword">this</span>.doStatePropsDependOnOwnProps ?</span><br><span class="line">          <span class="keyword">this</span>.finalMapStateToProps(state, props) :</span><br><span class="line">          <span class="keyword">this</span>.finalMapStateToProps(state)</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          checkStateShape(stateProps, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stateProps</span><br><span class="line">      &#125;</span><br><span class="line">      configureFinalMapState(store, props) &#123;</span><br><span class="line">        <span class="keyword">const</span> mappedState = mapState(store.getState(), props)</span><br><span class="line">        <span class="keyword">const</span> isFactory = <span class="keyword">typeof</span> mappedState === <span class="string">'function'</span></span><br><span class="line">        <span class="keyword">this</span>.finalMapStateToProps = isFactory ? mappedState : mapState</span><br><span class="line">        <span class="keyword">this</span>.doStatePropsDependOnOwnProps = <span class="keyword">this</span>.finalMapStateToProps.length !== <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.computeStateProps(store, props)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          checkStateShape(mappedState, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mappedState</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块原理很简单，进行一些参数校验，判断第一个参数mapStateToProps返回值是否为function，如果是递归调用，不是的话算出返回值。如果没传这个参数，默认给{}。</p><blockquote><p>可能会疑惑为什么传给 connect 的第一个参数本身是一个函数，react-redux 还允许这个函数的返回值也是一个函数呢？简单地说，这样设计可以允许在 connect 的第一个参数里利用函数闭包进行一些复杂计算的缓存，从而实现效率优化的目的</p></blockquote><p>当使用的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    home: state.home,</span><br><span class="line">    layout: state.layout</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染</p><h4 id="2-mapDispatchToProps"><a href="#2-mapDispatchToProps" class="headerlink" title="2.mapDispatchToProps"></a>2.mapDispatchToProps</h4><p>人如其名，它接受 store 的 dispatch 作为第一个参数，同时接受 this.props 作为可选的第二个参数。利用这个方法，可以在 connect 中方便地将 actionCreator 与 dispatch 绑定在一起（利用 bindActionCreators 方法），最终绑定好的方法也会作为 props 传给当前组件。这块的源码与mapStateToProps一样，就不贴了。</p><p>bindActionCreator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-mergeProps"><a href="#3-mergeProps" class="headerlink" title="3.mergeProps"></a>3.mergeProps</h4><p>前两个参数返回的对象，都要跟组件自身的props merge一下，形成一个新的对象赋值给对应组件，可以在这一步做一些处理，这个参数就是干这个的，该参数签名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mergeProps(stateProps, dispatchProps, ownProps): props</span><br></pre></td></tr></table></figure><p>默认情况如果没传该参数，返回<code>Object.assign(ownProps, stateProps, dispatchProps)</code>。</p><h4 id="4-options"><a href="#4-options" class="headerlink" title="4.options"></a>4.options</h4><p>如果指定这个参数，可以定制 connector 的行为。</p><ul><li>[<code>pure = true</code>] <em>(Boolean)</em>: 如果为 true，connector 将执行 <code>shouldComponentUpdate</code> 并且浅对比 <code>mergeProps</code> 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。*默认值为 true。*</li><li>[<code>withRef = false</code>] <em>(Boolean)</em>: 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 <code>getWrappedInstance()</code> 方法获得。*默认值为 false。*</li></ul><p>这个connect组件还干了一件事，状态缓存判断。当store变了的时候，前后状态判断，如果状态不等，更新组件，并且完成事件分发。</p><h2 id="6-Redux流程梳理"><a href="#6-Redux流程梳理" class="headerlink" title="6. Redux流程梳理"></a>6. Redux流程梳理</h2><p>上面讲了大量的函数源码，这么些函数之间的关系：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://sslstatic.ktanx.com/images/release/201811/4g40yEqEfjeRqxs6.png" alt="4g40yEqEfjeRqxs6.png" title>                </div>                <div class="image-caption">4g40yEqEfjeRqxs6.png</div>            </figure>初始化阶段：</p><ol><li>createStore创建一个store对象</li><li>将store对象通过参数给Provider组件</li><li>Provider组件将store通过context向子组件传递</li><li>Connect组件通过context获取到store，存入自己的state</li><li>componentDidMount里面订阅store.subscribe事件</li></ol><p>更新数据阶段：</p><ol><li>用户事件触发</li><li>actionCreator生成action交给dispatch</li><li>实际上交给了封装后的中间层（compose(applyMiddleware(…))）</li><li>请求依次通过每个中间件，中间件通过next进行下一步</li><li>最后一个中间件将action交给store.dispatch</li><li>dispatch内部将action交给reducer执行</li><li>combineReducer将每个子reducer执行一遍算出新的state</li><li>dispatch内部调用所有订阅事件</li><li>Connect组件handleChange事件触发判断新state和旧state是否===</li><li>并且判断新的state是否与mapStateToProps shallowEqual</li><li>不等则setState触发更新</li></ol><h2 id="7-Redux设计技巧"><a href="#7-Redux设计技巧" class="headerlink" title="7.Redux设计技巧"></a>7.Redux设计技巧</h2><ol><li><p>匿名函数&amp;&amp;闭包使用</p><p>redux核心函数大量使用了匿名函数和闭包来实现数据共享和状态同步。</p></li><li><p>函数柯里化使用</p><p>使用函数柯里化s实现参数复用，本质上是降低通用性，提高适用性。</p></li><li><p>核心状态读取是拷贝而不是地址</p><p>对于state这种核心状态使用getState()计算出新的state，而不是直接返回一个state对象。</p></li><li><p>观察者订阅者是核心实现</p><p>使用观察者订阅者模式实现数据响应。</p></li><li><p>context这个api的使用</p><p>平时开发不常接触的api实现Provider与Connect通信。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redux使用中的几个点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redux三大设计原则&lt;/li&gt;
&lt;li&gt;Create Store&lt;/li&gt;
&lt;li&gt;Redux middleware&lt;/li&gt;
&lt;li&gt;combineReducer&lt;/li&gt;
&lt;li&gt;Provider与Connect&lt;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入了解useMemo和useCallback</title>
    <link href="https://summxu.github.io/2021/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3useMemo%E5%92%8CuseCallback/"/>
    <id>https://summxu.github.io/2021/深入了解useMemo和useCallback/</id>
    <published>2021-10-31T01:06:38.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<p>从 <code>useMemo</code> 开始。<code>useMemo</code> 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。</p><p>React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“re-render”。基于当前应用程序状态，每次重新呈现都是应用程序UI在给定时刻应该是什么样子的快照。可以把它想象成一堆照片，每一张照片都记录了给定每个状态变量的特定值时事物的样子。</p><p>每次“re-render”都会根据当前状态在脑海中生成 DOM 应该是什么样子的图像。但实际上它是一堆JS对象，被称为“<strong>virtual DOM</strong>”。</p><p>不直接告诉 React 需要更改哪些 DOM 节点。相反，根据当前状态告诉React UI应该是什么样子。通过重新渲染，React 创建一个新的快照，它可以通过比较快照找出需要更改的内容，就像玩“寻找差异”游戏一样。</p><p>React 在开箱即用时进行了大量优化，所以通常情况下，重新渲染不是什么大问题。但是，在某些情况下，创建这些快照确实需要一些时间。这可能会导致性能问题，比如 UI 在用户执行操作后更新不够快。</p><p>而 <code>useMemo</code> 和 <code>useCallback</code> 是用来帮助优化重渲染的工具。他们通过两种方式做到这一点：</p><ol><li>减少在给定渲染中需要完成的工作量。</li><li>减少组件需要重新呈现的次数。</li></ol><p>让通过下面的栗子来理解它们吧。</p><h2 id="2-示例1：大量的计算"><a href="#2-示例1：大量的计算" class="headerlink" title="2. 示例1：大量的计算"></a>2. 示例1：大量的计算</h2><p>假设正在构建一个工具来帮助用户查找 0 到 <code>selectedNum</code> 之间的所有素数，其中 <code>selectedNum</code> 是用户提供的值。**质数是只能被1和自身整除的数，比如17。**下面是一个可能的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存储用户所选号码的状态。</span></span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算从 0 到用户选择的数字 selectedNum 之间的所有素数</span></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line"></span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:&#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;&#123;allPrimes.join(', ')&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定数字是否是素数的 Helper 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>有一个状态，一个叫做 <code>selectedNum</code> 的数字。使用 <code>for</code> 循环，手动计算 0 到 <code>selectedNum</code> 之间的所有素数。呈现一个受控制的数字输入，因此用户可以更改 <code>selectedNum</code> 。向用户显示计算的所有质数。</p><p>这段代码需要大量的计算。如果用户选择一个较大的 <code>selectedNum</code>，将需要遍历成千上万个数字，检查是否每个数字都是素数。而且，虽然有比我上面使用的更有效的质数检查算法，但它总是需要大量的计算。</p><p>有时确实需要执行这个计算，比如当用户选择一个新的 <code>selectedNum</code> 时。但是可能会遇到一些性能问题，如果在不需要做的时候无偿地做这项工作。</p><p>例如，让假设的例子还包含一个数字时钟:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// time 是一个每秒改变一次的状态变量，因此它总是与当前时间同步。</span></span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算所有质数（与前面的示例相同）</span></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">        &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label htmlFor="num"&gt;Your number:&lt;/</span>label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = React.useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  </span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearInterval(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>的应用程序现在有两个状态，<code>selectedNum</code> 和 <code>time</code>。时间变量每秒更新一次，以反映当前时间，该值用于呈现右上角的数字时钟。</p><p>问题在于：<strong>每当这些状态变量发生变化时，就会重新运行那些昂贵的质数计算。因为时间每秒改变一次，这意味着不断地重新生成质数列表，即使用户选择的数字没有改变！！！</strong></p><p>在 JavaScript 中，只有一个主线程，通过一遍又一遍地运行这段代码让它非常繁忙，每一秒。这意味着当用户尝试做其他事情时，应用程序可能会感到迟缓，特别是在低端设备上。</p><p>但如果可以“跳过”这些计算呢？如果已经有了一个给定数字的质数列表，为什么不重用这个值而不是每次都从头计算呢？这正是 <code>useMemo</code> 允许做的。它看起来是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allPrimes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      result.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;, [selectedNum]);</span><br></pre></td></tr></table></figure><p><code>useMemo</code> 有两个参数：</p><ol><li>要执行的工作块，封装在函数中</li><li>依赖项列表</li></ol><p>在挂载期间，当这个组件第一次呈现时，React 将调用这个函数来运行所有的逻辑，计算所有的质数。无论从这个函数返回什么，都被赋值给 <code>allPrimes</code> 变量。</p><p>然而，对于每一个后续渲染，React 都要做出选择。</p><ol><li>再次调用函数，重新计算值</li><li>重用它上次执行此工作时已经拥有的数据。</li></ol><p>为了做出选择，React 查看提供的依赖项列表。对于之前的渲染有任何改变吗？如果是，React 将重新运行提供的函数，以计算一个新的值。否则，它将跳过所有这些工作并重用之前计算的值。</p><p><code>useMemo</code> 本质上类似于缓存，依赖项是缓存失效策略。在本例中，实际上是在说“只有当 <code>selectedNum</code> 发生变化时才重新计算质数列表”。当组件由于其他原因重新呈现时（例如。当时间状态变量发生变化时），<code>useMemo</code> 忽略函数并传递缓存的值。</p><p>这通常被称为记忆，这就是为什么这个钩子被称为 <code>useMemo</code>。下面是这个解决方案的实时版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> allPrimes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">        result.push(counter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;, [selectedNum]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">        &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label htmlFor="num"&gt;Your number:&lt;/</span>label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = React.useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearInterval(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>useMemo</code> 钩子确实可以帮助避免这里不必要的计算。但它真的是这里的最佳解决方案吗？通常，可以通过重组应用程序中的内容来避免对 <code>useMemo</code> 的需求。可以这样做：</p><ol><li><code>PrimeCalculator.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PrimeCalculator;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Clock.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">      &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useTime() &#123;</span></span><br><span class="line"><span class="regexp">  const [time, setTime] = React.useState(new Date());</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const intervalId = window.setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTime(new Date());</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    return () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      window.clearInterval(intervalId);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  return time;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Clock;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">'./Clock'</span>;</span><br><span class="line"><span class="keyword">import</span> PrimeCalculator <span class="keyword">from</span> <span class="string">'./PrimeCalculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;PrimeCalculator /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>我提取了两个新组件，<code>Clock</code> 和 <code>PrimeCalculator</code>。通过从 <code>App</code> 分支，这两个组件各自管理自己的状态。一个组件中的重新渲染不会影响另一个组件。</p><p>或许你听到很多关于提升状态的说法，但有时，更好的方法是将状态向下推。每个组件应该有一个单独的职责，在上面的例子中，<code>App</code> 正在做两件完全不相关的事情。</p><p>现在，这并不总是一个选择。在一个大型的现实应用中，有许多状态需要向上提升，而不能向下推。对于这种情况，我还有另一个妙计。让看一个例子。假设需要将 <code>time</code> 变量提升到 <code>PrimeCalculator</code> 之上：</p><ol><li><code>PrimeCalculator.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PrimeCalculator;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Clock.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">&#123; time &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">      &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Clock;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getHours &#125; <span class="keyword">from</span> <span class="string">'date-fns'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">'./Clock'</span>;</span><br><span class="line"><span class="keyword">import</span> PrimeCalculator <span class="keyword">from</span> <span class="string">'./PrimeCalculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将的PrimeCalculator转换为一个纯组件</span></span><br><span class="line"><span class="keyword">const</span> PurePrimeCalculator = React.memo(PrimeCalculator);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据一天中的时间选择一个合适的背景色</span></span><br><span class="line">  <span class="keyword">const</span> backgroundColor = getBackgroundColorFromTime(time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; backgroundColor &#125;&#125;&gt;</span><br><span class="line">      &lt;Clock time=&#123;time&#125; /&gt;</span><br><span class="line">      &lt;PurePrimeCalculator /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const getBackgroundColorFromTime = (time) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const hours = getHours(time);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  if (hours &lt; 12) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 早晨用的淡黄色</span></span><br><span class="line"><span class="regexp">    return 'hsl(50deg 100% 90%)';</span></span><br><span class="line"><span class="regexp">  &#125; else if (hours &lt; 18) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 下午暗淡的蓝色</span></span><br><span class="line"><span class="regexp">    return 'hsl(220deg 60% 92%)'</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 夜晚的深蓝色</span></span><br><span class="line"><span class="regexp">    return 'hsl(220deg 100% 80%)';</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useTime() &#123;</span></span><br><span class="line"><span class="regexp">  const [time, setTime] = React.useState(new Date());</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const intervalId = window.setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTime(new Date());</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    return () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      window.clearInterval(intervalId);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  return time;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><code>React.memo</code> 包在组件周围，保护它免受不相关的更新。<code>PurePrimeCalculator</code> 只有在接收到新数据或内部状态发生变化时才会重新呈现。这就是所谓的纯组件。本质上，告诉 React 这个组件将总是在相同的输入条件下产生相同的输出，可以跳过没有任何改变的重新呈现。</p><p>在上面的例子中，我应用了 <code>React.memo</code> 到导入的 <code>PrimeCalculator</code> 组件。事实上,我选择了这样的结构，以便所有内容都在同一个文件中可见，以便更容易理解。在实践中，使用 <code>React.memo</code> 组件导出，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrimeCalculator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 这里的组件内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(PrimeCalculator);</span><br></pre></td></tr></table></figure><p>的 <code>PrimeCalculator</code> 组件现在将始终是纯的，当要使用它时，不需要对它进行修补。</p><p>这里有一个视角转换：之前，在记忆一个特定计算的结果，计算质数。然而，在本例中，我记住了整个组件。无论哪种方式，只有当用户选择一个新的 <code>selectedNum</code> 时，昂贵的计算才会重新运行。但优化的是父组件，而不是特定的慢代码行。</p><p>我并不是说一种方法比另一种更好；每种工具在工具箱中都有自己的位置。但在这个特定的情况下，我更喜欢这种方法。现在，如果您曾经尝试在现实世界的设置中使用纯组件，您可能会注意到一些特殊的东西：纯组件经常重新渲染相当多，即使看起来没有任何变化！这很好地将引入了 <code>useMemo</code> 解决的第二个问题。</p><h2 id="3-示例2：保留引用"><a href="#3-示例2：保留引用" class="headerlink" title="3. 示例2：保留引用"></a>3. 示例2：保留引用</h2><p>在下面的示例中，我创建了一个 <code>Boxes</code> 组件。它展示了一组彩色的盒子，用于某种装饰目的。我还有一个不相关的状态：用户名。</p><ol><li><code>Boxes.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Boxes</span>(<span class="params">&#123; boxes &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"boxes-wrapper"</span>&gt;</span><br><span class="line">      &#123;boxes.map(<span class="function">(<span class="params">boxStyles, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;div</span><br><span class="line">          key=&#123;index&#125;</span><br><span class="line">          className=<span class="string">"box"</span></span><br><span class="line">          style=&#123;boxStyles&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default React.memo(Boxes);</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Boxes <span class="keyword">from</span> <span class="string">'./Boxes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = React.useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [boxWidth, setBoxWidth] = React.useState(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> id = React.useId();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 尝试改变这些值</span></span><br><span class="line">  <span class="keyword">const</span> boxes = [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Boxes boxes=&#123;boxes&#125; /&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;label htmlFor=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-name`</span>&#125;&gt;</span><br><span class="line">          Name:</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          id=&#123;`$&#123;id&#125;-name`&#125;</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          value=&#123;name&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(event) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setName(event.target.value);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;label htmlFor=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-box-width`</span>&#125;&gt;</span><br><span class="line">          First box width:</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          id=&#123;`$&#123;id&#125;-box-width`&#125;</span></span><br><span class="line"><span class="regexp">          type="range"</span></span><br><span class="line"><span class="regexp">          min=&#123;1&#125;</span></span><br><span class="line"><span class="regexp">          max=&#123;5&#125;</span></span><br><span class="line"><span class="regexp">          step=&#123;0.01&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;boxWidth&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(event) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setBoxWidth(Number(event.target.value));</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>由于在 <code>boxes.js</code> 中使用了<code>React.memo()</code> 封装默认导出，<code>Boxes</code> 是一个纯组件。这意味着它应该只在它的<code>props</code>改变时重新渲染。然而，每当用户更改其名称时，<code>Boxes</code> 也会重新呈现。</p><p>为什么的 <code>React.memo()</code> 没有保护？盒子组件只有1个<code>prop</code>，盒子，它看起来好像给它在每次渲染完全相同的数据。总是一样的东西：一个红盒子，一个紫色的宽盒子，一个黄色的盒子。确实有一个影响<code>boxes</code> 数组的 <code>boxWidth</code> 状态变量，但没有更改它！</p><p>问题在于：每次 React 重新渲染时，都会生成一个全新的数组。它们在值上是相等的，但在参照物上是不同的。我想如果先不谈 React，只谈普通的 JavaScript，会很有帮助。让来看一个类似的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> firstResult = getNumbers();</span><br><span class="line"><span class="keyword">const</span> secondResult = getNumbers();</span><br><span class="line"><span class="built_in">console</span>.log(firstResult === secondResult);</span><br></pre></td></tr></table></figure><p>你怎么看？<code>firstResult</code> 是否等于 <code>secondResult</code>？从某种意义上说，的确如此。两个变量都具有相同的结构<code>[1,2,3]</code>。但这不是 <code>===</code> 运算符实际检查的内容。相反，<code>===</code> 检查两个表达式是否相同。已经创建了两个不同的数组。它们可能包含相同的内容，但它们不是同一个数组。</p><p>每次调用 <code>getNumbers</code> 函数时，都会创建一个全新的数组，它是保存在计算机内存中的一个不同的东西。如果多次调用它，将在内存中存储该数组的多个副本。注意，简单的数据类型——比如<strong>字符串</strong>、<strong>数字</strong>和<strong>布尔值</strong>——可以按值进行比较。但是当涉及到<strong>数组</strong>和<strong>对象</strong>时，它们只能通过<strong>引用</strong>进行比较。</p><p>让回到 React：的 <code>Boxes</code> React组件也是一个 JavaScript 函数。当渲染它时，调用那个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次渲染这个组件时，调用这个函数…</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最后创造了一个全新的数组</span></span><br><span class="line">  <span class="keyword">const</span> boxes = [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// .然后将其作为 prop 传递给该组件!</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Boxes boxes=&#123;boxes&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当名称状态改变时，的 <code>App</code> 组件将重新呈现，这将重新运行所有的代码。构造一个全新的 <code>boxes</code> 数组，并将其传递给的 <code>Boxes</code> 组件。从而导致盒子重新渲染，因为给了它一个全新的数组。盒子数组的结构在渲染之间没有改变，但这无关紧要。React 所知道的是，箱子 <code>prop</code> 已经收到了一个新创建的，从未见过的数组。要解决这个问题，可以使用 <code>useMemo</code> hook：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boxes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;, [boxWidth]);</span><br></pre></td></tr></table></figure><p>与之前看到的质数例子不同，这里不担心计算成本很高的计算。的唯一目标是<strong>保留对特定数组的引用</strong>。将 <code>boxWidth</code> 列为一个依赖项，因为确实希望在用户调整红色框的宽度时重新呈现 <code>Boxes</code> 组件。然而，在 <code>useMemo</code> 中，重用了之前创建的 <code>boxes</code> 数组。</p><p>通过在多个渲染中保留相同的引用，允许纯组件按希望的方式工作，忽略不影响 UI 的渲染。</p><h2 id="4-useCallback"><a href="#4-useCallback" class="headerlink" title="4. useCallback"></a>4. useCallback</h2><p>前面了解了 <code>useMemo</code>。那 <code>useCallback</code> 呢？这是一个简短的版本：<strong>这是完全相同的事情，但用于函数而不是数组/对象</strong>。与数组和对象类似，函数是根据引用比较的，而不是根据值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functionOne = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> functionTwo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(functionOne === functionTwo); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这意味着，如果在组件中定义一个函数，它将在每次渲染时重新生成，每次生成一个相同但唯一的函数。让看一个例子：</p><ol><li><code>MegaBoost.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MegaBoost</span>(<span class="params">&#123; handleClick &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Render MegaBoost'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">      className=<span class="string">"mega-boost-button"</span></span><br><span class="line">      onClick=&#123;handleClick&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      MEGA BOOST!</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default React.memo(MegaBoost);</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>App.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MegaBoost <span class="keyword">from</span> <span class="string">'./MegaBoost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleMegaBoost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          setCount(count + <span class="number">1</span>)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Click me!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MegaBoost handleClick=&#123;handleMegaBoost&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>这个栗子描述了一个典型的计数器应用程序，但有一个特殊的“Mega Boost”按钮。这个按钮大大增加了计数，以防你很匆忙，不想多次点击标准按钮。</p><p>多亏了 <code>React.memo</code>, <code>MegaBoost</code> 组件是一个纯组件。它不依赖于计数，但每当计数改变时它就会重新呈现！就像看到的盒子数组，这里的问题是在每个渲染上生成一个全新的函数。如果渲染 3 次，将创建 3 个单独的 <code>handleMegaBoost</code> 函数，突破 <code>React.memo</code>的保护。利用对 <code>useMemo</code> 的了解，可以像这样解决问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleMegaBoost = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>返回的不是一个数组，而是一个函数。然后将此函数存储在 <code>handleMegaBoost</code> 变量中。这很有效，但还有更好的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleMegaBoost = React.useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><code>useCallback</code> 的作用与 <code>useMemo</code> 相同，但它是专门为函数构建的。直接给它一个函数，它记住那个函数，在渲染之间进行线程处理。换句话说，这两个表达有相同的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.useCallback(<span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;&#125;, []);</span><br><span class="line"><span class="comment">// 在功能上等价于</span></span><br><span class="line">React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;&#125;, []);</span><br></pre></td></tr></table></figure><p><code>useCallback</code> 是语法糖。它的存在纯粹是为了让在记忆回调函数时更加方便。</p><h2 id="5-什么时候使用这些-hook"><a href="#5-什么时候使用这些-hook" class="headerlink" title="5. 什么时候使用这些 hook"></a>5. 什么时候使用这些 hook</h2><p>好了，已经看到了 <code>useMemo</code> 和 <code>useCallback</code> 如何允许跨多个渲染线程引用重用复杂的计算或避免破坏纯组件。问题是：应该多经常使用它？</p><p>在我个人看来，将每个对象/数组/函数包装在这些钩子中是浪费时间。在大多数情况下，好处是可以忽略不计的；React 是高度优化的，重新渲染通常不像通常认为的那样缓慢或昂贵！</p><p>使用这些钩子的最佳方式是响应问题。如果你注意到你的应用程序变得有点迟缓，你可以使用 <code>React Profiler</code> 来查找缓慢的渲染。在某些情况下，可以通过重构应用程序来提高性能。在其他情况下，<code>useMemo</code> 和<code>useCallback</code> 可以帮助加快速度。</p><h3 id="5-1-用于自定义-hook-内部"><a href="#5-1-用于自定义-hook-内部" class="headerlink" title="5.1 用于自定义 hook 内部"></a>5.1 用于自定义 hook 内部</h3><p>例如下面这个自定义 hook <code>useToggle</code>，它的工作方式几乎和 <code>useState</code> 完全一样，但只能在 <code>true</code> 和 <code>false</code> 之间切换状态变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isDarkMode, toggleDarkMode] = useToggle(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;toggleDarkMode&#125;&gt;</span><br><span class="line">      Toggle color theme</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>下面是如何定义这个自定义 hook 的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useToggle</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(initialValue);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> toggle = React.useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(<span class="function"><span class="params">v</span> =&gt;</span> !v);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [value, toggle];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>toggle</code> 函数是用 <code>useCallback</code> 记忆的。当我构建这样的自定义可重用钩子时，我希望使它们尽可能高效，因为我不知道将来会在哪里使用它们。在95%的情况下，这可能是多余的，但如果我使用这个钩子30或40次，这很有可能有助于提高应用程序的性能。</p><h3 id="5-2-在-context-提供者"><a href="#5-2-在-context-提供者" class="headerlink" title="5.2 在 context 提供者"></a>5.2 在 context 提供者</h3><p>当在具有 <code>context</code> 的应用程序之间共享数据时，通常会传递一个大对象作为 <code>value</code> 属性。记住这个对象通常是个好主意：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AuthContext = React.createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AuthProvider</span>(<span class="params">&#123; user, status, forgotPwLink, children &#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedValue = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user,</span><br><span class="line">      status,</span><br><span class="line">      forgotPwLink,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [user, status, forgotPwLink]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider value=&#123;memoizedValue&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/AuthContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>为什么这是有益的？可能有几十个纯组件使用这个上下文。如果没有 <code>useMemo</code>，如果 <code>AuthProvider</code> 的父组件碰巧重新渲染，那么所有这些组件都将被迫重新渲染。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从 &lt;code&gt;useMemo&lt;/code&gt; 开始。&lt;code&gt;useMemo&lt;/code&gt; 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。&lt;/p&gt;
&lt;p&gt;React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue的响应式原理</title>
    <link href="https://summxu.github.io/2021/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://summxu.github.io/2021/Vue的响应式原理/</id>
    <published>2021-05-07T01:07:32.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue2使用Object-defineProperty实现响应式"><a href="#vue2使用Object-defineProperty实现响应式" class="headerlink" title="vue2使用Object.defineProperty实现响应式"></a>vue2使用Object.defineProperty实现响应式</h2><ul><li>遍历属性，对每一个属性的值用Object.defineProperty进行getter和setter的改造；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">data, key</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get data:'</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">data, key, value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'set data:'</span>, key,<span class="string">'-'</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">    <span class="keyword">let</span> value = data[key]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>()&#123;</span><br><span class="line">        track(data, key)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">        trigger(data, key, newVal)</span><br><span class="line">        value = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'object'</span>)&#123;</span><br><span class="line">      observe(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'win'</span>,</span><br><span class="line">  family: [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(obj)</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'ten'</span></span><br><span class="line">obj.family[<span class="number">3</span>] = <span class="number">6</span> <span class="comment">//不是响应式，没有被Object.defineProperty包装一下</span></span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">//不是响应式，没有被Object.defineProperty包装一下</span></span><br><span class="line"><span class="built_in">console</span>.log(obj, <span class="string">'obj'</span>)</span><br></pre></td></tr></table></figure><p>Vue3相对于Vue2响应式原理也发生了变化，由原先的 <code>Object.defineproperty</code> 改成了使用 <code>Proxy</code> 替代。<code>Proxy</code> 相对于 <code>Object.defineproperty</code> 有以下几个优化点：</p><ul><li>对象新增属性不再需要手动 <code>$set</code> 添加响应式，<code>Proxy</code> 默认会监听动态添加属性和属性的删除等操作。</li><li>消除无法监听数组索引，length 属性等等，不再需要在数组原型对象上重写数组的方法。</li><li><code>Object.defineproperty</code> 是劫持所有对象属性的 <code>get</code>/<code>set</code> 方法,需要遍历递归去实现，<code>Proxy</code> 是代理整个对象。</li><li>Vue2 只能拦截对象属性的 <code>get</code> 和 <code>set</code> 操作,而 <code>Proxy</code> 拥有 <code>13</code> 种拦截方法。</li></ul><h2 id="Vue3中的响应式原理"><a href="#Vue3中的响应式原理" class="headerlink" title="Vue3中的响应式原理"></a>Vue3中的响应式原理</h2><p>实现原理：</p><p>通过Proxy（代理）： 拦截对象中任意属性的变化，包括：属性值的读写，属性的增加，属性的删除等。</p><p>通过Reffect（反射）： 对源对象的属性进行操作</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul><li>Proxy对象对于创建一个对象的代理，也可以理解成在对象前面设了一层拦截，<strong>可以实现基本操作的拦截和一些自定义操作（比如一些赋值、属性查找、函数调用等）；</strong></li><li>用法：<code>var proxy = new Proxy(target, handler);</code><br><strong>target：</strong>目标函数（即进行改造的函数）；<br><strong>handler：</strong>一些自定义操作（比如vue中getter和setter的操作）；</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li>Reflect是es6为操作对象而提供的新API，设计它的目的有：<br>① 把Object对象上一些明显属于语言内部的方法放到Reflect对象身上，比如Object.defineProperty；<br>② 修改了某些object方法返回的结果；<br>③ 让Object操作都变成函数行为；<br>④ Reflect对象上的方法和Proxy对象上的方法一一对应，这样就可以让Proxy对象方便地调用对应的Reflect方法；</li><li><code>Reflect.get(target, propertyKey, receiver)</code>：<strong>等价于<code>target[propertyKey]</code>，</strong>Reflect.get方法查找并返回target对象的propertyKey属性，如果没有该属性，则返回undefined。</li><li><code>Reflect.set(target, propertyKey, value, receiver)</code>：<strong>等价于<code>target[propertyKey] = value</code>，</strong>Reflect.set方法设置target对象的propertyKey属性等于value。</li></ul><h3 id="Proxy和Reflect的使用"><a href="#Proxy和Reflect的使用" class="headerlink" title="Proxy和Reflect的使用"></a>Proxy和Reflect的使用</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'win'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get--'</span>, key)</span><br><span class="line">    <span class="keyword">return</span> Reflect.get(...arguments)  </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set--'</span>, key, <span class="string">'='</span>, value)</span><br><span class="line">    <span class="keyword">return</span> Reflect.set(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> Proxy(obj, handler)</span><br><span class="line">data.name = <span class="string">'ten'</span></span><br><span class="line"><span class="built_in">console</span>.log(data.name,<span class="string">'data.name22'</span>)</span><br></pre></td></tr></table></figure><h2 id="使用Proxy和Reflect完成响应式"><a href="#使用Proxy和Reflect完成响应式" class="headerlink" title="使用Proxy和Reflect完成响应式"></a>使用Proxy和Reflect完成响应式</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get--'</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key, value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'set--'</span>, key, <span class="string">'='</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key, receiver)&#123;</span><br><span class="line">      track(target, key)</span><br><span class="line">      <span class="keyword">const</span> value = Reflect.get(...arguments)</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reactive(value)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, val, receiver)&#123;</span><br><span class="line">      trigger(target, key, val)</span><br><span class="line">      <span class="keyword">return</span> Reflect.set(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'win'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = reactive(obj)</span><br><span class="line"></span><br><span class="line">data.list = [<span class="number">5</span>] <span class="comment">//响应式  这两句话是执行Reflect.set()</span></span><br><span class="line">data.age = <span class="number">18</span> <span class="comment">//响应式</span></span><br><span class="line"><span class="built_in">console</span>.log(data, <span class="string">'data111'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue2使用Object-defineProperty实现响应式&quot;&gt;&lt;a href=&quot;#vue2使用Object-defineProperty实现响应式&quot; class=&quot;headerlink&quot; title=&quot;vue2使用Object.defineProperty实
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ReactNative踩坑记</title>
    <link href="https://summxu.github.io/2020/ReactNative%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://summxu.github.io/2020/ReactNative踩坑记/</id>
    <published>2020-07-21T04:16:24.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近在使用react-native的时候遇到了很多坑-这里记录一下"><a href="#最近在使用react-native的时候遇到了很多坑-这里记录一下" class="headerlink" title="最近在使用react-native的时候遇到了很多坑,这里记录一下"></a>最近在使用react-native的时候遇到了很多坑,这里记录一下</h2><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>react-native 虽然支持flex布局，但是所有的样式均是css样式的一个很小的集合，尤其是在安卓机下问题尤为凸显：</p><ol><li><p>View内部的元素千万不要超出父级的范围，iso上问题倒是不大，安卓上就什么超出的都看不到了</p></li><li><p>lineHeight 可以用，不过千万不要写成小数，否则安卓上会直接崩溃</p></li><li><p>rn的样式不存在继承的情况，所以基本上每个节点都要写style，真的是体力活</p></li><li><p>如果Text的父级元素设置了背景颜色，那么ios下Text的背景颜色也是父级的背景颜色，要么自己写个Text重置下样式，要么就遇到了再改</p></li><li><p>react-native的字号是没有设置单位的，所以会随着系统设置的字体大小而变化，我也不知道这是不是坑，不过貌似有的app也没有管这个，如果硬要去设置Text的文字不随系统改变，安卓是可以统一设置的，ios上Text设置allowFontScaling ={false}就可以解决</p></li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>react-native 在发生js异常的时候，debug的时候会直接红屏幕，但是再release的时候直接会崩溃退出，解决办法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ErrorUtils <span class="keyword">from</span> <span class="string">"ErrorUtils"</span> &lt;br&gt;<span class="comment">//这里应该做个判断，如果不是debug的才做这样的异常全局处理</span></span><br><span class="line">ErrorUtils.setGlobalHandler(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;&lt;br&gt;　　<span class="comment">//发生异常的处理方法,当然如果是打包好的话可能你找都找不到是哪段代码出问题了</span></span><br><span class="line">　　Alert.alert(<span class="string">"异常"</span>,<span class="built_in">JSON</span>.stringify(e))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>react-native虽然自带有fetch，不过在使用的时候发现了一个问题，如果需要获取http的header头的时候问题就来了，可能得到的是一些千奇百怪的样式，这并不是react-native的错，而是第三方的 whatwg-fetch 留下的坑，当然也有人再github上跟react-native反映过这个问题，不过得到的解决方案都很坑，唯有一个办法，就是拷贝自己修改，修改如下:</p><ol><li><p>注释该注释的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">　　 <span class="comment">//注释这里，不然总是用的是全局的fetch</span></span><br><span class="line">    <span class="comment">// if (self.fetch) &#123;</span></span><br><span class="line">    <span class="comment">//     return</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>修改该修改的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHeaders</span>(<span class="params">rawHeaders</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> headers = <span class="keyword">new</span> Headers()&lt;br&gt;　　　　　<span class="comment">//把\t\n改成\t，因为一般header都是用\n来分割的</span></span><br><span class="line">    rawHeaders.split(<span class="string">'\n'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//rawHeaders.split('\t\n').forEach(function(line) &#123;</span></span><br><span class="line">            <span class="keyword">var</span> parts = line.split(<span class="string">':'</span>)</span><br><span class="line">            <span class="keyword">var</span> key = parts.shift().trim()</span><br><span class="line">            <span class="keyword">if</span> (key) &#123;</span><br><span class="line">                <span class="keyword">var</span> value = parts.join(<span class="string">':'</span>).trim()</span><br><span class="line">                headers.append(key, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接import你改好的文件，fetch就可以用了</p></li></ol><h2 id="Modal"><a href="#Modal" class="headerlink" title="Modal"></a>Modal</h2><p>Mode控件在使用的时候要注意了，因为这个是rn提供的，并且也写的很清楚是最高层级的一个弹出层，所以你想要又打开Model又要跳转基本是无望的了，所以建议不要使用这个，最好是使用第三方的控件，我们用的是 react-native-modalbox + 高阶控件 实现的全遮盖的弹出层</p><h2 id="点击屏幕其他位置关闭的菜单"><a href="#点击屏幕其他位置关闭的菜单" class="headerlink" title="点击屏幕其他位置关闭的菜单"></a>点击屏幕其他位置关闭的菜单</h2><p>这类菜单有个共同的特点就是点击屏幕其他地方然后菜单就关闭，我们的解决办法就是用自己写的 react-native-modalbox + 高阶控件 也就是说放在一个弹出层里面，当然可以试试把当前页面套进一个大的 TouchableWithoutFeedback 里面</p><h2 id="接口请求"><a href="#接口请求" class="headerlink" title="接口请求"></a>接口请求</h2><p>非特殊情况下都应该这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;InteractionManager&#125; <span class="keyword">from</span> <span class="string">"react-native"</span></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">  InteractionManager.runAfterInteractions(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fetch(<span class="string">"xxx.xxx.xxx"</span>,&#123;&#125;)</span><br><span class="line">    &#125;);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>官方提供的自定义隐藏键盘的方法是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Keyboard &#125; <span class="keyword">from</span> <span class="string">'react-native'</span></span><br><span class="line">Keyboard.dismiss()</span><br></pre></td></tr></table></figure><p>但是我试了很多次之后发现根本不能，而且还报错，楼主的react-native版本是0.35.0</p><p>看了官方的issue才知道这个不行，推荐下面方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dismissKeyboard <span class="keyword">from</span> <span class="string">'dismissKeyboard'</span>dismissKeyboard()</span><br></pre></td></tr></table></figure><p>这样就可以隐藏了，太坑了</p><p>还有个很坑的地方，官方提供的移除键盘事件的方法不可用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;　　Keyboard.addListener(<span class="string">'keyboardDidShow'</span>, <span class="keyword">this</span>.keyboardDidShow.bind(<span class="keyword">this</span>))　　Keyboard.addListener(<span class="string">'keyboardDidHide'</span>, <span class="keyword">this</span>.keyboardDidHide.bind(<span class="keyword">this</span>))&#125;componentWillUnmount () &#123;</span><br><span class="line">    Keyboard.removeAllListeners(<span class="string">'keyboardDidShow'</span>)</span><br><span class="line">    Keyboard.removeAllListeners(<span class="string">'keyboardDidHide'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的方式特么的如果操作快了，或者有时候莫名其妙的就会出错,下面的才是正确的打开方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">　　<span class="keyword">this</span>.keyboardDidShowListener = Keyboard.addListener(<span class="string">'keyboardDidShow'</span>, <span class="keyword">this</span>.keyboardDidShow.bind(<span class="keyword">this</span>))</span><br><span class="line">　　<span class="keyword">this</span>.keyboardDidHideListener = Keyboard.addListener(<span class="string">'keyboardDidHide'</span>, <span class="keyword">this</span>.keyboardDidHide.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidShowListener.remove()</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidHideListener.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>https这个问题上ios还好，安卓问题就来了，前期我们准备将ajax请求的库丢给原生安卓和ios来做我们直接调用就是了，但是后来发现问题这样那样的问题太多了，</p><p>所以在热更新服务器启动或者打包的时候就把源代码先改了在进行打包或者启动服务器</p><p>文件位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java</span><br></pre></td></tr></table></figure><p>这个文件的最后一个方法修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> OkHttpClient createClient() &#123;</span><br><span class="line">  <span class="comment">// No timeouts by default</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">  .sslSocketFactory(sslContext.getSocketFactory())</span><br><span class="line">  .hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public boolean verify(<span class="built_in">String</span> hostname, SSLSession session) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//忽略所有的认证，直接返回了true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    .connectTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .readTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .writeTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .cookieJar(<span class="keyword">new</span> ReactCookieJarContainer())</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改源代码的方式有点略坑，不过可以解决很多问题，还节约时间！！！</p><h2 id="BackAndroid"><a href="#BackAndroid" class="headerlink" title="BackAndroid"></a>BackAndroid</h2><p>安卓机有独特的点击按键返回，所以在最外层会注册一个监听方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bindHardwareBackPress()&#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">        BackAndroid.addEventListener(<span class="string">'hardwareBackPress'</span>, <span class="keyword">this</span>._onHomeBackPress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">onHomeBackPress()&#123;</span><br><span class="line">    <span class="keyword">let</span> routeList = <span class="keyword">this</span>.getRouteList();</span><br><span class="line">    <span class="keyword">if</span> (routeList.length !== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.navigator.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.handleHomeBackPress();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">handleHomeBackPress()&#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">"android"</span>) &#123;</span><br><span class="line">        ToastAndroid.show(<span class="string">"再按一次退出应用"</span>, ToastAndroid.SHORT);</span><br><span class="line">        BackAndroid.removeEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onHomeBackPress);</span><br><span class="line">        BackAndroid.addEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onExitApp);</span><br><span class="line">        <span class="keyword">this</span>.timer = TimerMixin.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            TimerMixin.clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">            BackAndroid.removeEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onExitApp);</span><br><span class="line">            BackAndroid.addEventListener(<span class="string">"hardwareBackPress"</span>, <span class="keyword">this</span>._onHomeBackPress);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exitApp()&#123;</span><br><span class="line">    BackAndroid.exitApp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是监听返回键，如果不是在最外层的路由就返回上一个,如果在最外层就直接关闭app，但是有很多这样那样的需求要去对安卓的返回键进行操作，坑就来了，你以为提供的removeEventListener方法是没问题的？no ！！！ 他会移除所有的监听，这是不是很坑！！！！</p><p>所以：<strong>在需要对安卓返回键进行特殊处理的时候记得其他地方做了监听的再重新监听一次！！！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最近在使用react-native的时候遇到了很多坑-这里记录一下&quot;&gt;&lt;a href=&quot;#最近在使用react-native的时候遇到了很多坑-这里记录一下&quot; class=&quot;headerlink&quot; title=&quot;最近在使用react-native的时候遇到了很多坑
      
    
    </summary>
    
    
    
      <category term="ReactNative" scheme="https://summxu.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存-ETag</title>
    <link href="https://summxu.github.io/2019/http-cache-etag/"/>
    <id>https://summxu.github.io/2019/http-cache-etag/</id>
    <published>2019-08-10T12:44:11.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。</p></blockquote><h2 id="ETag验证缓存的响应"><a href="#ETag验证缓存的响应" class="headerlink" title="ETag验证缓存的响应"></a>ETag验证缓存的响应</h2><p>在本地通过 express 启了一个非常简单的个服务，具体如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello http'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://127.0.0.1:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是仔细看却发现，第一次进入页面<strong><a href="http://127.0.0.1:3000/" target="_blank" rel="noopener">http://127.0.0.1:3000/</a></strong>时，Status为200而再次刷新发现Status却是304</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-e14290fe5a1aaa4b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-f19b1eb12e8d8cc4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>仔细对比发现</p><ol><li>第一次请求时候请求参数中并没有 If-None-Match 字段但是却有个Pragma；同时在请求的Response中有一个 <strong>ETag: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg”</strong>字段。</li><li>刷新页面后再次请求在请求头中却有个 *<em>If-None-Match: W/“a-QFZ79AprHeNlMfPMKXyEUV+lyOg” *</em>，If-None-Match 的值和第一次请求的ETag的值相同。</li></ol><p>经过查询才了解原理浏览器会根据HTTP请求的ETag验证请求的资源是否发生了改变，如果它未发生变化，服务器将返回“304 Not Modified”响应，并且资源从浏览器缓存中读取，这样就不必再次下载请求。</p><p>由此看来整个的过程就是下面这样：</p><ol><li>如果缓存中有ETag 令牌，客户端请求时会自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。</li><li>服务器根据当前资源核对令牌，验证是否发生变化，将验证结果通知给客户端，客户端根据结果看看是否需要从缓存中读取还是发送资源请求。</li></ol><p>补充一个很直白的 <a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">TCP协议的三次握手</a> 的理解。</p><p>为了验证查证的结果，我又添加一个请求处理。这个过程是，客户端明确返回一个ETag, 但是这里每次请求的的返回值都不相同，这里简单的使用了个<strong>etag++</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello http'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证ETag</span></span><br><span class="line"><span class="keyword">let</span> etag = <span class="number">0</span>;</span><br><span class="line">app.get(<span class="string">'/test'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  etag++;</span><br><span class="line">  res.set(<span class="string">'ETag'</span>, etag);</span><br><span class="line">  res.send(<span class="string">'ETag'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://127.0.0.1:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/8532055-71230f0ad656f455.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>查看下 /test 地址的请求结果，会发现If-None-Match 的值和 Response中的 ETag值每次都不相同，并且是 浏览器会将每次的 ETag 值都缓存起来在下次请求的时候发送给服务器。这样一来，每次服务器每次校验的值都是不相同的，所以这种就没有做缓存，因此每次请求 /test 地址都是 200 的状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在学习网站性能优化相关的内容，关于网站优化点特别多而HTTP缓存也是比较重要的一部分，于是今天就着重看下HTTP缓存相关的内容加深下对此相关知识的理解和认识。自己动手通过简单的服务，看看其中的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 
      
    
    </summary>
    
    
    
      <category term="网络" scheme="https://summxu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>fixed 定位失效 与 CSS 层叠上下文</title>
    <link href="https://summxu.github.io/2019/fixed-stacking-context/"/>
    <id>https://summxu.github.io/2019/fixed-stacking-context/</id>
    <published>2019-05-22T15:38:51.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分，position: fixed失效的问题；<br>第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。</p><h1 id="关于-position-fixed"><a href="#关于-position-fixed" class="headerlink" title="关于 position: fixed"></a>关于 position: fixed</h1><p><strong>position: fixed</strong> 在日常布局中比较常用，如移动端头部和底部导航定位、模态框、悬浮按钮等，设置了这个属性值得元素会相对于屏幕视口（viewport）进行定位，其位置在屏幕进行滚动时会保持不变，不占用文档流中的位置，而且打印时这个元素会出现在 每一页 的相同位置。设置了 <strong>position: fixed</strong> 的元素最终的位置由它的 <strong>top, right, bottom, left</strong> 来决定，这个值会创建一个新的 <strong>stacking context</strong><br>但是，有些情况下，这种定位方式会失效，使得元素相对于视窗定位的定位不符合预期（其实是 <strong>fixed</strong> 定位的参考元素变了）。当该元素的父元素中（广义，包含祖先元素）有元素的 <strong>transform</strong> 或 <strong>perspective</strong> 的值不是 <strong>none</strong>，该元素就会相对于这个父元素而不是视口进行定位。<br>具体的原因是这样：</p><blockquote><p>Specifying a value other than none for the transform property establishes a new local coordinate system at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element’s transformation matrix. Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent. From the perspective of the user, an element effectively accumulates all the transform properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a current transformation matrix for the element.</p></blockquote><p>解释一下，<strong>transform</strong> 或 perspective 的非 none 值会影响元素的包含块和层叠上下文，这些值会在应用它的元素上建立一个局部的坐标系（X轴向右水平增加; Y轴垂直向下增加），由变换矩阵（<strong>transform</strong> 的值）给出元素到该局部坐标系的映射，而且 <strong>transform</strong> 带来的局部坐标系的改变是可以累积的——也就是说，子元素会在它的父元素的坐标系内建立子元素自己的局部坐标系：<br>父元素的 <strong>transform</strong> 们一层层积累定义了子元素当前的变换矩阵（一个元素的变换矩阵是从 <strong>transform</strong> 和 <strong>transform</strong>-origin 属性中计算出来的），步骤如下：</p><ul><li>通过 <strong>transform-origin</strong> 的值对坐标原点 X 和 Y 的位置进行转换</li><li>以变换后的 X、Y 为坐标原点原点，根据 <strong>transform</strong> 的属性值进行变换</li><li>X 和 Y 根据 <strong>transform-origin</strong> 的相反值平移回去</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180102175637761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGFuZGFfbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="如图" title>                </div>                <div class="image-caption">如图</div>            </figure><p><strong>transform</strong> 会影响最终的渲染效果，但是不影响除overflow外的CSS布局，当通过 <strong>getClientRects()</strong>、<strong>getBoundingClientRect()</strong> 这些接口获取 <strong>client rectangles</strong> 时，<strong>transform</strong> 的效果也会被考虑进去。</p><p>可以应用 <strong>transform</strong> 的元素（<strong>transformable elements</strong>）有：</p><ul><li>满足CSS盒模型的块级元素或行内元素，或者它的 display 值为 table-row, table-row-group, table-header-group, table-footer-group, table-cell, table-caption 中的一个</li><li>SVG 命名空间中具有 transform, patternTransform 或 gradientTransform 属性的元素</li></ul><p>p.s. 关于上面的应用<strong>transform</strong>后元素位置的计算方式。原文如下：</p><ol><li>Start with the identity matrix.</li><li>Translate by the computed X and Y of transform-origin</li><li>Multiply by each of the transform functions in transform property from left to right</li><li>Translate by the negated computed X and Y values of transform-origin</li></ol><p>参考文档：</p><p><a href="https://www.w3.org/TR/css-transforms-1/#propdef-transform" target="_blank" rel="noopener">The transform Property - W3C Working Draft - 30 November 2017</a></p><p><a href="https://www.w3.org/TR/css-transforms-1/#transform-rendering" target="_blank" rel="noopener">The Transform Rendering Model - W3C Working Draft - 30 November 2017</a></p><h1 id="层叠上下文-Stacking-Context"><a href="#层叠上下文-Stacking-Context" class="headerlink" title="层叠上下文 Stacking Context"></a>层叠上下文 Stacking Context</h1><p>通过上文我们知道了有层叠上下文这么一个东西，层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。和BFC还有IFC这些xx context一样，创建层叠上下文也是有条件的，文档中的层叠上下文由满足以下任意一个条件的元素形成：</p><ul><li>根元素 (HTML),</li><li>z-index 值不为 auto 的 绝对/相对定位元素</li><li>position 不是 static 的元素（sticky 也会创建层叠上下文，这是一个神奇的实验中的属性值）</li><li>一个 z-index 值不为 auto 的 flex 项目 (flex item)</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity）</li><li>transform 属性值不为 none 的元素</li><li>mix-blend-mode 属性值不为 normal 的元素</li><li>有 transform、filter、perspective、clip-path、mask / mask-image / mask-border 这些属性中任意一个或多个属性的元素</li><li>isolation 属性被设置为 isolate的元素</li><li>在 will-change 中指定了任意CSS` 属性的元素（即使没有直接指定这些属性的值）</li><li>-webkit-overflow-scrolling 属性被设置 touch的元素</li><li>设置了 transform-style: preserve-3d 的元素</li></ul><p>在层叠上下文中的子元素也会按照上面的规则进行层叠，子元素的 z-index 值只在父级层叠上下文中有意义，子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</p><p>但是，并不是创建了新的层叠上下文的元素并不一定都会对其拥有position: fixed的子元素的效果产生影响，<br>在Chrome（Blink内核）中，可以明确看到产生了影响的是：</p><ul><li>transform 属性值不为 none 的元素</li><li>设置了 transform-style: preserve-3d 的元素</li><li>perspective 值不为 none 的元素</li><li>在 will-change 中指定了任意 CSS 属性的元素</li><li>但是，在不同的浏览器内核下，上述结论也会有所差异，例如，在 Safari（Webkit内核） 中，只有transform 属性值不为 none 的元素会对 fixed 定位的效果产生影响.</li></ul><p>参考文档：</p><p><a href="https://www.w3.org/TR/css-color-3/#transparency" target="_blank" rel="noopener">the specification for opacity - W3C</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">The stacking context - MDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一部分，position: fixed失效的问题；&lt;br&gt;第二部分，了解一下由此扯出的一个Stacking Context层叠上下文。&lt;/p&gt;
&lt;h1 id=&quot;关于-position-fixed&quot;&gt;&lt;a href=&quot;#关于-position-fixed&quot; class=&quot;h
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css3 transform对普通元素的n多渲染影响</title>
    <link href="https://summxu.github.io/2019/transform-element-impact/"/>
    <id>https://summxu.github.io/2019/transform-element-impact/</id>
    <published>2019-05-18T15:15:18.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 <code>position:fixed</code> 无效，问题是因为dilog定位时用了transform，深究下问题原因，发现事情并不是这么简单！</p></blockquote><p>一个普普通通的元素，如果应用了CSS3 transform变换，即便这个transform属性值不会改变其任何表面的变化（如scale(1), translate(0,0)），但是，实际上，对这些元素还是造成了很深远的影响。</p><h1 id="transform提升元素的垂直地位"><a href="#transform提升元素的垂直地位" class="headerlink" title="transform提升元素的垂直地位"></a>transform提升元素的垂直地位</h1><p>当遭遇元素margin负值重叠的时候，如果没有static以外的position属性值的话，后面的元素是会覆盖前面的元素的。<br><code>img src=&quot;mm1&quot;&gt;&lt;img src=&quot;mm2&quot; style=&quot;margin-left:-60px;&quot;&gt;</code><br>在transform出现之前，这个规则一直很稳健；但是，自从transform降临，这个规则就变了。元素应用了transform属性之后，就会变得应用了position:relative一个尿性，原本应该被覆盖的元素会雄起，变成覆盖其他元素，修改为如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm1"</span> <span class="attr">style</span>=<span class="string">"-ms-transform:scale(1);transform:scale(1);"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm2"</span> <span class="attr">style</span>=<span class="string">"margin-left:-60px;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要是支持transform元素的浏览器，包括IE9(-ms-), 都会提高普通元素的垂直地位，使其覆盖其他元素而不是被覆盖。</p><p>这种特性底层原理是层叠上下文，具体可参见“<a href="www.baidu.com">深入理解CSS中的层叠上下文和层叠顺序</a>”一文。</p><h1 id="transform限制position-fixed的跟随效果"><a href="#transform限制position-fixed的跟随效果" class="headerlink" title="transform限制position:fixed的跟随效果"></a>transform限制position:fixed的跟随效果</h1><p>我们应该都知道，<code>position:fixed</code>可以让元素不跟随浏览器的滚动条滚动，而且这种跟随效果连它的兄弟们<code>position:relative/absolute</code>都限制不了。但是，真是一物降一物，<code>position:fixed</code>固定效果却被小小的<code>transform</code>给干掉了，直接降级变成<code>position:absolute</code>的蛋疼表现。</p><p>例如下面示意代码：</p><p><code>&lt;p style=&quot;transform:scale(1);&quot;&gt;&lt;img src=&quot;mm1.jpg&quot;style=&quot;position:fixed;&quot; /&gt;&lt;/p&gt;</code><br>结果，本来应该不跟着滚动条滚动的傲娇<code>fixed</code>元素，变成<code>absolute</code>一样的行为表现，归根结底就是父元素加了个小小的<code>transform</code>属性值。</p><p>注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有，IE浏览器，包括IE11, <code>fixed</code>还是<code>fixed</code>的表现。</p><h1 id="transform改变overflow对absolute元素的限制"><a href="#transform改变overflow对absolute元素的限制" class="headerlink" title="transform改变overflow对absolute元素的限制"></a>transform改变overflow对absolute元素的限制</h1><p>在以前，<code>overflow</code>与<code>absolute</code>之间的限制规范内容大致是这样的：</p><p><code>absolute</code>绝对定位元素，如果含有<code>overflow</code>不为<code>visible</code>的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有<code>position</code>为非<code>static</code>属性的声明，则<code>overflow</code>对该<code>absolute</code>元素不起作用。</p><p>比方说如下示意代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"width:96px; height:96px; border:2px solid #beceeb; overflow:hidden;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mm1.jpg"</span><span class="attr">style</span>=<span class="string">"position:absolute;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，一旦我们给<code>overflow</code>容器或者与图片有嵌套关系的子元素使用<code>transform</code>声明，估计<code>absolute</code>元素就要去领便当了！</p><p>无论是<code>overflow</code>容器还是嵌套子元素，只要有<code>transform</code>属性，就会<code>hidden</code>溢出的<code>absolute</code>元素。</p><h1 id="transform限制absolute的100-宽度大小"><a href="#transform限制absolute的100-宽度大小" class="headerlink" title="transform限制absolute的100%宽度大小"></a>transform限制absolute的100%宽度大小</h1><p>以前，我们设置<code>absolute</code>元素宽度100%, 则都会参照第一个非<code>static</code>值的<code>position</code>祖先元素计算，没有就<code>window</code>. 现在，需要把<code>transform</code>也考虑在内了。</p><p>结果，无论是IE9+，还是Chrome还是FireFox浏览器，所有绝对定位图片100%宽度，都是相对设置了<code>transform</code>的容器计算了，于是，上面的图片拉长到了西伯利亚；下面的图片被限制成了小胖墩。</p><p><code>transform</code>对<code>absolute</code>宽度100%限制~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;问题原因：项目中用到了vant框架，在dilog中想要弹出Actionsheet发现绝对定位是跟着dilog外层元素定位，此时的 &lt;code&gt;position:fixed&lt;/code&gt; 无效，问题是因为dilog定位时用了transform，深究下
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://summxu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>基于 document.execCommand 的富文本</title>
    <link href="https://summxu.github.io/2019/rich-text-editor-by-execCommand/"/>
    <id>https://summxu.github.io/2019/rich-text-editor-by-execCommand/</id>
    <published>2019-04-30T13:05:35.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需求，但其提供的诸多功能是用不上的，可以使用更轻量的实现代替。</p><p>在寻找新的替代品时，也顺便瞄了下各种编辑器的内部实现。一些体积庞大的编辑器一般都兼容低版本浏览器，不得不写很多兼容性的代码。而一些 MINI、轻量的编辑器是不对低端浏览器作兼容的，使用<code>Selection</code>、<code>Range</code>或者<code>document.execCommand</code>实现。</p><p>之前在 JavaScript 获取输入时的光标位置及场景问题 中提到过<code>Selection</code>和<code>Range</code>，这次就说说<code>document.execCommand</code>。</p><h1 id="document-execCommand"><a href="#document-execCommand" class="headerlink" title="document.execCommand"></a>document.execCommand</h1><p>该方法可以对可编辑器区域进行操作，比如加粗文字、改变字号、插入链接等。可编辑区域也就是设置了<code>contentEditable</code>属性的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">bool = document.execCommand(commandName, showDefaultUI[, arg])</span><br></pre></td></tr></table></figure><ul><li><code>commandName</code>：String，命令的名称</li><li><code>showDefaultUI</code>：Boolean，是否展示用户界面（暂时没有发现“用户界面”指的是什么），一般为false</li><li><code>arg</code>：String，要传递的参数，比如插入链接需要传入一个 URL，可选</li><li>返回值：Boolean，表示操作是否支持或是否启用<br>假如要把选中的文字加粗，只需要这样：</li></ul><p><code>document.execCommand(&#39;bold&#39;, false)</code></p><h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>[<a href="http://static.imys.net/execCommand-support-2017113.jpg]" target="_blank" rel="noopener">http://static.imys.net/execCommand-support-2017113.jpg]</a></p><p>对于现代浏览器的兼容度较好，不过 Android 53 取消兼容的什么鬼？</p><p>除了了解该方法的兼容性外，还需要了解每一种可执行命令的兼容性。比如<code>decreaseFontSize</code>，给选中文字添加<code>small</code>标签，也就是小号字体，谷歌是不支持的。</p><p>可以使用以下方法检测命令是否在浏览器中支持：</p><p><code>document.queryCommandSupported(commandName)</code></p><h1 id="简陋的实现"><a href="#简陋的实现" class="headerlink" title="简陋的实现"></a>简陋的实现</h1><p>不到 50 行代码，基于<a href="https://imys.net/demo/cmdEditor.html" target="_blank" rel="noopener">document.execCommand实现富文本编辑器</a>。</p><p>有兴趣的同学可以以此为出发点，去开发一个具备完整功能的编辑器。懒得折腾的可以像我一样多搜索几下，找一个合适的轮子。😅</p><p>参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">MDN: document.execCommand</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack按需打包Lodash的几种方式</title>
    <link href="https://summxu.github.io/2019/webpack-use-lodash/"/>
    <id>https://summxu.github.io/2019/webpack-use-lodash/</id>
    <published>2019-04-16T05:23:06.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<p>在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。</p><p>ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 71k 的体积。不能为了吃一口饭而买下一个饭店啊。</p><p>针对这个问题，其实已经有很多可选方案了。</p><h1 id="函数模块"><a href="#函数模块" class="headerlink" title="函数模块"></a>函数模块</h1><p>Lodash 中的每个函数在 NPM 都有一个单独的发布模块。<code>NPM: results for ‘lodash’</code><br>假如你只需要使用<code>_.isEqual</code>，那么你只需要安装<code>lodash.isequal</code>模块，然后按以下方式引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEqual = <span class="built_in">require</span>(<span class="string">'lodash.isequal'</span>)</span><br><span class="line"><span class="comment">// or ES6</span></span><br><span class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isequal'</span></span><br><span class="line">isEqual([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="全路径引用"><a href="#全路径引用" class="headerlink" title="全路径引用"></a>全路径引用</h1><p>在你完整安装 Lodash 后，可以按<code>lodash/函数名</code>的格式单独引入需要的函数模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> difference = <span class="built_in">require</span>(<span class="string">'lodash/difference'</span>)</span><br><span class="line"><span class="comment">// or ES6</span></span><br><span class="line"><span class="keyword">import</span> difference <span class="keyword">from</span> <span class="string">'lodash/difference'</span></span><br><span class="line">difference([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>])  <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure><h1 id="使用插件优化"><a href="#使用插件优化" class="headerlink" title="使用插件优化"></a>使用插件优化</h1><p>在简单场景下，以上两种方式足以解决问题。<br>而遇到复杂的数据对象时，我们不得不在一个文件中引入多个 Lodash 函数，这样就需要在文件中写多个<code>require</code>或<code>import</code>相关函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> remove <span class="keyword">from</span> <span class="string">'lodash/remove'</span></span><br><span class="line"><span class="keyword">import</span> uniq <span class="keyword">from</span> <span class="string">'lodash/uniq'</span></span><br><span class="line"><span class="keyword">import</span> invokeMap <span class="keyword">from</span> <span class="string">'lodash/invokeMap'</span></span><br><span class="line"><span class="keyword">import</span> sortBy <span class="keyword">from</span> <span class="string">'lodash/sortBy'</span></span><br><span class="line"><span class="comment">// more...</span></span><br></pre></td></tr></table></figure><p>正写到关键处却因为引入一个函数要拉到文件头部去定义引用而打乱了思路，很不爽！</p><p>于是我机智的到 Github 去搜索了webpack和lodash两个关键词的组合，排在首位的 lodash-webpack-plugin 就是为了解决这个问题而生。</p><p>使用时需要以下模块，其实除了前两个剩下的一般都已安装了：</p><p><code>$ npm i -S lodash-webpack-plugin babel-plugin-lodash babel-core babel-loader babel-preset-es2015 webpack</code><br><strong>配置：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"><span class="keyword">var</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      loader: <span class="string">'babel'</span>,</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        plugins: [<span class="string">'transform-runtime'</span>, <span class="string">'lodash'</span>],</span><br><span class="line">        presets: [<span class="string">'es2015'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> LodashModuleReplacementPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>babel-plugin-lodash</code>的配置，也就是<code>plugins: [&#39;lodash&#39;]</code>，并不是一定要在<code>loaders</code>中，也可以单独定义<code>babel</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"><span class="keyword">var</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      loader: <span class="string">'babel'</span>,</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  babel: &#123;</span><br><span class="line">    presets: [<span class="string">'es2015'</span>],</span><br><span class="line">    plugins: [<span class="string">'transform-runtime'</span>, <span class="string">'lodash'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> LodashModuleReplacementPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin,</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又或者是<code>.babelrc</code>文件中。</p><p>以上工作完成了，在每个你需要使用 lodash 函数的文件中只需要引用一次 lodash，即可调用任意函数而不会造成完全打包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line">_.add(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 打包时只会引入这一个函数模块</span></span><br></pre></td></tr></table></figure><p>注意：必须要使用 ES2015 的模块引用方式才有效。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>以上即是我目前所知道的几种方式，如果哪位朋友有更好的方式（比如只需要全局引入一次），请一定分享与我！😋</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。&lt;/p&gt;
&lt;p&gt;ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正确使用Vue指令的钩子函数</title>
    <link href="https://summxu.github.io/2019/vue-directive-hook/"/>
    <id>https://summxu.github.io/2019/vue-directive-hook/</id>
    <published>2019-03-24T07:28:24.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<p>在 Vue 中可以把一系列<strong>复杂的操作</strong>包装为一个指令。</p><blockquote><p><strong>什么是复杂的操作？</strong><br>我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段的掩盖等。我们总是期望以操作数据的形式来实现功能逻辑。</p></blockquote><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>对于自定义指令的定义，Vue2 有 5 个可选的钩子函数。</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li><li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。</li><li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind: 只调用一次，指令与元素解绑时调用。<br>接下来，定义一个简单的指令以验证这些钩子函数的触发时机。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-comp</span> <span class="attr">v-if</span>=<span class="string">"msg"</span> <span class="attr">:msg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"update"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"uninstall"</span>&gt;</span>卸载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"install"</span>&gt;</span>安装<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'bind'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inserted'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'componentUpdated'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'unbind'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> myComp = &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1 v-hello&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        msg: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">'Hello'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        myComp: myComp</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">'Hi'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        uninstall: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        install: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="string">'Hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="页面加载时"><a href="#页面加载时" class="headerlink" title="页面加载时"></a>页面加载时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind</span><br><span class="line">inserted</span><br></pre></td></tr></table></figure><h2 id="组件更新时"><a href="#组件更新时" class="headerlink" title="组件更新时"></a>组件更新时</h2><p>点击“更新”按钮，更改数据触发组件更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update</span><br><span class="line">componentUpdated</span><br></pre></td></tr></table></figure><h2 id="卸载组件时"><a href="#卸载组件时" class="headerlink" title="卸载组件时"></a>卸载组件时</h2><p>点击“卸载”按钮，数据置空否定判断以触发组件卸载。</p><p><code>unbind</code></p><h2 id="重新安装组件时"><a href="#重新安装组件时" class="headerlink" title="重新安装组件时"></a>重新安装组件时</h2><p>点击“安装”按钮，数据赋值肯定判断以触发组件重新安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind</span><br><span class="line">inserted</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>从案例的运行中，对 5 个钩子函数的触发时机有了初步的认识。存疑的也就是<code>bind</code>和<code>inserted</code>、<code>update</code>和<code>componentUpdated</code>的区别了。</p><h3 id="bind-和-inserted"><a href="#bind-和-inserted" class="headerlink" title="bind 和 inserted"></a>bind 和 inserted</h3><p>据文档所说，插入父节点时调用 inserted，来个测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.parentNode)  <span class="comment">// null</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bind'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.parentNode)  <span class="comment">// &lt;div id="app"&gt;...&lt;/div&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'inserted'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别在两个钩子函数中输出父节点：<strong>bind 时父节点为 null，inserted 时父节点存在。</strong></p><h3 id="update-和-componentUpdated"><a href="#update-和-componentUpdated" class="headerlink" title="update 和 componentUpdated"></a><strong>update</strong> 和 <strong>componentUpdated</strong></h3><p>关于这两个的介绍，从字眼上看感觉是组件更新周期有关，继续验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.innerHTML)   <span class="comment">// Hello</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el.innerHTML)   <span class="comment">// Hi</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentUpdated'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没毛病，<strong>update 和 componentUpdated 就是组件更新前和更新后的区别。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>文档说的没错…😒<br><a href="https://jsfiddle.net/imys/twbv0sov/1/" target="_blank" rel="noopener">Demo</a></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>根据需求的不同，我们要选择恰当的时机去初始化指令、更新指令调用参数以及释放指令存在时的内存占用等。</p><p>比较常见的场景是：用指令包装一些无依赖的第三方库以扩展组件功能。而一个健壮的库通常会包含：初始化实例、参数更新和释放实例资源占用等操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在 bind 钩子中初始化库实例</span></span><br><span class="line">        <span class="comment">// 如果需要使用父节点，也可以在 inserted 钩子中执行</span></span><br><span class="line">        el.__library__ = <span class="keyword">new</span> Library(el, binding.value)</span><br><span class="line">    &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 模版更新意味着指令的参数可能被改变，这里可以对库实例的参数作更新</span></span><br><span class="line">        <span class="comment">// 酌情使用 update 或 componentUpdated 钩子</span></span><br><span class="line">        el.__library__.setOptions(<span class="built_in">Object</span>.assign(binding.oldValue, binding.value))</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 释放实例</span></span><br><span class="line">        el.__library__.destory()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Vue 中可以把一系列&lt;strong&gt;复杂的操作&lt;/strong&gt;包装为一个指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是复杂的操作？&lt;/strong&gt;&lt;br&gt;我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://summxu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>使用队列解决插队业务场景</title>
    <link href="https://summxu.github.io/2019/queue-solve-continuous/"/>
    <id>https://summxu.github.io/2019/queue-solve-continuous/</id>
    <published>2019-03-01T01:02:36.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<p>为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。<br>但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。<br>理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。</p><p>我觉得用“插队”来描述这个场景真是再好不过了。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>既然有人要“插队”，我们就要定义一个规则：先进先出。<br>也就是数据结构中的“队列”了。</p><p>javascript 中队列的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="keyword">var</span> queue = []</span><br><span class="line"><span class="comment">// 进队</span></span><br><span class="line">queue.push(<span class="number">1</span>)</span><br><span class="line">queue.push(<span class="number">2</span>)</span><br><span class="line">queue.push(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">queue.shift() <span class="comment">// 1</span></span><br><span class="line">queue.shift() <span class="comment">// 2</span></span><br><span class="line">queue.shift() <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="keyword">var</span> queue2 = []</span><br><span class="line"><span class="comment">// 进队</span></span><br><span class="line">queue2.unshift(<span class="number">1</span>)</span><br><span class="line">queue2.unshift(<span class="number">2</span>)</span><br><span class="line">queue2.unshift(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">queue2.pop() <span class="comment">// 1</span></span><br><span class="line">queue2.pop() <span class="comment">// 2</span></span><br><span class="line">queue2.pop() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestQueue = []</span><br><span class="line"><span class="keyword">var</span> XHR = <span class="function"><span class="keyword">function</span>(<span class="params">method, url, param</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>点击操作的入口函数，先创建请求进队。<br>因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myClick</span>(<span class="params">method, url, param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = requestQueue.push(XHR(method, url, param))</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">1</span>) &#123;</span><br><span class="line">        update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的永远是队列中的第一个请求。<br>当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。<br>如果存在未完成的请求，继续调用更新操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    requestQueue[<span class="number">0</span>].then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// request success</span></span><br><span class="line">        requestQueue.shift()</span><br><span class="line">        requestQueue.length &amp;&amp; update()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。&lt;br&gt;但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。&lt;br&gt;理想的状态是上一个请求结束后
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何为Canvas中特定图形绑定事件？</title>
    <link href="https://summxu.github.io/2019/canvas-event/"/>
    <id>https://summxu.github.io/2019/canvas-event/</id>
    <published>2019-02-14T10:47:15.000Z</published>
    <updated>2023-12-25T09:35:30.926Z</updated>
    
    <content type="html"><![CDATA[<p>Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。<br>但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。</p><p>我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件时，动态判断当前响应元素为目标子节点时再执行对应的操作。</p><p>这个思想同样也可以用在 Canvas 上，只需要为 <code>canvas</code> 元素绑定事件，事件响应时判断当前鼠标位置处于哪个图形之上，执行对应的操作。</p><h1 id="isPointInPath"><a href="#isPointInPath" class="headerlink" title="isPointInPath"></a>isPointInPath</h1><p><code>context.isPointInPath(x, y);</code></p><p>理论上讲，想要知道一个点是否处于一个图形之中，现成的算法应该是有很多了。不过难得 canvas 本身就提供了这样的函数，用来判断一个点是否处于当前路径中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">'2d'</span>);</span><br><span class="line">ctx.rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ctx.isPointInPath(<span class="number">50</span>, <span class="number">100</span>))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>就像这样，当你创建一个矩形时，就会产生一个路径，此时就可以调用该方法去判断一个点是否存在于该路径。</p><p>产生路径的函数还有其他，比如：<code>lineTo()</code>、<code>clip()</code>、<code>arc()</code>、<code>arcTo()</code> 等。</p><h1 id="实现图形的事件绑定"><a href="#实现图形的事件绑定" class="headerlink" title="实现图形的事件绑定"></a>实现图形的事件绑定</h1><p>先来个简单的饼图吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> r = canvas.width / <span class="number">2</span>;</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#2196f3'</span>; <span class="comment">//蓝色</span></span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(r, r, r, <span class="built_in">Math</span>.PI * <span class="number">1</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#f44336'</span>; <span class="comment">//红色</span></span><br><span class="line">ctx.fill();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInPath</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx.isPointInPath(x, y);</span><br><span class="line">&#125;</span><br><span class="line">canvas.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isInPath(e.offsetX, e.offsetY)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在创建一个红蓝拼接的饼图，<code>isInPath</code> 方法判断一个点是否处于蓝色区。理想的结果是只有当鼠标点击区域为蓝色区域时才输出<code>hello。</code></p><p>但事实确不是如此，示例Demo。无论点击红色还是蓝色区域均会输出 <code>hello</code>，这是怎么回事呢</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>既然 <code>isPointInPath(x, y)</code> 的基于路径判断的，那我们就从路径入手。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#2196f3'</span>;</span><br><span class="line">ctx.fill();</span><br><span class="line">ctx.arc(r, r, r, <span class="built_in">Math</span>.PI * <span class="number">1</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#f44336'</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p>当我们把画图时的 <code>ctx.beginPath()</code> 去掉后，发现生成的图形变成一个红色的整圆了：示例Demo。</p><p><code>beginPath()</code> 用来重置路径，由于第一个半圆画完路径未重置，第二个半圆就绘制了两条路径。这似乎解释了上个问题的答案。</p><p>在 <code>isInPath(x, y)</code>函数中，由于路径没有重置，所以最终最终判断的不止是 <code>ctx.arc(r, r, r, 0, Math.PI * 1)</code> 这个路径，还有方法外的画红色圆的路径。两个路径加一起自然就是个整圆，所以无论蓝色区还是红色区都会输出。</p><h2 id="正确结果"><a href="#正确结果" class="headerlink" title="正确结果"></a>正确结果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInPath</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(r, r, r, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx.isPointInPath(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>isInPath</code> 函数，加入重置路径，结果正确输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。&lt;br&gt;但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。&lt;/p&gt;
&lt;p&gt;我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://summxu.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
