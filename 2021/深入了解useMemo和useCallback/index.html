<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>深入了解useMemo和useCallback</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content>
    <div style="display:none;"><img src="/img/avatar.jpg"></div>
    <meta property="og:image" content="https://summxu.github.io/img/avatar.jpg">
    <meta name="description" content="从 useMemo 开始。useMemo 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。 React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“re-render”。基于当前应用程序状态，每次重新呈现都是应用程序UI在给定时刻应该是什么样子的快照。可以把它想象成一堆照片，每一张照片都记录了给定每个状态变量的特定值时事物的样子。 每次“">
<meta name="keywords" content="JavaScript,HTML5,TypeScript,React,Angular,Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="深入了解useMemo和useCallback">
<meta property="og:url" content="https://summxu.github.io/2021/深入了解useMemo和useCallback/index.html">
<meta property="og:site_name" content="小兵旭旭的博客">
<meta property="og:description" content="从 useMemo 开始。useMemo 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。 React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“re-render”。基于当前应用程序状态，每次重新呈现都是应用程序UI在给定时刻应该是什么样子的快照。可以把它想象成一堆照片，每一张照片都记录了给定每个状态变量的特定值时事物的样子。 每次“">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2024-01-15T03:44:39.624Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入了解useMemo和useCallback">
<meta name="twitter:description" content="从 useMemo 开始。useMemo 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。 React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“re-render”。基于当前应用程序状态，每次重新呈现都是应用程序UI在给定时刻应该是什么样子的快照。可以把它想象成一堆照片，每一张照片都记录了给定每个状态变量的特定值时事物的样子。 每次“">
    
        <link rel="alternate" type="application/atom+xml" title="小兵旭旭的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">summxu</h5>
          <a href="mailto:chenxu4012@foxmail.com" title="chenxu4012@foxmail.com" class="mail">chenxu4012@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-align-right"></i>
                时间线
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/JavaScript"  >
                <i class="icon icon-lg icon-star"></i>
                分类标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-grav"></i>
                这是我
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/summxu" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/1938786603" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/atom.xml" target="_blank" >
                <i class="icon icon-lg icon-rss-square"></i>
                Rss
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">深入了解useMemo和useCallback</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">深入了解useMemo和useCallback</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-10-31T01:06:38.000Z" itemprop="datePublished" class="page-time">
  2021-10-31
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-示例1：大量的计算"><span class="post-toc-number">1.</span> <span class="post-toc-text">2. 示例1：大量的计算</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-示例2：保留引用"><span class="post-toc-number">2.</span> <span class="post-toc-text">3. 示例2：保留引用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-useCallback"><span class="post-toc-number">3.</span> <span class="post-toc-text">4. useCallback</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-什么时候使用这些-hook"><span class="post-toc-number">4.</span> <span class="post-toc-text">5. 什么时候使用这些 hook</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1-用于自定义-hook-内部"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">5.1 用于自定义 hook 内部</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-在-context-提供者"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">5.2 在 context 提供者</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-2021/深入了解useMemo和useCallback"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">深入了解useMemo和useCallback</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-10-31 09:06:38" datetime="2021-10-31T01:06:38.000Z"  itemprop="datePublished">2021-10-31</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>从 <code>useMemo</code> 开始。<code>useMemo</code> 的基本思想是它允许在渲染之间“记住”计算值。这个定义需要一些解释，先来解决这个问题。</p>
<p>React 做的主要事情是保持UI与应用程序状态同步。它用来做这件事的工具叫做“re-render”。基于当前应用程序状态，每次重新呈现都是应用程序UI在给定时刻应该是什么样子的快照。可以把它想象成一堆照片，每一张照片都记录了给定每个状态变量的特定值时事物的样子。</p>
<p>每次“re-render”都会根据当前状态在脑海中生成 DOM 应该是什么样子的图像。但实际上它是一堆JS对象，被称为“<strong>virtual DOM</strong>”。</p>
<p>不直接告诉 React 需要更改哪些 DOM 节点。相反，根据当前状态告诉React UI应该是什么样子。通过重新渲染，React 创建一个新的快照，它可以通过比较快照找出需要更改的内容，就像玩“寻找差异”游戏一样。</p>
<p>React 在开箱即用时进行了大量优化，所以通常情况下，重新渲染不是什么大问题。但是，在某些情况下，创建这些快照确实需要一些时间。这可能会导致性能问题，比如 UI 在用户执行操作后更新不够快。</p>
<p>而 <code>useMemo</code> 和 <code>useCallback</code> 是用来帮助优化重渲染的工具。他们通过两种方式做到这一点：</p>
<ol>
<li>减少在给定渲染中需要完成的工作量。</li>
<li>减少组件需要重新呈现的次数。</li>
</ol>
<p>让通过下面的栗子来理解它们吧。</p>
<h2 id="2-示例1：大量的计算"><a href="#2-示例1：大量的计算" class="headerlink" title="2. 示例1：大量的计算"></a>2. 示例1：大量的计算</h2><p>假设正在构建一个工具来帮助用户查找 0 到 <code>selectedNum</code> 之间的所有素数，其中 <code>selectedNum</code> 是用户提供的值。**质数是只能被1和自身整除的数，比如17。**下面是一个可能的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存储用户所选号码的状态。</span></span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算从 0 到用户选择的数字 selectedNum 之间的所有素数</span></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line"></span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:&#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;&#123;allPrimes.join(', ')&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定数字是否是素数的 Helper 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>有一个状态，一个叫做 <code>selectedNum</code> 的数字。使用 <code>for</code> 循环，手动计算 0 到 <code>selectedNum</code> 之间的所有素数。呈现一个受控制的数字输入，因此用户可以更改 <code>selectedNum</code> 。向用户显示计算的所有质数。</p>
<p>这段代码需要大量的计算。如果用户选择一个较大的 <code>selectedNum</code>，将需要遍历成千上万个数字，检查是否每个数字都是素数。而且，虽然有比我上面使用的更有效的质数检查算法，但它总是需要大量的计算。</p>
<p>有时确实需要执行这个计算，比如当用户选择一个新的 <code>selectedNum</code> 时。但是可能会遇到一些性能问题，如果在不需要做的时候无偿地做这项工作。</p>
<p>例如，让假设的例子还包含一个数字时钟:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// time 是一个每秒改变一次的状态变量，因此它总是与当前时间同步。</span></span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算所有质数（与前面的示例相同）</span></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">        &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label htmlFor="num"&gt;Your number:&lt;/</span>label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = React.useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  </span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearInterval(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>的应用程序现在有两个状态，<code>selectedNum</code> 和 <code>time</code>。时间变量每秒更新一次，以反映当前时间，该值用于呈现右上角的数字时钟。</p>
<p>问题在于：<strong>每当这些状态变量发生变化时，就会重新运行那些昂贵的质数计算。因为时间每秒改变一次，这意味着不断地重新生成质数列表，即使用户选择的数字没有改变！！！</strong></p>
<p>在 JavaScript 中，只有一个主线程，通过一遍又一遍地运行这段代码让它非常繁忙，每一秒。这意味着当用户尝试做其他事情时，应用程序可能会感到迟缓，特别是在低端设备上。</p>
<p>但如果可以“跳过”这些计算呢？如果已经有了一个给定数字的质数列表，为什么不重用这个值而不是每次都从头计算呢？这正是 <code>useMemo</code> 允许做的。它看起来是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allPrimes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      result.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;, [selectedNum]);</span><br></pre></td></tr></table></figure>

<p><code>useMemo</code> 有两个参数：</p>
<ol>
<li>要执行的工作块，封装在函数中</li>
<li>依赖项列表</li>
</ol>
<p>在挂载期间，当这个组件第一次呈现时，React 将调用这个函数来运行所有的逻辑，计算所有的质数。无论从这个函数返回什么，都被赋值给 <code>allPrimes</code> 变量。</p>
<p>然而，对于每一个后续渲染，React 都要做出选择。</p>
<ol>
<li>再次调用函数，重新计算值</li>
<li>重用它上次执行此工作时已经拥有的数据。</li>
</ol>
<p>为了做出选择，React 查看提供的依赖项列表。对于之前的渲染有任何改变吗？如果是，React 将重新运行提供的函数，以计算一个新的值。否则，它将跳过所有这些工作并重用之前计算的值。</p>
<p><code>useMemo</code> 本质上类似于缓存，依赖项是缓存失效策略。在本例中，实际上是在说“只有当 <code>selectedNum</code> 发生变化时才重新计算质数列表”。当组件由于其他原因重新呈现时（例如。当时间状态变量发生变化时），<code>useMemo</code> 忽略函数并传递缓存的值。</p>
<p>这通常被称为记忆，这就是为什么这个钩子被称为 <code>useMemo</code>。下面是这个解决方案的实时版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> allPrimes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">        result.push(counter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;, [selectedNum]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">        &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form&gt;</span></span><br><span class="line"><span class="regexp">        &lt;label htmlFor="num"&gt;Your number:&lt;/</span>label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = React.useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearInterval(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<code>useMemo</code> 钩子确实可以帮助避免这里不必要的计算。但它真的是这里的最佳解决方案吗？通常，可以通过重组应用程序中的内容来避免对 <code>useMemo</code> 的需求。可以这样做：</p>
<ol>
<li><code>PrimeCalculator.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PrimeCalculator;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>Clock.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">      &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useTime() &#123;</span></span><br><span class="line"><span class="regexp">  const [time, setTime] = React.useState(new Date());</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const intervalId = window.setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTime(new Date());</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    return () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      window.clearInterval(intervalId);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  return time;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Clock;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>App.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">'./Clock'</span>;</span><br><span class="line"><span class="keyword">import</span> PrimeCalculator <span class="keyword">from</span> <span class="string">'./PrimeCalculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;PrimeCalculator /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>我提取了两个新组件，<code>Clock</code> 和 <code>PrimeCalculator</code>。通过从 <code>App</code> 分支，这两个组件各自管理自己的状态。一个组件中的重新渲染不会影响另一个组件。</p>
<p>或许你听到很多关于提升状态的说法，但有时，更好的方法是将状态向下推。每个组件应该有一个单独的职责，在上面的例子中，<code>App</code> 正在做两件完全不相关的事情。</p>
<p>现在，这并不总是一个选择。在一个大型的现实应用中，有许多状态需要向上提升，而不能向下推。对于这种情况，我还有另一个妙计。让看一个例子。假设需要将 <code>time</code> 变量提升到 <code>PrimeCalculator</code> 之上：</p>
<ol>
<li><code>PrimeCalculator.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [selectedNum, setSelectedNum] = React.useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allPrimes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt; selectedNum; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(counter)) &#123;</span><br><span class="line">      allPrimes.push(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">"num"</span>&gt;Your number:<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"number"</span></span><br><span class="line">          value=&#123;selectedNum&#125;</span><br><span class="line">          onChange=&#123;(event) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了防止太大，将最大值设定在10万</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">Math</span>.min(<span class="number">100</span>_000, <span class="built_in">Number</span>(event.target.value));</span><br><span class="line">            </span><br><span class="line">            setSelectedNum(num);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        There are &#123;allPrimes.length&#125; prime(s) between 1 and &#123;selectedNum&#125;:</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;span className="prime-list"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;allPrimes.join(', ')&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(n));</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> counter = <span class="number">2</span>; counter &lt;= max; counter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % counter === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PrimeCalculator;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>Clock.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">'date-fns/format'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">&#123; time &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"clock"</span>&gt;</span><br><span class="line">      &#123;format(time, <span class="string">'hh:mm:ss a'</span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Clock;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>App.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getHours &#125; <span class="keyword">from</span> <span class="string">'date-fns'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">'./Clock'</span>;</span><br><span class="line"><span class="keyword">import</span> PrimeCalculator <span class="keyword">from</span> <span class="string">'./PrimeCalculator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将的PrimeCalculator转换为一个纯组件</span></span><br><span class="line"><span class="keyword">const</span> PurePrimeCalculator = React.memo(PrimeCalculator);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = useTime();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据一天中的时间选择一个合适的背景色</span></span><br><span class="line">  <span class="keyword">const</span> backgroundColor = getBackgroundColorFromTime(time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; backgroundColor &#125;&#125;&gt;</span><br><span class="line">      &lt;Clock time=&#123;time&#125; /&gt;</span><br><span class="line">      &lt;PurePrimeCalculator /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const getBackgroundColorFromTime = (time) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const hours = getHours(time);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  if (hours &lt; 12) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 早晨用的淡黄色</span></span><br><span class="line"><span class="regexp">    return 'hsl(50deg 100% 90%)';</span></span><br><span class="line"><span class="regexp">  &#125; else if (hours &lt; 18) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 下午暗淡的蓝色</span></span><br><span class="line"><span class="regexp">    return 'hsl(220deg 60% 92%)'</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 夜晚的深蓝色</span></span><br><span class="line"><span class="regexp">    return 'hsl(220deg 100% 80%)';</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function useTime() &#123;</span></span><br><span class="line"><span class="regexp">  const [time, setTime] = React.useState(new Date());</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const intervalId = window.setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTime(new Date());</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    return () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      window.clearInterval(intervalId);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;, []);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  return time;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p><code>React.memo</code> 包在组件周围，保护它免受不相关的更新。<code>PurePrimeCalculator</code> 只有在接收到新数据或内部状态发生变化时才会重新呈现。这就是所谓的纯组件。本质上，告诉 React 这个组件将总是在相同的输入条件下产生相同的输出，可以跳过没有任何改变的重新呈现。</p>
<p>在上面的例子中，我应用了 <code>React.memo</code> 到导入的 <code>PrimeCalculator</code> 组件。事实上,我选择了这样的结构，以便所有内容都在同一个文件中可见，以便更容易理解。在实践中，使用 <code>React.memo</code> 组件导出，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrimeCalculator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimeCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 这里的组件内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(PrimeCalculator);</span><br></pre></td></tr></table></figure>

<p>的 <code>PrimeCalculator</code> 组件现在将始终是纯的，当要使用它时，不需要对它进行修补。</p>
<p>这里有一个视角转换：之前，在记忆一个特定计算的结果，计算质数。然而，在本例中，我记住了整个组件。无论哪种方式，只有当用户选择一个新的 <code>selectedNum</code> 时，昂贵的计算才会重新运行。但优化的是父组件，而不是特定的慢代码行。</p>
<p>我并不是说一种方法比另一种更好；每种工具在工具箱中都有自己的位置。但在这个特定的情况下，我更喜欢这种方法。现在，如果您曾经尝试在现实世界的设置中使用纯组件，您可能会注意到一些特殊的东西：纯组件经常重新渲染相当多，即使看起来没有任何变化！这很好地将引入了 <code>useMemo</code> 解决的第二个问题。</p>
<h2 id="3-示例2：保留引用"><a href="#3-示例2：保留引用" class="headerlink" title="3. 示例2：保留引用"></a>3. 示例2：保留引用</h2><p>在下面的示例中，我创建了一个 <code>Boxes</code> 组件。它展示了一组彩色的盒子，用于某种装饰目的。我还有一个不相关的状态：用户名。</p>
<ol>
<li><code>Boxes.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Boxes</span>(<span class="params">&#123; boxes &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"boxes-wrapper"</span>&gt;</span><br><span class="line">      &#123;boxes.map(<span class="function">(<span class="params">boxStyles, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;div</span><br><span class="line">          key=&#123;index&#125;</span><br><span class="line">          className=<span class="string">"box"</span></span><br><span class="line">          style=&#123;boxStyles&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default React.memo(Boxes);</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>App.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Boxes <span class="keyword">from</span> <span class="string">'./Boxes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = React.useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [boxWidth, setBoxWidth] = React.useState(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> id = React.useId();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 尝试改变这些值</span></span><br><span class="line">  <span class="keyword">const</span> boxes = [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Boxes boxes=&#123;boxes&#125; /&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;label htmlFor=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-name`</span>&#125;&gt;</span><br><span class="line">          Name:</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          id=&#123;`$&#123;id&#125;-name`&#125;</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          value=&#123;name&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(event) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setName(event.target.value);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;label htmlFor=&#123;<span class="string">`<span class="subst">$&#123;id&#125;</span>-box-width`</span>&#125;&gt;</span><br><span class="line">          First box width:</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          id=&#123;`$&#123;id&#125;-box-width`&#125;</span></span><br><span class="line"><span class="regexp">          type="range"</span></span><br><span class="line"><span class="regexp">          min=&#123;1&#125;</span></span><br><span class="line"><span class="regexp">          max=&#123;5&#125;</span></span><br><span class="line"><span class="regexp">          step=&#123;0.01&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;boxWidth&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(event) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setBoxWidth(Number(event.target.value));</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>由于在 <code>boxes.js</code> 中使用了<code>React.memo()</code> 封装默认导出，<code>Boxes</code> 是一个纯组件。这意味着它应该只在它的<code>props</code>改变时重新渲染。然而，每当用户更改其名称时，<code>Boxes</code> 也会重新呈现。</p>
<p>为什么的 <code>React.memo()</code> 没有保护？盒子组件只有1个<code>prop</code>，盒子，它看起来好像给它在每次渲染完全相同的数据。总是一样的东西：一个红盒子，一个紫色的宽盒子，一个黄色的盒子。确实有一个影响<code>boxes</code> 数组的 <code>boxWidth</code> 状态变量，但没有更改它！</p>
<p>问题在于：每次 React 重新渲染时，都会生成一个全新的数组。它们在值上是相等的，但在参照物上是不同的。我想如果先不谈 React，只谈普通的 JavaScript，会很有帮助。让来看一个类似的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> firstResult = getNumbers();</span><br><span class="line"><span class="keyword">const</span> secondResult = getNumbers();</span><br><span class="line"><span class="built_in">console</span>.log(firstResult === secondResult);</span><br></pre></td></tr></table></figure>

<p>你怎么看？<code>firstResult</code> 是否等于 <code>secondResult</code>？从某种意义上说，的确如此。两个变量都具有相同的结构<code>[1,2,3]</code>。但这不是 <code>===</code> 运算符实际检查的内容。相反，<code>===</code> 检查两个表达式是否相同。已经创建了两个不同的数组。它们可能包含相同的内容，但它们不是同一个数组。</p>
<p>每次调用 <code>getNumbers</code> 函数时，都会创建一个全新的数组，它是保存在计算机内存中的一个不同的东西。如果多次调用它，将在内存中存储该数组的多个副本。注意，简单的数据类型——比如<strong>字符串</strong>、<strong>数字</strong>和<strong>布尔值</strong>——可以按值进行比较。但是当涉及到<strong>数组</strong>和<strong>对象</strong>时，它们只能通过<strong>引用</strong>进行比较。</p>
<p>让回到 React：的 <code>Boxes</code> React组件也是一个 JavaScript 函数。当渲染它时，调用那个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次渲染这个组件时，调用这个函数…</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最后创造了一个全新的数组</span></span><br><span class="line">  <span class="keyword">const</span> boxes = [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// .然后将其作为 prop 传递给该组件!</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Boxes boxes=&#123;boxes&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当名称状态改变时，的 <code>App</code> 组件将重新呈现，这将重新运行所有的代码。构造一个全新的 <code>boxes</code> 数组，并将其传递给的 <code>Boxes</code> 组件。从而导致盒子重新渲染，因为给了它一个全新的数组。盒子数组的结构在渲染之间没有改变，但这无关紧要。React 所知道的是，箱子 <code>prop</code> 已经收到了一个新创建的，从未见过的数组。要解决这个问题，可以使用 <code>useMemo</code> hook：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boxes = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123; <span class="attr">flex</span>: boxWidth, <span class="attr">background</span>: <span class="string">'hsl(345deg 100% 50%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">3</span>, <span class="attr">background</span>: <span class="string">'hsl(260deg 100% 40%)'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">background</span>: <span class="string">'hsl(50deg 100% 60%)'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;, [boxWidth]);</span><br></pre></td></tr></table></figure>

<p>与之前看到的质数例子不同，这里不担心计算成本很高的计算。的唯一目标是<strong>保留对特定数组的引用</strong>。将 <code>boxWidth</code> 列为一个依赖项，因为确实希望在用户调整红色框的宽度时重新呈现 <code>Boxes</code> 组件。然而，在 <code>useMemo</code> 中，重用了之前创建的 <code>boxes</code> 数组。</p>
<p>通过在多个渲染中保留相同的引用，允许纯组件按希望的方式工作，忽略不影响 UI 的渲染。</p>
<h2 id="4-useCallback"><a href="#4-useCallback" class="headerlink" title="4. useCallback"></a>4. useCallback</h2><p>前面了解了 <code>useMemo</code>。那 <code>useCallback</code> 呢？这是一个简短的版本：<strong>这是完全相同的事情，但用于函数而不是数组/对象</strong>。与数组和对象类似，函数是根据引用比较的，而不是根据值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functionOne = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> functionTwo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(functionOne === functionTwo); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这意味着，如果在组件中定义一个函数，它将在每次渲染时重新生成，每次生成一个相同但唯一的函数。让看一个例子：</p>
<ol>
<li><code>MegaBoost.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MegaBoost</span>(<span class="params">&#123; handleClick &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Render MegaBoost'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">      className=<span class="string">"mega-boost-button"</span></span><br><span class="line">      onClick=&#123;handleClick&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      MEGA BOOST!</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default React.memo(MegaBoost);</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>App.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MegaBoost <span class="keyword">from</span> <span class="string">'./MegaBoost'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleMegaBoost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          setCount(count + <span class="number">1</span>)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Click me!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MegaBoost handleClick=&#123;handleMegaBoost&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>这个栗子描述了一个典型的计数器应用程序，但有一个特殊的“Mega Boost”按钮。这个按钮大大增加了计数，以防你很匆忙，不想多次点击标准按钮。</p>
<p>多亏了 <code>React.memo</code>, <code>MegaBoost</code> 组件是一个纯组件。它不依赖于计数，但每当计数改变时它就会重新呈现！就像看到的盒子数组，这里的问题是在每个渲染上生成一个全新的函数。如果渲染 3 次，将创建 3 个单独的 <code>handleMegaBoost</code> 函数，突破 <code>React.memo</code>的保护。利用对 <code>useMemo</code> 的了解，可以像这样解决问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleMegaBoost = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p>返回的不是一个数组，而是一个函数。然后将此函数存储在 <code>handleMegaBoost</code> 变量中。这很有效，但还有更好的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleMegaBoost = React.useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue + <span class="number">1234</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p><code>useCallback</code> 的作用与 <code>useMemo</code> 相同，但它是专门为函数构建的。直接给它一个函数，它记住那个函数，在渲染之间进行线程处理。换句话说，这两个表达有相同的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.useCallback(<span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;&#125;, []);</span><br><span class="line"><span class="comment">// 在功能上等价于</span></span><br><span class="line">React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;&#125;, []);</span><br></pre></td></tr></table></figure>

<p><code>useCallback</code> 是语法糖。它的存在纯粹是为了让在记忆回调函数时更加方便。</p>
<h2 id="5-什么时候使用这些-hook"><a href="#5-什么时候使用这些-hook" class="headerlink" title="5. 什么时候使用这些 hook"></a>5. 什么时候使用这些 hook</h2><p>好了，已经看到了 <code>useMemo</code> 和 <code>useCallback</code> 如何允许跨多个渲染线程引用重用复杂的计算或避免破坏纯组件。问题是：应该多经常使用它？</p>
<p>在我个人看来，将每个对象/数组/函数包装在这些钩子中是浪费时间。在大多数情况下，好处是可以忽略不计的；React 是高度优化的，重新渲染通常不像通常认为的那样缓慢或昂贵！</p>
<p>使用这些钩子的最佳方式是响应问题。如果你注意到你的应用程序变得有点迟缓，你可以使用 <code>React Profiler</code> 来查找缓慢的渲染。在某些情况下，可以通过重构应用程序来提高性能。在其他情况下，<code>useMemo</code> 和<code>useCallback</code> 可以帮助加快速度。</p>
<h3 id="5-1-用于自定义-hook-内部"><a href="#5-1-用于自定义-hook-内部" class="headerlink" title="5.1 用于自定义 hook 内部"></a>5.1 用于自定义 hook 内部</h3><p>例如下面这个自定义 hook <code>useToggle</code>，它的工作方式几乎和 <code>useState</code> 完全一样，但只能在 <code>true</code> 和 <code>false</code> 之间切换状态变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isDarkMode, toggleDarkMode] = useToggle(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;toggleDarkMode&#125;&gt;</span><br><span class="line">      Toggle color theme</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面是如何定义这个自定义 hook 的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useToggle</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(initialValue);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> toggle = React.useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(<span class="function"><span class="params">v</span> =&gt;</span> !v);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [value, toggle];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>toggle</code> 函数是用 <code>useCallback</code> 记忆的。当我构建这样的自定义可重用钩子时，我希望使它们尽可能高效，因为我不知道将来会在哪里使用它们。在95%的情况下，这可能是多余的，但如果我使用这个钩子30或40次，这很有可能有助于提高应用程序的性能。</p>
<h3 id="5-2-在-context-提供者"><a href="#5-2-在-context-提供者" class="headerlink" title="5.2 在 context 提供者"></a>5.2 在 context 提供者</h3><p>当在具有 <code>context</code> 的应用程序之间共享数据时，通常会传递一个大对象作为 <code>value</code> 属性。记住这个对象通常是个好主意：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AuthContext = React.createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AuthProvider</span>(<span class="params">&#123; user, status, forgotPwLink, children &#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedValue = React.useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user,</span><br><span class="line">      status,</span><br><span class="line">      forgotPwLink,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [user, status, forgotPwLink]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider value=&#123;memoizedValue&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/AuthContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>为什么这是有益的？可能有几十个纯组件使用这个上下文。如果没有 <code>useMemo</code>，如果 <code>AuthProvider</code> 的父组件碰巧重新渲染，那么所有这些组件都将被迫重新渲染。</p>

        </div>

        


        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://summxu.github.io/2021/深入了解useMemo和useCallback/&title=《深入了解useMemo和useCallback》 — 小兵旭旭的博客&pic=https://summxu.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://summxu.github.io/2021/深入了解useMemo和useCallback/&title=《深入了解useMemo和useCallback》 — 小兵旭旭的博客&source=小兵旭旭" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://summxu.github.io/2021/深入了解useMemo和useCallback/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《深入了解useMemo和useCallback》 — 小兵旭旭的博客&url=https://summxu.github.io/2021/深入了解useMemo和useCallback/&via=https://summxu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://summxu.github.io/2021/深入了解useMemo和useCallback/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2022/Redux源码全面解析/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Redux源码全面解析</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/Vue的响应式原理/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Vue的响应式原理</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
  <div class="top" style="display: none;">
    
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


    <p>
      <!-- 
      <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i
            class="icon icon-lg icon-rss"></i></a></span>
       -->
      <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
    </p>
  </div>
  <div class="bottom">
    <p><span>summxu &copy;
        2017 -
        2024</span>
      <span>
        
        Power by Hexo
      </span>
    </p>
  </div>
</footer>
    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://summxu.github.io/2021/深入了解useMemo和useCallback/&title=《深入了解useMemo和useCallback》 — 小兵旭旭的博客&pic=https://summxu.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://summxu.github.io/2021/深入了解useMemo和useCallback/&title=《深入了解useMemo和useCallback》 — 小兵旭旭的博客&source=小兵旭旭" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://summxu.github.io/2021/深入了解useMemo和useCallback/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《深入了解useMemo和useCallback》 — 小兵旭旭的博客&url=https://summxu.github.io/2021/深入了解useMemo和useCallback/&via=https://summxu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://summxu.github.io/2021/深入了解useMemo和useCallback/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACqUlEQVR42u3awWodMQwF0Pz/T7fQVSHNm3sl+yWFM6sQnBkfBywh6eMjfn79ef7++fNv8je0v/n8xcMPHh4e3mjrXz3Jmtefzw8i5xV7wMPDw7vGa7eVX9MJ/nWwyUMRHh4e3k/jzVYmISfZCR4eHt7/zsvDRo5/vR4PDw/vp/Fm1/esPDFLpq/XWvDw8PAmXywaYN/78/X+Hh4eHt6oq942vdowkJceZrvFw8PDu8HLU9hZS2yP3xQy8PDw8N7Dyweh8jGpU8MB+dHj4eHh3eO15dpNYywH5P+Ah3fi4eHhXeYlr2hbXzfS6Hy0Cw8PD+/9vFOYvNiRkPI1eHh4ePd4bf89KRbMhk03qfZD6wsPDw/vKG+WyOapdj5AsPluEffw8PDw1rx8OLVtnu2HBhJ8PTSAh4eHt+DNNrFZkzfG8pGF6Lt4eHh4h3j5INTmms7Lwe1RfuR1FDw8PLxDvGKAqUyv82s9X//6yB52iIeHh3eIdyowtMl0XurNMQ9DV3h4eHiHeKdCQj5A0N7Ym/IEHh4e3g1ekmvvqW1dOcc8hCU8PDy8a7y8NNA+D8lu+bShAg8PD+8eb3+5t0lzHoqS90QpNR4eHt4h3uwVbSCZNc/yA6oTazw8PLwFLy+e5ulsm2q3pdu8fIyHh4d3g9eWa/PLfZYcJwEpPzI8PDy8G7x9EWE2ONUGmNkR4OHh4d3gbTYUzXMlo1HlYEEelvDw8PBu8GajAO2lfKqg0BZH8PDw8G7wbgw8tVs8G0iGSDw8PLySl5dHN6TNwa0CAx4eHt413tlBqFMljytDA3h4eHhv580S5WTlbDzrgYqHh4f3rby25NoGj30o+rIYgYeHh3eB117Z+6GodlQr/9t/BAY8PDy8o7xTDbB2XKBlbFJtPDw8vEO832DgkpcmE34fAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };

</script>

<script src="/js/main.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</body>
</html>
