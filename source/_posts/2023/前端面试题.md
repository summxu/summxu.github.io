---
title: 前端面试题
date: 2023-12-21 09:49:38
tags:
  - JavaScript
---

## React组件为什么不能返回多个元素
1. React组件最后会编译为render函数，函数的返回值只能是1个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的
2. react的虚拟DOM是一个树状结构，树的根节点只能是1个，如果有多个根节点，无法确认是在哪棵树上进行更新
- React组件怎样可以返回多个组件
  1. 使用HOC（高阶函数）
  2. 使用React.Fragment，会创建一个虚拟节点，但不会渲染到真实DOM中
  3. 使用数组返回

## 模块化
- amd
  浏览器的一种模块引用方式，define 定义模块（放大），使用 require 引入模块。
- esm
  esm 是 es6 的模块，通过 export、export default 导入，通过 import 引入
- CommonJS
  服务端（nodejs）中的引入方式，module.exports 导出 require 引入
- umd
  umd 是 amd 与 CommonJS 两种格式的兼容。既可以跑在浏览器，又可以跑在 Node 中

## 首屏优化策略
- 减小入口文件积:
  1. webpack 开启压缩js 压缩css 压缩image 分离样式
  2. 路由组件动态加载
- 静态资源http本地缓存,设置缓存响应头.
- UI框架按需加载, 使用 import 
- 开启GZip压缩
- 使用服务端渲染

## 错误捕获
- 后端接口错误: 通过代码拦截接口,错误码判断
- 使用 try catch 捕获错误
- `Vue.config.errorHandler` 函数全局捕获错误
- errorCaptured 生命周期捕获
- getDerivedStateFromError 渲染备用UI, componentDidCatch 打印错误

## Vue
  ### v-show和v-if有什么区别
  1. v-show 和 v-if 在效果上是一样的功能，都是使元素在页面上可见或者不可见。
  2. v-show 单纯的是修改css display:noe 实现的，v-if 则是在dom上添加或者删除元素。
  3. v-if 切换有一个局部编译/卸载的过程，包括怎么合适的重建事件监听和销毁子组件。
  4. v-if 切换会重新触发组件的生命周期。

  ### 有用过keep-alive吗？它有什么作用
  1. keep-alive 是一个内置组件，被他包裹的组件起到一个缓存作用，一般用到路由切换上面，不会被销毁。
  2. include 属性可以是一个正则表达式，也可以是一个数组，匹配哪些被他包裹的组件被缓存。
  3. max 属性表示最多可以缓存多少个组件。
  4. 被缓存的组件多了两个生命周期 actived 和 deactivated。
  5. includes 匹配的是组件的 name 选项。

  ### 为什么data属性是一个函数而不是一个对象
  - 组件中的data必须是一个函数，组件是用来复用的，为了防止data复用，将其定义为函数。
    1. 创建组件的时候是用同一个构造函数创建的，如果data是对象，就会让所有的组件实例共用了这一个data
    2. 而函数返回的内存地址是独立的，不会出现复用。
  - new Vue 实例中的data可以是一个对象，这是因为new Vue只会存在一个。

## Set && Map
- Set是一个类数组的数据结构，他的特点是无序且不重复的，我们称之为集合，它提供了 `add` `has` `delete` `clear` 等方法
  1. 可以利用set的无序性给对象排序
- WeakSet 的成员只能是可引用对象，没有遍历方法，没有size属性，WeakSet里面的引用只要在外部消失，它在 WeakSet里面的引用就会自动消失。
- Map是键值对的**有序**列表，而键和值都可以是任意类型，我们叫字典，提供了 `set` `get` `has` `delete` `clear` 等方法
  1. 可以利用map的有序性，给对象排序
  2. 可以利用map的size属性，统计对象中有多少成员
- WeakMap 没有遍历方法，没有clear方法，只接受对象作为键名，WeakMap的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失

## 性能优化
1. shouldComponentUpdate、pureComponent
2. useMemo useCallback
3. getDerviedStateFromProps
4. 使用Fragment
5. v-for/map使用正确的key
6. 拆分尽可能小的可复用组件，ErrorBoundary
7. 使用React.lazy和React.Suspense延迟加载不需要立马使用的组件

## webpack

### 简单说一下 webpack 的构建流程

> webpack 从启动到结束会依次执行以下流程：

1. 初始化参数：从**配置文件**和**shell**语句中读取与合并参数，得到最终的参数。
2. 开始编译：用得到的参数初始化 compiler 对象，加载所有配置的 plugin，执行 compiler 对象的 run 方法开始编译。
3. 编译模块：根据配置中的 entry 找出所有的入口文件, 从入口文件出发，递归找出该模块依赖的模块，调用所有配置的 Loader 对模块进行编译，直到所有依赖文件都经过编译。
4. 输出资源：编译完每个模块之后, 根据入口和模块之间的关系，组装成一个个包含多个模块的 chunk, 再把每个 chunk 转换成一个单独的文件加入到输出列表, 根据配置确定输出的路径和文件名，把文件内容写入到文件系统.

### Loader 和 Plugin 的区别
- loader 本质上是一个函数, 在该函数对接收到的内容进行转换，返回转换后的结果。
- 编写loader的思路:
  1. 开发规范: loader 支持链式调用,开发上遵循“单一职责.
  2. loader 入参`content`是源文件的内容, 通过 `this.getOptions()` 拿到额外配置的参数.
  3. loader 处理完之后的返回值可以通过`this.callback()`同步方式返回或者`this.async()`异步方式返回.
  4. 可以使用 schema-utils 来检验的我们的参数是否正确通过.
- plugin 可以扩展 webpack 的功能 ,webpack 实际上是一个微内核系统 (tapable), 在 Webpack 运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果. 
- 编写plugin的思路:
  1. plugin 是一个构造函数, `consturctor ` 能获取传入的配置参数
  2. apply() 方法可以得到 compiler 对象, compiler 暴露了和 webpack 整个生命周期相关的 hooks 
  3. compilation 暴露了与模块和依赖有关的粒度更小的事件hooks, 再使用相关的 API 对资源进行添加或者修改
  4. emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并可以进行修改.

### tree shaking 原理是什么

> ES Module的静态语法分析更好优化, umd 引入更难优化

- 先标记(添加注释)出模块导出值中哪些没有被动用过, .
- 使用 terser 删除掉这些没被用到的Dead Code。
- package.json sideEffects 就是告知webpack可以安全的删除未用到的exports

### 说一下 Babel 原理

> babel 是一个代码转换工具, 在webpack中以loader 的形式存在, jsx es6 转 es5

- 解析：将代码转换成 AST
- 转换：访问 AST 的节点进行变换操作生产新的 AST
- 生成：以新的 AST 为基础生成代码 详细参考 深入理解babel

### webpack 优化前端代码
- loader
  1. url-loader：可以设置一个阈值，大于阈值会交给 file-loader，小于阈值时返回文件 base64 形式编码（处理图片）。
  2. image-loader：加载并且压缩图片文件
  3. babel-loader：把 ES6 转换成 ES5。

- plugin
  1. terser-webpack-plugin：压缩js文件
  2. optimize-css-assets-webpack-plugin：压缩css代码。
  3. mini-css-extract-plugin：分离样式文件，css 提取为单独文件，支持按需加载。
  4. ModuleconcatenationPlugin：开启 Scope Hoisting。

- 配置
  1. tree-shaking
  2. splitChunks bundle 代码切割

## ReactNative

## Electron

## Nginx && Linux

  
## mini Vue

## mini React

反思复盘，整理零散知识点，完善知识体系

## 手写节流，防抖
- 节流
```JavaScript
function throttle(fn) {
  let canRun = true
  return function () {
    if(canRun === false) return
    canRun = false
    setTimeout(() => {
      fn.apply(this, arguments)
      canRun = true
    }, 500)
  }
}
```
- 防抖
```JavaScript
function debounce(fn) {
  let timer = null
  return function() {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, arguments)
    }, 500)
  }
}
```

## 手写Promise（没有考虑链式调用）
```JavaScript
  // 创建MyPromise类 
  class MyPromise {
    // 通过构造函数constructor，在执行这个类的时候需要传递一个执行器进去并立即调用
    constructor(executor) {
      this.status = 'pending'
      // 定义 fulfilled 情况下的返回值
      this.result = null
      // 定义 rejected 情况下的返回值
      this.reason = null
      // 定义回调函数数组
      this.onFulfilledCallbacks = []
      this.onRejectedCallbacks = []
      executor(this.resolve, this.reject)
    }
    // 定义resolve函数，改变状态和调用回调
    resolve = result => {
      if (this.status !== 'pending') return
      this.result = result
      this.status = 'fulfilled'
      // 执行数组里的 回调函数
      this.onFulfilledCallbacks.forEach(callback => callback(result))
    }
    // 定义reject函数，改变状态和调用回调
    reject = reason => {
      if (this.status !== 'pending') return
      this.reason = reason
      this.status = 'rejected'
      // 执行数组里的 回调函数
      this.onFulfilledCallbacks.forEach(callback => callback(reason))
    }
    // 定义then方法，接受两个回调函数
    then = (onFulfilled, onRejected) => {
      // 判断接受的回调函数，并可以为空给默认值
      onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : result => result
      if (this.status === 'fulfilled') {
        // fulfilled状态，调用第一个 fulfilled回调函数
        // 添加到宏任务，尽量晚于执行器后
        setTimeout(() => { onFulfilled(this.result) });
      } else if (this.status === 'rejected') {
        // rejected状态，调用第二个 rejected回调函数
        // 添加到宏任务，尽量晚于执行器后
        setTimeout(() => { onRejected(this.reason) });
      } else if (this.status === 'pending') {
        // 如果执行器中为异步（执行时机晚）不会立即改变状态，此时调用then一定是pending
        // 这个时候可以把回调函数保存到数组里，等待resolve/reject调用执行then
        this.onFulfilledCallbacks.push(onFulfilled)
        this.onRejectedCallbacks.push(onRejected)
      }
    }

    catch = (onRejected) => {
      setTimeout(() => { onRejected(this.reason) });
    }
  }

  new MyPromise((resolve, reject) => {
    setTimeout(() => { resolve('2秒之后执行then') }, 200);
  }).then(res => { console.log(res) })
```

## 冷知识
- valueOf 返回对象本身

## 面试技巧
1. 在日常的开发中，我对vue的使用更加频繁，但当有新需求给我的时候，我会考虑用更合适的技术方案去实现它，比如有时候可能会用react、甚至使用存js。我认为自己在技术上还是有一定的追求和理解，也经常关注一些前沿的解决方案。

## 知识体系学习
1. 书籍
2. 博客
3. 开源社区