---
title: 前端面试题
date: 2023-12-21 09:49:38
tags:
  - JavaScript
---

## React组件为什么不能返回多个元素
1. React组件最后会编译为render函数，函数的返回值只能是1个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的
2. react的虚拟DOM是一个树状结构，树的根节点只能是1个，如果有多个根节点，无法确认是在哪棵树上进行更新
- React组件怎样可以返回多个组件
  1. 使用HOC（高阶函数）
  2. 使用React.Fragment，会创建一个虚拟节点，但不会渲染到真实DOM中
  3. 使用数组返回

## 模块化
- amd
  浏览器的一种模块引用方式，define 定义模块（放大），使用 require 引入模块。
- esm
  esm 是 es6 的模块，通过 export、export default 导入，通过 import 引入
- CommonJS
  服务端（nodejs）中的引入方式，module.exports 导出 require 引入
- umd
  umd 是 amd 与 CommonJS 两种格式的兼容。既可以跑在浏览器，又可以跑在 Node 中

## 首屏优化策略
- 减小入口文件积:
  1. webpack 开启压缩js 压缩css 压缩image 分离样式
  2. 路由组件动态加载
- 静态资源http本地缓存,设置缓存响应头.
- UI框架按需加载, 使用 import 
- 开启GZip压缩
- 使用服务端渲染

## 错误捕获
- 后端接口错误: 通过代码拦截接口,错误码判断
- 使用 try catch 捕获错误
- `Vue.config.errorHandler` 函数全局捕获错误
- errorCaptured 生命周期捕获
- getDerivedStateFromError 渲染备用UI, componentDidCatch 打印错误

## webpack

### 简单说一下 webpack 的构建流程
> webpack 从启动到结束会依次执行以下流程：
1. 初始化参数：从**配置文件**和**shell**语句中读取与合并参数，得到最终的参数。
2. 开始编译：用得到的参数初始化 compiler 对象，加载所有配置的 plugin，执行 compiler 对象的 run 方法开始编译。
3. 编译模块：根据配置中的 entry 找出所有的入口文件, 从入口文件出发，递归找出该模块依赖的模块，调用所有配置的 Loader 对模块进行编译，直到所有依赖文件都经过编译。
4. 输出资源：编译完每个模块之后, 根据入口和模块之间的关系，组装成一个个包含多个模块的 chunk, 再把每个 chunk 转换成一个单独的文件加入到输出列表, 根据配置确定输出的路径和文件名，把文件内容写入到文件系统.

### Loader 和 Plugin 的区别
- loader 本质上是一个函数, 在该函数对接收到的内容进行转换，返回转换后的结果。
- 编写loader的思路:
  1. 开发规范: loader 支持链式调用,开发上遵循“单一职责.
  2. loader 入参`content`是源文件的内容, 通过 `this.getOptions()` 拿到额外配置的参数.
  3. loader 处理完之后的返回值可以通过`this.callback()`同步方式返回或者`this.async()`异步方式返回.
  4. 可以使用 schema-utils 来检验的我们的参数是否正确通过.
- plugin 可以扩展 webpack 的功能 ,webpack 实际上是一个微内核系统 (tapable), 在 Webpack 运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果. 
- 编写plugin的思路:
  1. plugin 是一个构造函数, `consturctor ` 能获取传入的配置参数
  2. apply() 方法可以得到 compiler 对象, compiler 暴露了和 webpack 整个生命周期相关的 hooks 
  3. compilation 暴露了与模块和依赖有关的粒度更小的事件hooks, 再使用相关的 API 对资源进行添加或者修改
  4. emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并可以进行修改.

### tree shaking 原理是什么
> ES Module的静态语法分析更好优化, umd 引入更难优化
- 先标记(添加注释)出模块导出值中哪些没有被动用过, .
- 使用 terser 删除掉这些没被用到的Dead Code。
- package.json sideEffects 就是告知webpack可以安全的删除未用到的exports

### 说一下 Babel 原理
> babel 是一个代码转换工具, 在webpack中以loader 的形式存在, jsx es6 转 es5
- 解析：将代码转换成 AST
- 转换：访问 AST 的节点进行变换操作生产新的 AST
- 生成：以新的 AST 为基础生成代码 详细参考 深入理解babel

### webpack 优化前端代码
- loader
  1. url-loader：可以设置一个阈值，大于阈值会交给 file-loader，小于阈值时返回文件 base64 形式编码（处理图片）。
  2. image-loader：加载并且压缩图片文件
  3. babel-loader：把 ES6 转换成 ES5。

- plugin
  1. terser-webpack-plugin：压缩js文件
  2. optimize-css-assets-webpack-plugin：压缩css代码。
  3. mini-css-extract-plugin：分离样式文件，css 提取为单独文件，支持按需加载。
  4. ModuleconcatenationPlugin：开启 Scope Hoisting。

- 配置
  1. tree-shaking
  2. splitChunks bundle 代码切割

## ReactNative

## Electron

## Nginx && Linux

  
## mini Vue

## mini React

反思复盘，整理零散知识点，完善知识体系

## 手写Promise（没有考虑链式调用）
```JavaScript
  // 创建MyPromise类 
  class MyPromise {
    // 通过构造函数constructor，在执行这个类的时候需要传递一个执行器进去并立即调用
    constructor(executor) {
      this.status = 'pending'
      // 定义 fulfilled 情况下的返回值
      this.result = null
      // 定义 rejected 情况下的返回值
      this.reason = null
      // 定义回调函数数组
      this.onFulfilledCallbacks = []
      this.onRejectedCallbacks = []
      executor(this.resolve, this.reject)
    }
    // 定义resolve函数，改变状态和调用回调
    resolve = result => {
      if (this.status !== 'pending') return
      this.result = result
      this.status = 'fulfilled'
      // 执行数组里的 回调函数
      this.onFulfilledCallbacks.forEach(callback => callback(result))
    }
    // 定义reject函数，改变状态和调用回调
    reject = reason => {
      if (this.status !== 'pending') return
      this.reason = reason
      this.status = 'rejected'
      // 执行数组里的 回调函数
      this.onFulfilledCallbacks.forEach(callback => callback(reason))
    }
    // 定义then方法，接受两个回调函数
    then = (onFulfilled, onRejected) => {
      // 判断接受的回调函数，并可以为空给默认值
      onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : result => result
      if (this.status === 'fulfilled') {
        // fulfilled状态，调用第一个 fulfilled回调函数
        // 添加到宏任务，尽量晚于执行器后
        setTimeout(() => { onFulfilled(this.result) });
      } else if (this.status === 'rejected') {
        // rejected状态，调用第二个 rejected回调函数
        // 添加到宏任务，尽量晚于执行器后
        setTimeout(() => { onRejected(this.reason) });
      } else if (this.status === 'pending') {
        // 如果执行器中为异步（执行时机晚）不会立即改变状态，此时调用then一定是pending
        // 这个时候可以把回调函数保存到数组里，等待resolve/reject调用执行then
        this.onFulfilledCallbacks.push(onFulfilled)
        this.onRejectedCallbacks.push(onRejected)
      }
    }

    catch = (onRejected) => {
      setTimeout(() => { onRejected(this.reason) });
    }
  }

  new MyPromise((resolve, reject) => {
    setTimeout(() => { resolve('2秒之后执行then') }, 200);
  }).then(res => { console.log(res) })
```

## 面试技巧
1. 

## 知识体系学习
1. 书籍
2. 博客
3. 开源社区